function j2(t) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  var n = Array.from(typeof t == "string" ? [t] : t);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
  var i = n.reduce(function(o, l) {
    var u = l.match(/\n([\t ]+|(?!\s).)/g);
    return u ? o.concat(u.map(function(h) {
      var f, d;
      return (d = (f = h.match(/[\t ]/g)) === null || f === void 0 ? void 0 : f.length) !== null && d !== void 0 ? d : 0;
    })) : o;
  }, []);
  if (i.length) {
    var s = new RegExp(`
[	 ]{` + Math.min.apply(Math, i) + "}", "g");
    n = n.map(function(o) {
      return o.replace(s, `
`);
    });
  }
  n[0] = n[0].replace(/^\r?\n/, "");
  var a = n[0];
  return e.forEach(function(o, l) {
    var u = a.match(/(?:^|\n)( *)$/), h = u ? u[1] : "", f = o;
    typeof o == "string" && o.includes(`
`) && (f = String(o).split(`
`).map(function(d, p) {
      return p === 0 ? d : "" + h + d;
    }).join(`
`)), a += f + n[l + 1];
  }), a;
}
var bc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function aU(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var rh = {}, h5 = {
  get exports() {
    return rh;
  },
  set exports(t) {
    rh = t;
  }
};
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(bc, function() {
    var r = 1e3, n = 6e4, i = 36e5, s = "millisecond", a = "second", o = "minute", l = "hour", u = "day", h = "week", f = "month", d = "quarter", p = "year", m = "date", _ = "Invalid Date", v = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, k = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, x = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(w) {
      var g = ["th", "st", "nd", "rd"], M = w % 100;
      return "[" + w + (g[(M - 20) % 10] || g[M] || g[0]) + "]";
    } }, D = function(w, g, M) {
      var y = String(w);
      return !y || y.length >= g ? w : "" + Array(g + 1 - y.length).join(M) + w;
    }, F = { s: D, z: function(w) {
      var g = -w.utcOffset(), M = Math.abs(g), y = Math.floor(M / 60), N = M % 60;
      return (g <= 0 ? "+" : "-") + D(y, 2, "0") + ":" + D(N, 2, "0");
    }, m: function w(g, M) {
      if (g.date() < M.date())
        return -w(M, g);
      var y = 12 * (M.year() - g.year()) + (M.month() - g.month()), N = g.clone().add(y, f), it = M - N < 0, Y = g.clone().add(y + (it ? -1 : 1), f);
      return +(-(y + (M - N) / (it ? N - Y : Y - N)) || 0);
    }, a: function(w) {
      return w < 0 ? Math.ceil(w) || 0 : Math.floor(w);
    }, p: function(w) {
      return { M: f, y: p, w: h, d: u, D: m, h: l, m: o, s: a, ms: s, Q: d }[w] || String(w || "").toLowerCase().replace(/s$/, "");
    }, u: function(w) {
      return w === void 0;
    } }, P = "en", V = {};
    V[P] = x;
    var R = function(w) {
      return w instanceof T;
    }, O = function w(g, M, y) {
      var N;
      if (!g)
        return P;
      if (typeof g == "string") {
        var it = g.toLowerCase();
        V[it] && (N = it), M && (V[it] = M, N = it);
        var Y = g.split("-");
        if (!N && Y.length > 1)
          return w(Y[0]);
      } else {
        var Z = g.name;
        V[Z] = g, N = Z;
      }
      return !y && N && (P = N), N || !y && P;
    }, C = function(w, g) {
      if (R(w))
        return w.clone();
      var M = typeof g == "object" ? g : {};
      return M.date = w, M.args = arguments, new T(M);
    }, S = F;
    S.l = O, S.i = R, S.w = function(w, g) {
      return C(w, { locale: g.$L, utc: g.$u, x: g.$x, $offset: g.$offset });
    };
    var T = function() {
      function w(M) {
        this.$L = O(M.locale, null, !0), this.parse(M);
      }
      var g = w.prototype;
      return g.parse = function(M) {
        this.$d = function(y) {
          var N = y.date, it = y.utc;
          if (N === null)
            return new Date(NaN);
          if (S.u(N))
            return new Date();
          if (N instanceof Date)
            return new Date(N);
          if (typeof N == "string" && !/Z$/i.test(N)) {
            var Y = N.match(v);
            if (Y) {
              var Z = Y[2] - 1 || 0, J = (Y[7] || "0").substring(0, 3);
              return it ? new Date(Date.UTC(Y[1], Z, Y[3] || 1, Y[4] || 0, Y[5] || 0, Y[6] || 0, J)) : new Date(Y[1], Z, Y[3] || 1, Y[4] || 0, Y[5] || 0, Y[6] || 0, J);
            }
          }
          return new Date(N);
        }(M), this.$x = M.x || {}, this.init();
      }, g.init = function() {
        var M = this.$d;
        this.$y = M.getFullYear(), this.$M = M.getMonth(), this.$D = M.getDate(), this.$W = M.getDay(), this.$H = M.getHours(), this.$m = M.getMinutes(), this.$s = M.getSeconds(), this.$ms = M.getMilliseconds();
      }, g.$utils = function() {
        return S;
      }, g.isValid = function() {
        return this.$d.toString() !== _;
      }, g.isSame = function(M, y) {
        var N = C(M);
        return this.startOf(y) <= N && N <= this.endOf(y);
      }, g.isAfter = function(M, y) {
        return C(M) < this.startOf(y);
      }, g.isBefore = function(M, y) {
        return this.endOf(y) < C(M);
      }, g.$g = function(M, y, N) {
        return S.u(M) ? this[y] : this.set(N, M);
      }, g.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, g.valueOf = function() {
        return this.$d.getTime();
      }, g.startOf = function(M, y) {
        var N = this, it = !!S.u(y) || y, Y = S.p(M), Z = function($, j) {
          var W = S.w(N.$u ? Date.UTC(N.$y, j, $) : new Date(N.$y, j, $), N);
          return it ? W : W.endOf(u);
        }, J = function($, j) {
          return S.w(N.toDate()[$].apply(N.toDate("s"), (it ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(j)), N);
        }, X = this.$W, tt = this.$M, st = this.$D, lt = "set" + (this.$u ? "UTC" : "");
        switch (Y) {
          case p:
            return it ? Z(1, 0) : Z(31, 11);
          case f:
            return it ? Z(1, tt) : Z(0, tt + 1);
          case h:
            var U = this.$locale().weekStart || 0, Tt = (X < U ? X + 7 : X) - U;
            return Z(it ? st - Tt : st + (6 - Tt), tt);
          case u:
          case m:
            return J(lt + "Hours", 0);
          case l:
            return J(lt + "Minutes", 1);
          case o:
            return J(lt + "Seconds", 2);
          case a:
            return J(lt + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, g.endOf = function(M) {
        return this.startOf(M, !1);
      }, g.$set = function(M, y) {
        var N, it = S.p(M), Y = "set" + (this.$u ? "UTC" : ""), Z = (N = {}, N[u] = Y + "Date", N[m] = Y + "Date", N[f] = Y + "Month", N[p] = Y + "FullYear", N[l] = Y + "Hours", N[o] = Y + "Minutes", N[a] = Y + "Seconds", N[s] = Y + "Milliseconds", N)[it], J = it === u ? this.$D + (y - this.$W) : y;
        if (it === f || it === p) {
          var X = this.clone().set(m, 1);
          X.$d[Z](J), X.init(), this.$d = X.set(m, Math.min(this.$D, X.daysInMonth())).$d;
        } else
          Z && this.$d[Z](J);
        return this.init(), this;
      }, g.set = function(M, y) {
        return this.clone().$set(M, y);
      }, g.get = function(M) {
        return this[S.p(M)]();
      }, g.add = function(M, y) {
        var N, it = this;
        M = Number(M);
        var Y = S.p(y), Z = function(tt) {
          var st = C(it);
          return S.w(st.date(st.date() + Math.round(tt * M)), it);
        };
        if (Y === f)
          return this.set(f, this.$M + M);
        if (Y === p)
          return this.set(p, this.$y + M);
        if (Y === u)
          return Z(1);
        if (Y === h)
          return Z(7);
        var J = (N = {}, N[o] = n, N[l] = i, N[a] = r, N)[Y] || 1, X = this.$d.getTime() + M * J;
        return S.w(X, this);
      }, g.subtract = function(M, y) {
        return this.add(-1 * M, y);
      }, g.format = function(M) {
        var y = this, N = this.$locale();
        if (!this.isValid())
          return N.invalidDate || _;
        var it = M || "YYYY-MM-DDTHH:mm:ssZ", Y = S.z(this), Z = this.$H, J = this.$m, X = this.$M, tt = N.weekdays, st = N.months, lt = function(j, W, z, A) {
          return j && (j[W] || j(y, it)) || z[W].slice(0, A);
        }, U = function(j) {
          return S.s(Z % 12 || 12, j, "0");
        }, Tt = N.meridiem || function(j, W, z) {
          var A = j < 12 ? "AM" : "PM";
          return z ? A.toLowerCase() : A;
        }, $ = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: X + 1, MM: S.s(X + 1, 2, "0"), MMM: lt(N.monthsShort, X, st, 3), MMMM: lt(st, X), D: this.$D, DD: S.s(this.$D, 2, "0"), d: String(this.$W), dd: lt(N.weekdaysMin, this.$W, tt, 2), ddd: lt(N.weekdaysShort, this.$W, tt, 3), dddd: tt[this.$W], H: String(Z), HH: S.s(Z, 2, "0"), h: U(1), hh: U(2), a: Tt(Z, J, !0), A: Tt(Z, J, !1), m: String(J), mm: S.s(J, 2, "0"), s: String(this.$s), ss: S.s(this.$s, 2, "0"), SSS: S.s(this.$ms, 3, "0"), Z: Y };
        return it.replace(k, function(j, W) {
          return W || $[j] || Y.replace(":", "");
        });
      }, g.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, g.diff = function(M, y, N) {
        var it, Y = S.p(y), Z = C(M), J = (Z.utcOffset() - this.utcOffset()) * n, X = this - Z, tt = S.m(this, Z);
        return tt = (it = {}, it[p] = tt / 12, it[f] = tt, it[d] = tt / 3, it[h] = (X - J) / 6048e5, it[u] = (X - J) / 864e5, it[l] = X / i, it[o] = X / n, it[a] = X / r, it)[Y] || X, N ? tt : S.a(tt);
      }, g.daysInMonth = function() {
        return this.endOf(f).$D;
      }, g.$locale = function() {
        return V[this.$L];
      }, g.locale = function(M, y) {
        if (!M)
          return this.$L;
        var N = this.clone(), it = O(M, y, !0);
        return it && (N.$L = it), N;
      }, g.clone = function() {
        return S.w(this.$d, this);
      }, g.toDate = function() {
        return new Date(this.valueOf());
      }, g.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, g.toISOString = function() {
        return this.$d.toISOString();
      }, g.toString = function() {
        return this.$d.toUTCString();
      }, w;
    }(), b = T.prototype;
    return C.prototype = b, [["$ms", s], ["$s", a], ["$m", o], ["$H", l], ["$W", u], ["$M", f], ["$y", p], ["$D", m]].forEach(function(w) {
      b[w[1]] = function(g) {
        return this.$g(g, w[0], w[1]);
      };
    }), C.extend = function(w, g) {
      return w.$i || (w(g, T, C), w.$i = !0), C;
    }, C.locale = O, C.isDayjs = R, C.unix = function(w) {
      return C(1e3 * w);
    }, C.en = V[P], C.Ls = V, C.p = {}, C;
  });
})(h5);
const kr = rh, Dn = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
}, B = {
  trace: (...t) => {
  },
  debug: (...t) => {
  },
  info: (...t) => {
  },
  warn: (...t) => {
  },
  error: (...t) => {
  },
  fatal: (...t) => {
  }
}, C1 = function(t = "fatal") {
  let e = Dn.fatal;
  typeof t == "string" ? (t = t.toLowerCase(), t in Dn && (e = Dn[t])) : typeof t == "number" && (e = t), B.trace = () => {
  }, B.debug = () => {
  }, B.info = () => {
  }, B.warn = () => {
  }, B.error = () => {
  }, B.fatal = () => {
  }, e <= Dn.fatal && (B.fatal = console.error ? console.error.bind(console, Fr("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", Fr("FATAL"))), e <= Dn.error && (B.error = console.error ? console.error.bind(console, Fr("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", Fr("ERROR"))), e <= Dn.warn && (B.warn = console.warn ? console.warn.bind(console, Fr("WARN"), "color: orange") : console.log.bind(console, "\x1B[33m", Fr("WARN"))), e <= Dn.info && (B.info = console.info ? console.info.bind(console, Fr("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", Fr("INFO"))), e <= Dn.debug && (B.debug = console.debug ? console.debug.bind(console, Fr("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", Fr("DEBUG"))), e <= Dn.trace && (B.trace = console.debug ? console.debug.bind(console, Fr("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", Fr("TRACE")));
}, Fr = (t) => `%c${kr().format("ss.SSS")} : ${t} : `;
var S1 = {};
Object.defineProperty(S1, "__esModule", { value: !0 });
var Jn = S1.sanitizeUrl = void 0, f5 = /^([^\w]*)(javascript|data|vbscript)/im, d5 = /&#(\w+)(^\w|;)?/g, p5 = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, g5 = /^([^:]+):/gm, y5 = [".", "/"];
function m5(t) {
  return y5.indexOf(t[0]) > -1;
}
function b5(t) {
  return t.replace(d5, function(e, r) {
    return String.fromCharCode(r);
  });
}
function _5(t) {
  var e = b5(t || "").replace(p5, "").trim();
  if (!e)
    return "about:blank";
  if (m5(e))
    return e;
  var r = e.match(g5);
  if (!r)
    return e;
  var n = r[0];
  return f5.test(n) ? "about:blank" : e;
}
Jn = S1.sanitizeUrl = _5;
function Go(t, e) {
  return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function x5(t, e) {
  return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function A1(t) {
  let e, r, n;
  t.length !== 2 ? (e = Go, r = (o, l) => Go(t(o), l), n = (o, l) => t(o) - l) : (e = t === Go || t === x5 ? t : v5, r = t, n = t);
  function i(o, l, u = 0, h = o.length) {
    if (u < h) {
      if (e(l, l) !== 0)
        return h;
      do {
        const f = u + h >>> 1;
        r(o[f], l) < 0 ? u = f + 1 : h = f;
      } while (u < h);
    }
    return u;
  }
  function s(o, l, u = 0, h = o.length) {
    if (u < h) {
      if (e(l, l) !== 0)
        return h;
      do {
        const f = u + h >>> 1;
        r(o[f], l) <= 0 ? u = f + 1 : h = f;
      } while (u < h);
    }
    return u;
  }
  function a(o, l, u = 0, h = o.length) {
    const f = i(o, l, u, h - 1);
    return f > u && n(o[f - 1], l) > -n(o[f], l) ? f - 1 : f;
  }
  return { left: i, center: a, right: s };
}
function v5() {
  return 0;
}
function k5(t) {
  return t === null ? NaN : +t;
}
const w5 = A1(Go), T5 = w5.right;
A1(k5).center;
const E5 = T5;
class uf extends Map {
  constructor(e, r = A5) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), e != null)
      for (const [n, i] of e)
        this.set(n, i);
  }
  get(e) {
    return super.get(hf(this, e));
  }
  has(e) {
    return super.has(hf(this, e));
  }
  set(e, r) {
    return super.set(C5(this, e), r);
  }
  delete(e) {
    return super.delete(S5(this, e));
  }
}
function hf({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : r;
}
function C5({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) ? t.get(n) : (t.set(n, r), r);
}
function S5({ _intern: t, _key: e }, r) {
  const n = e(r);
  return t.has(n) && (r = t.get(n), t.delete(n)), r;
}
function A5(t) {
  return t !== null && typeof t == "object" ? t.valueOf() : t;
}
var nh = Math.sqrt(50), ih = Math.sqrt(10), sh = Math.sqrt(2);
function L5(t, e, r) {
  var n, i = -1, s, a, o;
  if (e = +e, t = +t, r = +r, t === e && r > 0)
    return [t];
  if ((n = e < t) && (s = t, t = e, e = s), (o = X2(t, e, r)) === 0 || !isFinite(o))
    return [];
  if (o > 0) {
    let l = Math.round(t / o), u = Math.round(e / o);
    for (l * o < t && ++l, u * o > e && --u, a = new Array(s = u - l + 1); ++i < s; )
      a[i] = (l + i) * o;
  } else {
    o = -o;
    let l = Math.round(t * o), u = Math.round(e * o);
    for (l / o < t && ++l, u / o > e && --u, a = new Array(s = u - l + 1); ++i < s; )
      a[i] = (l + i) / o;
  }
  return n && a.reverse(), a;
}
function X2(t, e, r) {
  var n = (e - t) / Math.max(0, r), i = Math.floor(Math.log(n) / Math.LN10), s = n / Math.pow(10, i);
  return i >= 0 ? (s >= nh ? 10 : s >= ih ? 5 : s >= sh ? 2 : 1) * Math.pow(10, i) : -Math.pow(10, -i) / (s >= nh ? 10 : s >= ih ? 5 : s >= sh ? 2 : 1);
}
function ah(t, e, r) {
  var n = Math.abs(e - t) / Math.max(0, r), i = Math.pow(10, Math.floor(Math.log(n) / Math.LN10)), s = n / i;
  return s >= nh ? i *= 10 : s >= ih ? i *= 5 : s >= sh && (i *= 2), e < t ? -i : i;
}
function B5(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r < n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t)
      (i = e(i, ++n, t)) != null && (r < i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function D5(t, e) {
  let r;
  if (e === void 0)
    for (const n of t)
      n != null && (r > n || r === void 0 && n >= n) && (r = n);
  else {
    let n = -1;
    for (let i of t)
      (i = e(i, ++n, t)) != null && (r > i || r === void 0 && i >= i) && (r = i);
  }
  return r;
}
function I5(t) {
  return t;
}
var qo = 1, du = 2, oh = 3, Ao = 4, ff = 1e-6;
function M5(t) {
  return "translate(" + t + ",0)";
}
function N5(t) {
  return "translate(0," + t + ")";
}
function R5(t) {
  return (e) => +t(e);
}
function F5(t, e) {
  return e = Math.max(0, t.bandwidth() - e * 2) / 2, t.round() && (e = Math.round(e)), (r) => +t(r) + e;
}
function O5() {
  return !this.__axis;
}
function K2(t, e) {
  var r = [], n = null, i = null, s = 6, a = 6, o = 3, l = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5, u = t === qo || t === Ao ? -1 : 1, h = t === Ao || t === du ? "x" : "y", f = t === qo || t === oh ? M5 : N5;
  function d(p) {
    var m = n ?? (e.ticks ? e.ticks.apply(e, r) : e.domain()), _ = i ?? (e.tickFormat ? e.tickFormat.apply(e, r) : I5), v = Math.max(s, 0) + o, k = e.range(), x = +k[0] + l, D = +k[k.length - 1] + l, F = (e.bandwidth ? F5 : R5)(e.copy(), l), P = p.selection ? p.selection() : p, V = P.selectAll(".domain").data([null]), R = P.selectAll(".tick").data(m, e).order(), O = R.exit(), C = R.enter().append("g").attr("class", "tick"), S = R.select("line"), T = R.select("text");
    V = V.merge(V.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), R = R.merge(C), S = S.merge(C.append("line").attr("stroke", "currentColor").attr(h + "2", u * s)), T = T.merge(C.append("text").attr("fill", "currentColor").attr(h, u * v).attr("dy", t === qo ? "0em" : t === oh ? "0.71em" : "0.32em")), p !== P && (V = V.transition(p), R = R.transition(p), S = S.transition(p), T = T.transition(p), O = O.transition(p).attr("opacity", ff).attr("transform", function(b) {
      return isFinite(b = F(b)) ? f(b + l) : this.getAttribute("transform");
    }), C.attr("opacity", ff).attr("transform", function(b) {
      var w = this.parentNode.__axis;
      return f((w && isFinite(w = w(b)) ? w : F(b)) + l);
    })), O.remove(), V.attr("d", t === Ao || t === du ? a ? "M" + u * a + "," + x + "H" + l + "V" + D + "H" + u * a : "M" + l + "," + x + "V" + D : a ? "M" + x + "," + u * a + "V" + l + "H" + D + "V" + u * a : "M" + x + "," + l + "H" + D), R.attr("opacity", 1).attr("transform", function(b) {
      return f(F(b) + l);
    }), S.attr(h + "2", u * s), T.attr(h, u * v).text(_), P.filter(O5).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", t === du ? "start" : t === Ao ? "end" : "middle"), P.each(function() {
      this.__axis = F;
    });
  }
  return d.scale = function(p) {
    return arguments.length ? (e = p, d) : e;
  }, d.ticks = function() {
    return r = Array.from(arguments), d;
  }, d.tickArguments = function(p) {
    return arguments.length ? (r = p == null ? [] : Array.from(p), d) : r.slice();
  }, d.tickValues = function(p) {
    return arguments.length ? (n = p == null ? null : Array.from(p), d) : n && n.slice();
  }, d.tickFormat = function(p) {
    return arguments.length ? (i = p, d) : i;
  }, d.tickSize = function(p) {
    return arguments.length ? (s = a = +p, d) : s;
  }, d.tickSizeInner = function(p) {
    return arguments.length ? (s = +p, d) : s;
  }, d.tickSizeOuter = function(p) {
    return arguments.length ? (a = +p, d) : a;
  }, d.tickPadding = function(p) {
    return arguments.length ? (o = +p, d) : o;
  }, d.offset = function(p) {
    return arguments.length ? (l = +p, d) : l;
  }, d;
}
function P5(t) {
  return K2(qo, t);
}
function V5(t) {
  return K2(oh, t);
}
var Y5 = { value: () => {
} };
function Z2() {
  for (var t = 0, e = arguments.length, r = {}, n; t < e; ++t) {
    if (!(n = arguments[t] + "") || n in r || /[\s.]/.test(n))
      throw new Error("illegal type: " + n);
    r[n] = [];
  }
  return new $o(r);
}
function $o(t) {
  this._ = t;
}
function z5(t, e) {
  return t.trim().split(/^|\s+/).map(function(r) {
    var n = "", i = r.indexOf(".");
    if (i >= 0 && (n = r.slice(i + 1), r = r.slice(0, i)), r && !e.hasOwnProperty(r))
      throw new Error("unknown type: " + r);
    return { type: r, name: n };
  });
}
$o.prototype = Z2.prototype = {
  constructor: $o,
  on: function(t, e) {
    var r = this._, n = z5(t + "", r), i, s = -1, a = n.length;
    if (arguments.length < 2) {
      for (; ++s < a; )
        if ((i = (t = n[s]).type) && (i = U5(r[i], t.name)))
          return i;
      return;
    }
    if (e != null && typeof e != "function")
      throw new Error("invalid callback: " + e);
    for (; ++s < a; )
      if (i = (t = n[s]).type)
        r[i] = df(r[i], t.name, e);
      else if (e == null)
        for (i in r)
          r[i] = df(r[i], t.name, null);
    return this;
  },
  copy: function() {
    var t = {}, e = this._;
    for (var r in e)
      t[r] = e[r].slice();
    return new $o(t);
  },
  call: function(t, e) {
    if ((i = arguments.length - 2) > 0)
      for (var r = new Array(i), n = 0, i, s; n < i; ++n)
        r[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    for (s = this._[t], n = 0, i = s.length; n < i; ++n)
      s[n].value.apply(e, r);
  },
  apply: function(t, e, r) {
    if (!this._.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    for (var n = this._[t], i = 0, s = n.length; i < s; ++i)
      n[i].value.apply(e, r);
  }
};
function U5(t, e) {
  for (var r = 0, n = t.length, i; r < n; ++r)
    if ((i = t[r]).name === e)
      return i.value;
}
function df(t, e, r) {
  for (var n = 0, i = t.length; n < i; ++n)
    if (t[n].name === e) {
      t[n] = Y5, t = t.slice(0, n).concat(t.slice(n + 1));
      break;
    }
  return r != null && t.push({ name: e, value: r }), t;
}
var lh = "http://www.w3.org/1999/xhtml";
const pf = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: lh,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function _c(t) {
  var e = t += "", r = e.indexOf(":");
  return r >= 0 && (e = t.slice(0, r)) !== "xmlns" && (t = t.slice(r + 1)), pf.hasOwnProperty(e) ? { space: pf[e], local: t } : t;
}
function W5(t) {
  return function() {
    var e = this.ownerDocument, r = this.namespaceURI;
    return r === lh && e.documentElement.namespaceURI === lh ? e.createElement(t) : e.createElementNS(r, t);
  };
}
function H5(t) {
  return function() {
    return this.ownerDocument.createElementNS(t.space, t.local);
  };
}
function Q2(t) {
  var e = _c(t);
  return (e.local ? H5 : W5)(e);
}
function G5() {
}
function L1(t) {
  return t == null ? G5 : function() {
    return this.querySelector(t);
  };
}
function q5(t) {
  typeof t != "function" && (t = L1(t));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], a = s.length, o = n[i] = new Array(a), l, u, h = 0; h < a; ++h)
      (l = s[h]) && (u = t.call(l, l.__data__, h, s)) && ("__data__" in l && (u.__data__ = l.__data__), o[h] = u);
  return new gr(n, this._parents);
}
function J2(t) {
  return t == null ? [] : Array.isArray(t) ? t : Array.from(t);
}
function $5() {
  return [];
}
function tp(t) {
  return t == null ? $5 : function() {
    return this.querySelectorAll(t);
  };
}
function j5(t) {
  return function() {
    return J2(t.apply(this, arguments));
  };
}
function X5(t) {
  typeof t == "function" ? t = j5(t) : t = tp(t);
  for (var e = this._groups, r = e.length, n = [], i = [], s = 0; s < r; ++s)
    for (var a = e[s], o = a.length, l, u = 0; u < o; ++u)
      (l = a[u]) && (n.push(t.call(l, l.__data__, u, a)), i.push(l));
  return new gr(n, i);
}
function ep(t) {
  return function() {
    return this.matches(t);
  };
}
function rp(t) {
  return function(e) {
    return e.matches(t);
  };
}
var K5 = Array.prototype.find;
function Z5(t) {
  return function() {
    return K5.call(this.children, t);
  };
}
function Q5() {
  return this.firstElementChild;
}
function J5(t) {
  return this.select(t == null ? Q5 : Z5(typeof t == "function" ? t : rp(t)));
}
var tb = Array.prototype.filter;
function eb() {
  return Array.from(this.children);
}
function rb(t) {
  return function() {
    return tb.call(this.children, t);
  };
}
function nb(t) {
  return this.selectAll(t == null ? eb : rb(typeof t == "function" ? t : rp(t)));
}
function ib(t) {
  typeof t != "function" && (t = ep(t));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], a = s.length, o = n[i] = [], l, u = 0; u < a; ++u)
      (l = s[u]) && t.call(l, l.__data__, u, s) && o.push(l);
  return new gr(n, this._parents);
}
function np(t) {
  return new Array(t.length);
}
function sb() {
  return new gr(this._enter || this._groups.map(np), this._parents);
}
function gl(t, e) {
  this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = e;
}
gl.prototype = {
  constructor: gl,
  appendChild: function(t) {
    return this._parent.insertBefore(t, this._next);
  },
  insertBefore: function(t, e) {
    return this._parent.insertBefore(t, e);
  },
  querySelector: function(t) {
    return this._parent.querySelector(t);
  },
  querySelectorAll: function(t) {
    return this._parent.querySelectorAll(t);
  }
};
function ab(t) {
  return function() {
    return t;
  };
}
function ob(t, e, r, n, i, s) {
  for (var a = 0, o, l = e.length, u = s.length; a < u; ++a)
    (o = e[a]) ? (o.__data__ = s[a], n[a] = o) : r[a] = new gl(t, s[a]);
  for (; a < l; ++a)
    (o = e[a]) && (i[a] = o);
}
function lb(t, e, r, n, i, s, a) {
  var o, l, u = /* @__PURE__ */ new Map(), h = e.length, f = s.length, d = new Array(h), p;
  for (o = 0; o < h; ++o)
    (l = e[o]) && (d[o] = p = a.call(l, l.__data__, o, e) + "", u.has(p) ? i[o] = l : u.set(p, l));
  for (o = 0; o < f; ++o)
    p = a.call(t, s[o], o, s) + "", (l = u.get(p)) ? (n[o] = l, l.__data__ = s[o], u.delete(p)) : r[o] = new gl(t, s[o]);
  for (o = 0; o < h; ++o)
    (l = e[o]) && u.get(d[o]) === l && (i[o] = l);
}
function cb(t) {
  return t.__data__;
}
function ub(t, e) {
  if (!arguments.length)
    return Array.from(this, cb);
  var r = e ? lb : ob, n = this._parents, i = this._groups;
  typeof t != "function" && (t = ab(t));
  for (var s = i.length, a = new Array(s), o = new Array(s), l = new Array(s), u = 0; u < s; ++u) {
    var h = n[u], f = i[u], d = f.length, p = hb(t.call(h, h && h.__data__, u, n)), m = p.length, _ = o[u] = new Array(m), v = a[u] = new Array(m), k = l[u] = new Array(d);
    r(h, f, _, v, k, p, e);
    for (var x = 0, D = 0, F, P; x < m; ++x)
      if (F = _[x]) {
        for (x >= D && (D = x + 1); !(P = v[D]) && ++D < m; )
          ;
        F._next = P || null;
      }
  }
  return a = new gr(a, n), a._enter = o, a._exit = l, a;
}
function hb(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function fb() {
  return new gr(this._exit || this._groups.map(np), this._parents);
}
function db(t, e, r) {
  var n = this.enter(), i = this, s = this.exit();
  return typeof t == "function" ? (n = t(n), n && (n = n.selection())) : n = n.append(t + ""), e != null && (i = e(i), i && (i = i.selection())), r == null ? s.remove() : r(s), n && i ? n.merge(i).order() : i;
}
function pb(t) {
  for (var e = t.selection ? t.selection() : t, r = this._groups, n = e._groups, i = r.length, s = n.length, a = Math.min(i, s), o = new Array(i), l = 0; l < a; ++l)
    for (var u = r[l], h = n[l], f = u.length, d = o[l] = new Array(f), p, m = 0; m < f; ++m)
      (p = u[m] || h[m]) && (d[m] = p);
  for (; l < i; ++l)
    o[l] = r[l];
  return new gr(o, this._parents);
}
function gb() {
  for (var t = this._groups, e = -1, r = t.length; ++e < r; )
    for (var n = t[e], i = n.length - 1, s = n[i], a; --i >= 0; )
      (a = n[i]) && (s && a.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(a, s), s = a);
  return this;
}
function yb(t) {
  t || (t = mb);
  function e(f, d) {
    return f && d ? t(f.__data__, d.__data__) : !f - !d;
  }
  for (var r = this._groups, n = r.length, i = new Array(n), s = 0; s < n; ++s) {
    for (var a = r[s], o = a.length, l = i[s] = new Array(o), u, h = 0; h < o; ++h)
      (u = a[h]) && (l[h] = u);
    l.sort(e);
  }
  return new gr(i, this._parents).order();
}
function mb(t, e) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function bb() {
  var t = arguments[0];
  return arguments[0] = this, t.apply(null, arguments), this;
}
function _b() {
  return Array.from(this);
}
function xb() {
  for (var t = this._groups, e = 0, r = t.length; e < r; ++e)
    for (var n = t[e], i = 0, s = n.length; i < s; ++i) {
      var a = n[i];
      if (a)
        return a;
    }
  return null;
}
function vb() {
  let t = 0;
  for (const e of this)
    ++t;
  return t;
}
function kb() {
  return !this.node();
}
function wb(t) {
  for (var e = this._groups, r = 0, n = e.length; r < n; ++r)
    for (var i = e[r], s = 0, a = i.length, o; s < a; ++s)
      (o = i[s]) && t.call(o, o.__data__, s, i);
  return this;
}
function Tb(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function Eb(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function Cb(t, e) {
  return function() {
    this.setAttribute(t, e);
  };
}
function Sb(t, e) {
  return function() {
    this.setAttributeNS(t.space, t.local, e);
  };
}
function Ab(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttribute(t) : this.setAttribute(t, r);
  };
}
function Lb(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, r);
  };
}
function Bb(t, e) {
  var r = _c(t);
  if (arguments.length < 2) {
    var n = this.node();
    return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
  }
  return this.each((e == null ? r.local ? Eb : Tb : typeof e == "function" ? r.local ? Lb : Ab : r.local ? Sb : Cb)(r, e));
}
function ip(t) {
  return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView;
}
function Db(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function Ib(t, e, r) {
  return function() {
    this.style.setProperty(t, e, r);
  };
}
function Mb(t, e, r) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(t) : this.style.setProperty(t, n, r);
  };
}
function Nb(t, e, r) {
  return arguments.length > 1 ? this.each((e == null ? Db : typeof e == "function" ? Mb : Ib)(t, e, r ?? "")) : Ts(this.node(), t);
}
function Ts(t, e) {
  return t.style.getPropertyValue(e) || ip(t).getComputedStyle(t, null).getPropertyValue(e);
}
function Rb(t) {
  return function() {
    delete this[t];
  };
}
function Fb(t, e) {
  return function() {
    this[t] = e;
  };
}
function Ob(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    r == null ? delete this[t] : this[t] = r;
  };
}
function Pb(t, e) {
  return arguments.length > 1 ? this.each((e == null ? Rb : typeof e == "function" ? Ob : Fb)(t, e)) : this.node()[t];
}
function sp(t) {
  return t.trim().split(/^|\s+/);
}
function B1(t) {
  return t.classList || new ap(t);
}
function ap(t) {
  this._node = t, this._names = sp(t.getAttribute("class") || "");
}
ap.prototype = {
  add: function(t) {
    var e = this._names.indexOf(t);
    e < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t) {
    var e = this._names.indexOf(t);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t) {
    return this._names.indexOf(t) >= 0;
  }
};
function op(t, e) {
  for (var r = B1(t), n = -1, i = e.length; ++n < i; )
    r.add(e[n]);
}
function lp(t, e) {
  for (var r = B1(t), n = -1, i = e.length; ++n < i; )
    r.remove(e[n]);
}
function Vb(t) {
  return function() {
    op(this, t);
  };
}
function Yb(t) {
  return function() {
    lp(this, t);
  };
}
function zb(t, e) {
  return function() {
    (e.apply(this, arguments) ? op : lp)(this, t);
  };
}
function Ub(t, e) {
  var r = sp(t + "");
  if (arguments.length < 2) {
    for (var n = B1(this.node()), i = -1, s = r.length; ++i < s; )
      if (!n.contains(r[i]))
        return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? zb : e ? Vb : Yb)(r, e));
}
function Wb() {
  this.textContent = "";
}
function Hb(t) {
  return function() {
    this.textContent = t;
  };
}
function Gb(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function qb(t) {
  return arguments.length ? this.each(t == null ? Wb : (typeof t == "function" ? Gb : Hb)(t)) : this.node().textContent;
}
function $b() {
  this.innerHTML = "";
}
function jb(t) {
  return function() {
    this.innerHTML = t;
  };
}
function Xb(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function Kb(t) {
  return arguments.length ? this.each(t == null ? $b : (typeof t == "function" ? Xb : jb)(t)) : this.node().innerHTML;
}
function Zb() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Qb() {
  return this.each(Zb);
}
function Jb() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function t_() {
  return this.each(Jb);
}
function e_(t) {
  var e = typeof t == "function" ? t : Q2(t);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function r_() {
  return null;
}
function n_(t, e) {
  var r = typeof t == "function" ? t : Q2(t), n = e == null ? r_ : typeof e == "function" ? e : L1(e);
  return this.select(function() {
    return this.insertBefore(r.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function i_() {
  var t = this.parentNode;
  t && t.removeChild(this);
}
function s_() {
  return this.each(i_);
}
function a_() {
  var t = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function o_() {
  var t = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function l_(t) {
  return this.select(t ? o_ : a_);
}
function c_(t) {
  return arguments.length ? this.property("__data__", t) : this.node().__data__;
}
function u_(t) {
  return function(e) {
    t.call(this, e, this.__data__);
  };
}
function h_(t) {
  return t.trim().split(/^|\s+/).map(function(e) {
    var r = "", n = e.indexOf(".");
    return n >= 0 && (r = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: r };
  });
}
function f_(t) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var r = 0, n = -1, i = e.length, s; r < i; ++r)
        s = e[r], (!t.type || s.type === t.type) && s.name === t.name ? this.removeEventListener(s.type, s.listener, s.options) : e[++n] = s;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function d_(t, e, r) {
  return function() {
    var n = this.__on, i, s = u_(e);
    if (n) {
      for (var a = 0, o = n.length; a < o; ++a)
        if ((i = n[a]).type === t.type && i.name === t.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = r), i.value = e;
          return;
        }
    }
    this.addEventListener(t.type, s, r), i = { type: t.type, name: t.name, value: e, listener: s, options: r }, n ? n.push(i) : this.__on = [i];
  };
}
function p_(t, e, r) {
  var n = h_(t + ""), i, s = n.length, a;
  if (arguments.length < 2) {
    var o = this.node().__on;
    if (o) {
      for (var l = 0, u = o.length, h; l < u; ++l)
        for (i = 0, h = o[l]; i < s; ++i)
          if ((a = n[i]).type === h.type && a.name === h.name)
            return h.value;
    }
    return;
  }
  for (o = e ? d_ : f_, i = 0; i < s; ++i)
    this.each(o(n[i], e, r));
  return this;
}
function cp(t, e, r) {
  var n = ip(t), i = n.CustomEvent;
  typeof i == "function" ? i = new i(e, r) : (i = n.document.createEvent("Event"), r ? (i.initEvent(e, r.bubbles, r.cancelable), i.detail = r.detail) : i.initEvent(e, !1, !1)), t.dispatchEvent(i);
}
function g_(t, e) {
  return function() {
    return cp(this, t, e);
  };
}
function y_(t, e) {
  return function() {
    return cp(this, t, e.apply(this, arguments));
  };
}
function m_(t, e) {
  return this.each((typeof e == "function" ? y_ : g_)(t, e));
}
function* b_() {
  for (var t = this._groups, e = 0, r = t.length; e < r; ++e)
    for (var n = t[e], i = 0, s = n.length, a; i < s; ++i)
      (a = n[i]) && (yield a);
}
var D1 = [null];
function gr(t, e) {
  this._groups = t, this._parents = e;
}
function co() {
  return new gr([[document.documentElement]], D1);
}
function __() {
  return this;
}
gr.prototype = co.prototype = {
  constructor: gr,
  select: q5,
  selectAll: X5,
  selectChild: J5,
  selectChildren: nb,
  filter: ib,
  data: ub,
  enter: sb,
  exit: fb,
  join: db,
  merge: pb,
  selection: __,
  order: gb,
  sort: yb,
  call: bb,
  nodes: _b,
  node: xb,
  size: vb,
  empty: kb,
  each: wb,
  attr: Bb,
  style: Nb,
  property: Pb,
  classed: Ub,
  text: qb,
  html: Kb,
  raise: Qb,
  lower: t_,
  append: e_,
  insert: n_,
  remove: s_,
  clone: l_,
  datum: c_,
  on: p_,
  dispatch: m_,
  [Symbol.iterator]: b_
};
function _t(t) {
  return typeof t == "string" ? new gr([[document.querySelector(t)]], [document.documentElement]) : new gr([[t]], D1);
}
function I1(t) {
  return typeof t == "string" ? new gr([document.querySelectorAll(t)], [document.documentElement]) : new gr([J2(t)], D1);
}
function uo(t, e, r) {
  t.prototype = e.prototype = r, r.constructor = t;
}
function xc(t, e) {
  var r = Object.create(t.prototype);
  for (var n in e)
    r[n] = e[n];
  return r;
}
function Xi() {
}
var Ra = 0.7, yl = 1 / Ra, ms = "\\s*([+-]?\\d+)\\s*", Fa = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", bn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", x_ = /^#([0-9a-f]{3,8})$/, v_ = new RegExp(`^rgb\\(${ms},${ms},${ms}\\)$`), k_ = new RegExp(`^rgb\\(${bn},${bn},${bn}\\)$`), w_ = new RegExp(`^rgba\\(${ms},${ms},${ms},${Fa}\\)$`), T_ = new RegExp(`^rgba\\(${bn},${bn},${bn},${Fa}\\)$`), E_ = new RegExp(`^hsl\\(${Fa},${bn},${bn}\\)$`), C_ = new RegExp(`^hsla\\(${Fa},${bn},${bn},${Fa}\\)$`), gf = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
uo(Xi, Ri, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: yf,
  // Deprecated! Use color.formatHex.
  formatHex: yf,
  formatHex8: S_,
  formatHsl: A_,
  formatRgb: mf,
  toString: mf
});
function yf() {
  return this.rgb().formatHex();
}
function S_() {
  return this.rgb().formatHex8();
}
function A_() {
  return hp(this).formatHsl();
}
function mf() {
  return this.rgb().formatRgb();
}
function Ri(t) {
  var e, r;
  return t = (t + "").trim().toLowerCase(), (e = x_.exec(t)) ? (r = e[1].length, e = parseInt(e[1], 16), r === 6 ? bf(e) : r === 3 ? new or(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : r === 8 ? Lo(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : r === 4 ? Lo(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = v_.exec(t)) ? new or(e[1], e[2], e[3], 1) : (e = k_.exec(t)) ? new or(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = w_.exec(t)) ? Lo(e[1], e[2], e[3], e[4]) : (e = T_.exec(t)) ? Lo(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = E_.exec(t)) ? vf(e[1], e[2] / 100, e[3] / 100, 1) : (e = C_.exec(t)) ? vf(e[1], e[2] / 100, e[3] / 100, e[4]) : gf.hasOwnProperty(t) ? bf(gf[t]) : t === "transparent" ? new or(NaN, NaN, NaN, 0) : null;
}
function bf(t) {
  return new or(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function Lo(t, e, r, n) {
  return n <= 0 && (t = e = r = NaN), new or(t, e, r, n);
}
function up(t) {
  return t instanceof Xi || (t = Ri(t)), t ? (t = t.rgb(), new or(t.r, t.g, t.b, t.opacity)) : new or();
}
function ch(t, e, r, n) {
  return arguments.length === 1 ? up(t) : new or(t, e, r, n ?? 1);
}
function or(t, e, r, n) {
  this.r = +t, this.g = +e, this.b = +r, this.opacity = +n;
}
uo(or, ch, xc(Xi, {
  brighter(t) {
    return t = t == null ? yl : Math.pow(yl, t), new or(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Ra : Math.pow(Ra, t), new or(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new or(Ii(this.r), Ii(this.g), Ii(this.b), ml(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: _f,
  // Deprecated! Use color.formatHex.
  formatHex: _f,
  formatHex8: L_,
  formatRgb: xf,
  toString: xf
}));
function _f() {
  return `#${Di(this.r)}${Di(this.g)}${Di(this.b)}`;
}
function L_() {
  return `#${Di(this.r)}${Di(this.g)}${Di(this.b)}${Di((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function xf() {
  const t = ml(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${Ii(this.r)}, ${Ii(this.g)}, ${Ii(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function ml(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function Ii(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function Di(t) {
  return t = Ii(t), (t < 16 ? "0" : "") + t.toString(16);
}
function vf(t, e, r, n) {
  return n <= 0 ? t = e = r = NaN : r <= 0 || r >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new jr(t, e, r, n);
}
function hp(t) {
  if (t instanceof jr)
    return new jr(t.h, t.s, t.l, t.opacity);
  if (t instanceof Xi || (t = Ri(t)), !t)
    return new jr();
  if (t instanceof jr)
    return t;
  t = t.rgb();
  var e = t.r / 255, r = t.g / 255, n = t.b / 255, i = Math.min(e, r, n), s = Math.max(e, r, n), a = NaN, o = s - i, l = (s + i) / 2;
  return o ? (e === s ? a = (r - n) / o + (r < n) * 6 : r === s ? a = (n - e) / o + 2 : a = (e - r) / o + 4, o /= l < 0.5 ? s + i : 2 - s - i, a *= 60) : o = l > 0 && l < 1 ? 0 : a, new jr(a, o, l, t.opacity);
}
function B_(t, e, r, n) {
  return arguments.length === 1 ? hp(t) : new jr(t, e, r, n ?? 1);
}
function jr(t, e, r, n) {
  this.h = +t, this.s = +e, this.l = +r, this.opacity = +n;
}
uo(jr, B_, xc(Xi, {
  brighter(t) {
    return t = t == null ? yl : Math.pow(yl, t), new jr(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? Ra : Math.pow(Ra, t), new jr(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, r = this.l, n = r + (r < 0.5 ? r : 1 - r) * e, i = 2 * r - n;
    return new or(
      pu(t >= 240 ? t - 240 : t + 120, i, n),
      pu(t, i, n),
      pu(t < 120 ? t + 240 : t - 120, i, n),
      this.opacity
    );
  },
  clamp() {
    return new jr(kf(this.h), Bo(this.s), Bo(this.l), ml(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = ml(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${kf(this.h)}, ${Bo(this.s) * 100}%, ${Bo(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function kf(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function Bo(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function pu(t, e, r) {
  return (t < 60 ? e + (r - e) * t / 60 : t < 180 ? r : t < 240 ? e + (r - e) * (240 - t) / 60 : e) * 255;
}
const D_ = Math.PI / 180, I_ = 180 / Math.PI, bl = 18, fp = 0.96422, dp = 1, pp = 0.82521, gp = 4 / 29, bs = 6 / 29, yp = 3 * bs * bs, M_ = bs * bs * bs;
function mp(t) {
  if (t instanceof _n)
    return new _n(t.l, t.a, t.b, t.opacity);
  if (t instanceof zn)
    return bp(t);
  t instanceof or || (t = up(t));
  var e = bu(t.r), r = bu(t.g), n = bu(t.b), i = gu((0.2225045 * e + 0.7168786 * r + 0.0606169 * n) / dp), s, a;
  return e === r && r === n ? s = a = i : (s = gu((0.4360747 * e + 0.3850649 * r + 0.1430804 * n) / fp), a = gu((0.0139322 * e + 0.0971045 * r + 0.7141733 * n) / pp)), new _n(116 * i - 16, 500 * (s - i), 200 * (i - a), t.opacity);
}
function N_(t, e, r, n) {
  return arguments.length === 1 ? mp(t) : new _n(t, e, r, n ?? 1);
}
function _n(t, e, r, n) {
  this.l = +t, this.a = +e, this.b = +r, this.opacity = +n;
}
uo(_n, N_, xc(Xi, {
  brighter(t) {
    return new _n(this.l + bl * (t ?? 1), this.a, this.b, this.opacity);
  },
  darker(t) {
    return new _n(this.l - bl * (t ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var t = (this.l + 16) / 116, e = isNaN(this.a) ? t : t + this.a / 500, r = isNaN(this.b) ? t : t - this.b / 200;
    return e = fp * yu(e), t = dp * yu(t), r = pp * yu(r), new or(
      mu(3.1338561 * e - 1.6168667 * t - 0.4906146 * r),
      mu(-0.9787684 * e + 1.9161415 * t + 0.033454 * r),
      mu(0.0719453 * e - 0.2289914 * t + 1.4052427 * r),
      this.opacity
    );
  }
}));
function gu(t) {
  return t > M_ ? Math.pow(t, 1 / 3) : t / yp + gp;
}
function yu(t) {
  return t > bs ? t * t * t : yp * (t - gp);
}
function mu(t) {
  return 255 * (t <= 31308e-7 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055);
}
function bu(t) {
  return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function R_(t) {
  if (t instanceof zn)
    return new zn(t.h, t.c, t.l, t.opacity);
  if (t instanceof _n || (t = mp(t)), t.a === 0 && t.b === 0)
    return new zn(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
  var e = Math.atan2(t.b, t.a) * I_;
  return new zn(e < 0 ? e + 360 : e, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity);
}
function uh(t, e, r, n) {
  return arguments.length === 1 ? R_(t) : new zn(t, e, r, n ?? 1);
}
function zn(t, e, r, n) {
  this.h = +t, this.c = +e, this.l = +r, this.opacity = +n;
}
function bp(t) {
  if (isNaN(t.h))
    return new _n(t.l, 0, 0, t.opacity);
  var e = t.h * D_;
  return new _n(t.l, Math.cos(e) * t.c, Math.sin(e) * t.c, t.opacity);
}
uo(zn, uh, xc(Xi, {
  brighter(t) {
    return new zn(this.h, this.c, this.l + bl * (t ?? 1), this.opacity);
  },
  darker(t) {
    return new zn(this.h, this.c, this.l - bl * (t ?? 1), this.opacity);
  },
  rgb() {
    return bp(this).rgb();
  }
}));
const vc = (t) => () => t;
function _p(t, e) {
  return function(r) {
    return t + r * e;
  };
}
function F_(t, e, r) {
  return t = Math.pow(t, r), e = Math.pow(e, r) - t, r = 1 / r, function(n) {
    return Math.pow(t + n * e, r);
  };
}
function O_(t, e) {
  var r = e - t;
  return r ? _p(t, r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r) : vc(isNaN(t) ? e : t);
}
function P_(t) {
  return (t = +t) == 1 ? wa : function(e, r) {
    return r - e ? F_(e, r, t) : vc(isNaN(e) ? r : e);
  };
}
function wa(t, e) {
  var r = e - t;
  return r ? _p(t, r) : vc(isNaN(t) ? e : t);
}
const _l = function t(e) {
  var r = P_(e);
  function n(i, s) {
    var a = r((i = ch(i)).r, (s = ch(s)).r), o = r(i.g, s.g), l = r(i.b, s.b), u = wa(i.opacity, s.opacity);
    return function(h) {
      return i.r = a(h), i.g = o(h), i.b = l(h), i.opacity = u(h), i + "";
    };
  }
  return n.gamma = t, n;
}(1);
function V_(t, e) {
  e || (e = []);
  var r = t ? Math.min(e.length, t.length) : 0, n = e.slice(), i;
  return function(s) {
    for (i = 0; i < r; ++i)
      n[i] = t[i] * (1 - s) + e[i] * s;
    return n;
  };
}
function Y_(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function z_(t, e) {
  var r = e ? e.length : 0, n = t ? Math.min(r, t.length) : 0, i = new Array(n), s = new Array(r), a;
  for (a = 0; a < n; ++a)
    i[a] = M1(t[a], e[a]);
  for (; a < r; ++a)
    s[a] = e[a];
  return function(o) {
    for (a = 0; a < n; ++a)
      s[a] = i[a](o);
    return s;
  };
}
function U_(t, e) {
  var r = new Date();
  return t = +t, e = +e, function(n) {
    return r.setTime(t * (1 - n) + e * n), r;
  };
}
function $r(t, e) {
  return t = +t, e = +e, function(r) {
    return t * (1 - r) + e * r;
  };
}
function W_(t, e) {
  var r = {}, n = {}, i;
  (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
  for (i in e)
    i in t ? r[i] = M1(t[i], e[i]) : n[i] = e[i];
  return function(s) {
    for (i in r)
      n[i] = r[i](s);
    return n;
  };
}
var hh = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, _u = new RegExp(hh.source, "g");
function H_(t) {
  return function() {
    return t;
  };
}
function G_(t) {
  return function(e) {
    return t(e) + "";
  };
}
function xp(t, e) {
  var r = hh.lastIndex = _u.lastIndex = 0, n, i, s, a = -1, o = [], l = [];
  for (t = t + "", e = e + ""; (n = hh.exec(t)) && (i = _u.exec(e)); )
    (s = i.index) > r && (s = e.slice(r, s), o[a] ? o[a] += s : o[++a] = s), (n = n[0]) === (i = i[0]) ? o[a] ? o[a] += i : o[++a] = i : (o[++a] = null, l.push({ i: a, x: $r(n, i) })), r = _u.lastIndex;
  return r < e.length && (s = e.slice(r), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? l[0] ? G_(l[0].x) : H_(e) : (e = l.length, function(u) {
    for (var h = 0, f; h < e; ++h)
      o[(f = l[h]).i] = f.x(u);
    return o.join("");
  });
}
function M1(t, e) {
  var r = typeof e, n;
  return e == null || r === "boolean" ? vc(e) : (r === "number" ? $r : r === "string" ? (n = Ri(e)) ? (e = n, _l) : xp : e instanceof Ri ? _l : e instanceof Date ? U_ : Y_(e) ? V_ : Array.isArray(e) ? z_ : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? W_ : $r)(t, e);
}
function q_(t, e) {
  return t = +t, e = +e, function(r) {
    return Math.round(t * (1 - r) + e * r);
  };
}
var wf = 180 / Math.PI, fh = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function vp(t, e, r, n, i, s) {
  var a, o, l;
  return (a = Math.sqrt(t * t + e * e)) && (t /= a, e /= a), (l = t * r + e * n) && (r -= t * l, n -= e * l), (o = Math.sqrt(r * r + n * n)) && (r /= o, n /= o, l /= o), t * n < e * r && (t = -t, e = -e, l = -l, a = -a), {
    translateX: i,
    translateY: s,
    rotate: Math.atan2(e, t) * wf,
    skewX: Math.atan(l) * wf,
    scaleX: a,
    scaleY: o
  };
}
var Do;
function $_(t) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t + "");
  return e.isIdentity ? fh : vp(e.a, e.b, e.c, e.d, e.e, e.f);
}
function j_(t) {
  return t == null || (Do || (Do = document.createElementNS("http://www.w3.org/2000/svg", "g")), Do.setAttribute("transform", t), !(t = Do.transform.baseVal.consolidate())) ? fh : (t = t.matrix, vp(t.a, t.b, t.c, t.d, t.e, t.f));
}
function kp(t, e, r, n) {
  function i(u) {
    return u.length ? u.pop() + " " : "";
  }
  function s(u, h, f, d, p, m) {
    if (u !== f || h !== d) {
      var _ = p.push("translate(", null, e, null, r);
      m.push({ i: _ - 4, x: $r(u, f) }, { i: _ - 2, x: $r(h, d) });
    } else
      (f || d) && p.push("translate(" + f + e + d + r);
  }
  function a(u, h, f, d) {
    u !== h ? (u - h > 180 ? h += 360 : h - u > 180 && (u += 360), d.push({ i: f.push(i(f) + "rotate(", null, n) - 2, x: $r(u, h) })) : h && f.push(i(f) + "rotate(" + h + n);
  }
  function o(u, h, f, d) {
    u !== h ? d.push({ i: f.push(i(f) + "skewX(", null, n) - 2, x: $r(u, h) }) : h && f.push(i(f) + "skewX(" + h + n);
  }
  function l(u, h, f, d, p, m) {
    if (u !== f || h !== d) {
      var _ = p.push(i(p) + "scale(", null, ",", null, ")");
      m.push({ i: _ - 4, x: $r(u, f) }, { i: _ - 2, x: $r(h, d) });
    } else
      (f !== 1 || d !== 1) && p.push(i(p) + "scale(" + f + "," + d + ")");
  }
  return function(u, h) {
    var f = [], d = [];
    return u = t(u), h = t(h), s(u.translateX, u.translateY, h.translateX, h.translateY, f, d), a(u.rotate, h.rotate, f, d), o(u.skewX, h.skewX, f, d), l(u.scaleX, u.scaleY, h.scaleX, h.scaleY, f, d), u = h = null, function(p) {
      for (var m = -1, _ = d.length, v; ++m < _; )
        f[(v = d[m]).i] = v.x(p);
      return f.join("");
    };
  };
}
var X_ = kp($_, "px, ", "px)", "deg)"), K_ = kp(j_, ", ", ")", ")");
function Z_(t) {
  return function(e, r) {
    var n = t((e = uh(e)).h, (r = uh(r)).h), i = wa(e.c, r.c), s = wa(e.l, r.l), a = wa(e.opacity, r.opacity);
    return function(o) {
      return e.h = n(o), e.c = i(o), e.l = s(o), e.opacity = a(o), e + "";
    };
  };
}
const Q_ = Z_(O_);
var Es = 0, ga = 0, ia = 0, wp = 1e3, xl, ya, vl = 0, Fi = 0, kc = 0, Oa = typeof performance == "object" && performance.now ? performance : Date, Tp = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t) {
  setTimeout(t, 17);
};
function N1() {
  return Fi || (Tp(J_), Fi = Oa.now() + kc);
}
function J_() {
  Fi = 0;
}
function kl() {
  this._call = this._time = this._next = null;
}
kl.prototype = Ep.prototype = {
  constructor: kl,
  restart: function(t, e, r) {
    if (typeof t != "function")
      throw new TypeError("callback is not a function");
    r = (r == null ? N1() : +r) + (e == null ? 0 : +e), !this._next && ya !== this && (ya ? ya._next = this : xl = this, ya = this), this._call = t, this._time = r, dh();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, dh());
  }
};
function Ep(t, e, r) {
  var n = new kl();
  return n.restart(t, e, r), n;
}
function tx() {
  N1(), ++Es;
  for (var t = xl, e; t; )
    (e = Fi - t._time) >= 0 && t._call.call(void 0, e), t = t._next;
  --Es;
}
function Tf() {
  Fi = (vl = Oa.now()) + kc, Es = ga = 0;
  try {
    tx();
  } finally {
    Es = 0, rx(), Fi = 0;
  }
}
function ex() {
  var t = Oa.now(), e = t - vl;
  e > wp && (kc -= e, vl = t);
}
function rx() {
  for (var t, e = xl, r, n = 1 / 0; e; )
    e._call ? (n > e._time && (n = e._time), t = e, e = e._next) : (r = e._next, e._next = null, e = t ? t._next = r : xl = r);
  ya = t, dh(n);
}
function dh(t) {
  if (!Es) {
    ga && (ga = clearTimeout(ga));
    var e = t - Fi;
    e > 24 ? (t < 1 / 0 && (ga = setTimeout(Tf, t - Oa.now() - kc)), ia && (ia = clearInterval(ia))) : (ia || (vl = Oa.now(), ia = setInterval(ex, wp)), Es = 1, Tp(Tf));
  }
}
function Ef(t, e, r) {
  var n = new kl();
  return e = e == null ? 0 : +e, n.restart((i) => {
    n.stop(), t(i + e);
  }, e, r), n;
}
var nx = Z2("start", "end", "cancel", "interrupt"), ix = [], Cp = 0, Cf = 1, ph = 2, jo = 3, Sf = 4, gh = 5, Xo = 6;
function wc(t, e, r, n, i, s) {
  var a = t.__transition;
  if (!a)
    t.__transition = {};
  else if (r in a)
    return;
  sx(t, r, {
    name: e,
    index: n,
    // For context during callback.
    group: i,
    // For context during callback.
    on: nx,
    tween: ix,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: Cp
  });
}
function R1(t, e) {
  var r = on(t, e);
  if (r.state > Cp)
    throw new Error("too late; already scheduled");
  return r;
}
function Tn(t, e) {
  var r = on(t, e);
  if (r.state > jo)
    throw new Error("too late; already running");
  return r;
}
function on(t, e) {
  var r = t.__transition;
  if (!r || !(r = r[e]))
    throw new Error("transition not found");
  return r;
}
function sx(t, e, r) {
  var n = t.__transition, i;
  n[e] = r, r.timer = Ep(s, 0, r.time);
  function s(u) {
    r.state = Cf, r.timer.restart(a, r.delay, r.time), r.delay <= u && a(u - r.delay);
  }
  function a(u) {
    var h, f, d, p;
    if (r.state !== Cf)
      return l();
    for (h in n)
      if (p = n[h], p.name === r.name) {
        if (p.state === jo)
          return Ef(a);
        p.state === Sf ? (p.state = Xo, p.timer.stop(), p.on.call("interrupt", t, t.__data__, p.index, p.group), delete n[h]) : +h < e && (p.state = Xo, p.timer.stop(), p.on.call("cancel", t, t.__data__, p.index, p.group), delete n[h]);
      }
    if (Ef(function() {
      r.state === jo && (r.state = Sf, r.timer.restart(o, r.delay, r.time), o(u));
    }), r.state = ph, r.on.call("start", t, t.__data__, r.index, r.group), r.state === ph) {
      for (r.state = jo, i = new Array(d = r.tween.length), h = 0, f = -1; h < d; ++h)
        (p = r.tween[h].value.call(t, t.__data__, r.index, r.group)) && (i[++f] = p);
      i.length = f + 1;
    }
  }
  function o(u) {
    for (var h = u < r.duration ? r.ease.call(null, u / r.duration) : (r.timer.restart(l), r.state = gh, 1), f = -1, d = i.length; ++f < d; )
      i[f].call(t, h);
    r.state === gh && (r.on.call("end", t, t.__data__, r.index, r.group), l());
  }
  function l() {
    r.state = Xo, r.timer.stop(), delete n[e];
    for (var u in n)
      return;
    delete t.__transition;
  }
}
function ax(t, e) {
  var r = t.__transition, n, i, s = !0, a;
  if (r) {
    e = e == null ? null : e + "";
    for (a in r) {
      if ((n = r[a]).name !== e) {
        s = !1;
        continue;
      }
      i = n.state > ph && n.state < gh, n.state = Xo, n.timer.stop(), n.on.call(i ? "interrupt" : "cancel", t, t.__data__, n.index, n.group), delete r[a];
    }
    s && delete t.__transition;
  }
}
function ox(t) {
  return this.each(function() {
    ax(this, t);
  });
}
function lx(t, e) {
  var r, n;
  return function() {
    var i = Tn(this, t), s = i.tween;
    if (s !== r) {
      n = r = s;
      for (var a = 0, o = n.length; a < o; ++a)
        if (n[a].name === e) {
          n = n.slice(), n.splice(a, 1);
          break;
        }
    }
    i.tween = n;
  };
}
function cx(t, e, r) {
  var n, i;
  if (typeof r != "function")
    throw new Error();
  return function() {
    var s = Tn(this, t), a = s.tween;
    if (a !== n) {
      i = (n = a).slice();
      for (var o = { name: e, value: r }, l = 0, u = i.length; l < u; ++l)
        if (i[l].name === e) {
          i[l] = o;
          break;
        }
      l === u && i.push(o);
    }
    s.tween = i;
  };
}
function ux(t, e) {
  var r = this._id;
  if (t += "", arguments.length < 2) {
    for (var n = on(this.node(), r).tween, i = 0, s = n.length, a; i < s; ++i)
      if ((a = n[i]).name === t)
        return a.value;
    return null;
  }
  return this.each((e == null ? lx : cx)(r, t, e));
}
function F1(t, e, r) {
  var n = t._id;
  return t.each(function() {
    var i = Tn(this, n);
    (i.value || (i.value = {}))[e] = r.apply(this, arguments);
  }), function(i) {
    return on(i, n).value[e];
  };
}
function Sp(t, e) {
  var r;
  return (typeof e == "number" ? $r : e instanceof Ri ? _l : (r = Ri(e)) ? (e = r, _l) : xp)(t, e);
}
function hx(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function fx(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function dx(t, e, r) {
  var n, i = r + "", s;
  return function() {
    var a = this.getAttribute(t);
    return a === i ? null : a === n ? s : s = e(n = a, r);
  };
}
function px(t, e, r) {
  var n, i = r + "", s;
  return function() {
    var a = this.getAttributeNS(t.space, t.local);
    return a === i ? null : a === n ? s : s = e(n = a, r);
  };
}
function gx(t, e, r) {
  var n, i, s;
  return function() {
    var a, o = r(this), l;
    return o == null ? void this.removeAttribute(t) : (a = this.getAttribute(t), l = o + "", a === l ? null : a === n && l === i ? s : (i = l, s = e(n = a, o)));
  };
}
function yx(t, e, r) {
  var n, i, s;
  return function() {
    var a, o = r(this), l;
    return o == null ? void this.removeAttributeNS(t.space, t.local) : (a = this.getAttributeNS(t.space, t.local), l = o + "", a === l ? null : a === n && l === i ? s : (i = l, s = e(n = a, o)));
  };
}
function mx(t, e) {
  var r = _c(t), n = r === "transform" ? K_ : Sp;
  return this.attrTween(t, typeof e == "function" ? (r.local ? yx : gx)(r, n, F1(this, "attr." + t, e)) : e == null ? (r.local ? fx : hx)(r) : (r.local ? px : dx)(r, n, e));
}
function bx(t, e) {
  return function(r) {
    this.setAttribute(t, e.call(this, r));
  };
}
function _x(t, e) {
  return function(r) {
    this.setAttributeNS(t.space, t.local, e.call(this, r));
  };
}
function xx(t, e) {
  var r, n;
  function i() {
    var s = e.apply(this, arguments);
    return s !== n && (r = (n = s) && _x(t, s)), r;
  }
  return i._value = e, i;
}
function vx(t, e) {
  var r, n;
  function i() {
    var s = e.apply(this, arguments);
    return s !== n && (r = (n = s) && bx(t, s)), r;
  }
  return i._value = e, i;
}
function kx(t, e) {
  var r = "attr." + t;
  if (arguments.length < 2)
    return (r = this.tween(r)) && r._value;
  if (e == null)
    return this.tween(r, null);
  if (typeof e != "function")
    throw new Error();
  var n = _c(t);
  return this.tween(r, (n.local ? xx : vx)(n, e));
}
function wx(t, e) {
  return function() {
    R1(this, t).delay = +e.apply(this, arguments);
  };
}
function Tx(t, e) {
  return e = +e, function() {
    R1(this, t).delay = e;
  };
}
function Ex(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? wx : Tx)(e, t)) : on(this.node(), e).delay;
}
function Cx(t, e) {
  return function() {
    Tn(this, t).duration = +e.apply(this, arguments);
  };
}
function Sx(t, e) {
  return e = +e, function() {
    Tn(this, t).duration = e;
  };
}
function Ax(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? Cx : Sx)(e, t)) : on(this.node(), e).duration;
}
function Lx(t, e) {
  if (typeof e != "function")
    throw new Error();
  return function() {
    Tn(this, t).ease = e;
  };
}
function Bx(t) {
  var e = this._id;
  return arguments.length ? this.each(Lx(e, t)) : on(this.node(), e).ease;
}
function Dx(t, e) {
  return function() {
    var r = e.apply(this, arguments);
    if (typeof r != "function")
      throw new Error();
    Tn(this, t).ease = r;
  };
}
function Ix(t) {
  if (typeof t != "function")
    throw new Error();
  return this.each(Dx(this._id, t));
}
function Mx(t) {
  typeof t != "function" && (t = ep(t));
  for (var e = this._groups, r = e.length, n = new Array(r), i = 0; i < r; ++i)
    for (var s = e[i], a = s.length, o = n[i] = [], l, u = 0; u < a; ++u)
      (l = s[u]) && t.call(l, l.__data__, u, s) && o.push(l);
  return new Kn(n, this._parents, this._name, this._id);
}
function Nx(t) {
  if (t._id !== this._id)
    throw new Error();
  for (var e = this._groups, r = t._groups, n = e.length, i = r.length, s = Math.min(n, i), a = new Array(n), o = 0; o < s; ++o)
    for (var l = e[o], u = r[o], h = l.length, f = a[o] = new Array(h), d, p = 0; p < h; ++p)
      (d = l[p] || u[p]) && (f[p] = d);
  for (; o < n; ++o)
    a[o] = e[o];
  return new Kn(a, this._parents, this._name, this._id);
}
function Rx(t) {
  return (t + "").trim().split(/^|\s+/).every(function(e) {
    var r = e.indexOf(".");
    return r >= 0 && (e = e.slice(0, r)), !e || e === "start";
  });
}
function Fx(t, e, r) {
  var n, i, s = Rx(e) ? R1 : Tn;
  return function() {
    var a = s(this, t), o = a.on;
    o !== n && (i = (n = o).copy()).on(e, r), a.on = i;
  };
}
function Ox(t, e) {
  var r = this._id;
  return arguments.length < 2 ? on(this.node(), r).on.on(t) : this.each(Fx(r, t, e));
}
function Px(t) {
  return function() {
    var e = this.parentNode;
    for (var r in this.__transition)
      if (+r !== t)
        return;
    e && e.removeChild(this);
  };
}
function Vx() {
  return this.on("end.remove", Px(this._id));
}
function Yx(t) {
  var e = this._name, r = this._id;
  typeof t != "function" && (t = L1(t));
  for (var n = this._groups, i = n.length, s = new Array(i), a = 0; a < i; ++a)
    for (var o = n[a], l = o.length, u = s[a] = new Array(l), h, f, d = 0; d < l; ++d)
      (h = o[d]) && (f = t.call(h, h.__data__, d, o)) && ("__data__" in h && (f.__data__ = h.__data__), u[d] = f, wc(u[d], e, r, d, u, on(h, r)));
  return new Kn(s, this._parents, e, r);
}
function zx(t) {
  var e = this._name, r = this._id;
  typeof t != "function" && (t = tp(t));
  for (var n = this._groups, i = n.length, s = [], a = [], o = 0; o < i; ++o)
    for (var l = n[o], u = l.length, h, f = 0; f < u; ++f)
      if (h = l[f]) {
        for (var d = t.call(h, h.__data__, f, l), p, m = on(h, r), _ = 0, v = d.length; _ < v; ++_)
          (p = d[_]) && wc(p, e, r, _, d, m);
        s.push(d), a.push(h);
      }
  return new Kn(s, a, e, r);
}
var Ux = co.prototype.constructor;
function Wx() {
  return new Ux(this._groups, this._parents);
}
function Hx(t, e) {
  var r, n, i;
  return function() {
    var s = Ts(this, t), a = (this.style.removeProperty(t), Ts(this, t));
    return s === a ? null : s === r && a === n ? i : i = e(r = s, n = a);
  };
}
function Ap(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function Gx(t, e, r) {
  var n, i = r + "", s;
  return function() {
    var a = Ts(this, t);
    return a === i ? null : a === n ? s : s = e(n = a, r);
  };
}
function qx(t, e, r) {
  var n, i, s;
  return function() {
    var a = Ts(this, t), o = r(this), l = o + "";
    return o == null && (l = o = (this.style.removeProperty(t), Ts(this, t))), a === l ? null : a === n && l === i ? s : (i = l, s = e(n = a, o));
  };
}
function $x(t, e) {
  var r, n, i, s = "style." + e, a = "end." + s, o;
  return function() {
    var l = Tn(this, t), u = l.on, h = l.value[s] == null ? o || (o = Ap(e)) : void 0;
    (u !== r || i !== h) && (n = (r = u).copy()).on(a, i = h), l.on = n;
  };
}
function jx(t, e, r) {
  var n = (t += "") == "transform" ? X_ : Sp;
  return e == null ? this.styleTween(t, Hx(t, n)).on("end.style." + t, Ap(t)) : typeof e == "function" ? this.styleTween(t, qx(t, n, F1(this, "style." + t, e))).each($x(this._id, t)) : this.styleTween(t, Gx(t, n, e), r).on("end.style." + t, null);
}
function Xx(t, e, r) {
  return function(n) {
    this.style.setProperty(t, e.call(this, n), r);
  };
}
function Kx(t, e, r) {
  var n, i;
  function s() {
    var a = e.apply(this, arguments);
    return a !== i && (n = (i = a) && Xx(t, a, r)), n;
  }
  return s._value = e, s;
}
function Zx(t, e, r) {
  var n = "style." + (t += "");
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (e == null)
    return this.tween(n, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(n, Kx(t, e, r ?? ""));
}
function Qx(t) {
  return function() {
    this.textContent = t;
  };
}
function Jx(t) {
  return function() {
    var e = t(this);
    this.textContent = e ?? "";
  };
}
function t6(t) {
  return this.tween("text", typeof t == "function" ? Jx(F1(this, "text", t)) : Qx(t == null ? "" : t + ""));
}
function e6(t) {
  return function(e) {
    this.textContent = t.call(this, e);
  };
}
function r6(t) {
  var e, r;
  function n() {
    var i = t.apply(this, arguments);
    return i !== r && (e = (r = i) && e6(i)), e;
  }
  return n._value = t, n;
}
function n6(t) {
  var e = "text";
  if (arguments.length < 1)
    return (e = this.tween(e)) && e._value;
  if (t == null)
    return this.tween(e, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(e, r6(t));
}
function i6() {
  for (var t = this._name, e = this._id, r = Lp(), n = this._groups, i = n.length, s = 0; s < i; ++s)
    for (var a = n[s], o = a.length, l, u = 0; u < o; ++u)
      if (l = a[u]) {
        var h = on(l, e);
        wc(l, t, r, u, a, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new Kn(n, this._parents, t, r);
}
function s6() {
  var t, e, r = this, n = r._id, i = r.size();
  return new Promise(function(s, a) {
    var o = { value: a }, l = { value: function() {
      --i === 0 && s();
    } };
    r.each(function() {
      var u = Tn(this, n), h = u.on;
      h !== t && (e = (t = h).copy(), e._.cancel.push(o), e._.interrupt.push(o), e._.end.push(l)), u.on = e;
    }), i === 0 && s();
  });
}
var a6 = 0;
function Kn(t, e, r, n) {
  this._groups = t, this._parents = e, this._name = r, this._id = n;
}
function Lp() {
  return ++a6;
}
var In = co.prototype;
Kn.prototype = {
  constructor: Kn,
  select: Yx,
  selectAll: zx,
  selectChild: In.selectChild,
  selectChildren: In.selectChildren,
  filter: Mx,
  merge: Nx,
  selection: Wx,
  transition: i6,
  call: In.call,
  nodes: In.nodes,
  node: In.node,
  size: In.size,
  empty: In.empty,
  each: In.each,
  on: Ox,
  attr: mx,
  attrTween: kx,
  style: jx,
  styleTween: Zx,
  text: t6,
  textTween: n6,
  remove: Vx,
  tween: ux,
  delay: Ex,
  duration: Ax,
  ease: Bx,
  easeVarying: Ix,
  end: s6,
  [Symbol.iterator]: In[Symbol.iterator]
};
function o6(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var l6 = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: o6
};
function c6(t, e) {
  for (var r; !(r = t.__transition) || !(r = r[e]); )
    if (!(t = t.parentNode))
      throw new Error(`transition ${e} not found`);
  return r;
}
function u6(t) {
  var e, r;
  t instanceof Kn ? (e = t._id, t = t._name) : (e = Lp(), (r = l6).time = N1(), t = t == null ? null : t + "");
  for (var n = this._groups, i = n.length, s = 0; s < i; ++s)
    for (var a = n[s], o = a.length, l, u = 0; u < o; ++u)
      (l = a[u]) && wc(l, t, e, u, a, r || c6(l, e));
  return new Kn(n, this._parents, t, e);
}
co.prototype.interrupt = ox;
co.prototype.transition = u6;
const yh = Math.PI, mh = 2 * yh, Si = 1e-6, h6 = mh - Si;
function bh() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function O1() {
  return new bh();
}
bh.prototype = O1.prototype = {
  constructor: bh,
  moveTo: function(t, e) {
    this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +e);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(t, e) {
    this._ += "L" + (this._x1 = +t) + "," + (this._y1 = +e);
  },
  quadraticCurveTo: function(t, e, r, n) {
    this._ += "Q" + +t + "," + +e + "," + (this._x1 = +r) + "," + (this._y1 = +n);
  },
  bezierCurveTo: function(t, e, r, n, i, s) {
    this._ += "C" + +t + "," + +e + "," + +r + "," + +n + "," + (this._x1 = +i) + "," + (this._y1 = +s);
  },
  arcTo: function(t, e, r, n, i) {
    t = +t, e = +e, r = +r, n = +n, i = +i;
    var s = this._x1, a = this._y1, o = r - t, l = n - e, u = s - t, h = a - e, f = u * u + h * h;
    if (i < 0)
      throw new Error("negative radius: " + i);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = t) + "," + (this._y1 = e);
    else if (f > Si)
      if (!(Math.abs(h * o - l * u) > Si) || !i)
        this._ += "L" + (this._x1 = t) + "," + (this._y1 = e);
      else {
        var d = r - s, p = n - a, m = o * o + l * l, _ = d * d + p * p, v = Math.sqrt(m), k = Math.sqrt(f), x = i * Math.tan((yh - Math.acos((m + f - _) / (2 * v * k))) / 2), D = x / k, F = x / v;
        Math.abs(D - 1) > Si && (this._ += "L" + (t + D * u) + "," + (e + D * h)), this._ += "A" + i + "," + i + ",0,0," + +(h * d > u * p) + "," + (this._x1 = t + F * o) + "," + (this._y1 = e + F * l);
      }
  },
  arc: function(t, e, r, n, i, s) {
    t = +t, e = +e, r = +r, s = !!s;
    var a = r * Math.cos(n), o = r * Math.sin(n), l = t + a, u = e + o, h = 1 ^ s, f = s ? n - i : i - n;
    if (r < 0)
      throw new Error("negative radius: " + r);
    this._x1 === null ? this._ += "M" + l + "," + u : (Math.abs(this._x1 - l) > Si || Math.abs(this._y1 - u) > Si) && (this._ += "L" + l + "," + u), r && (f < 0 && (f = f % mh + mh), f > h6 ? this._ += "A" + r + "," + r + ",0,1," + h + "," + (t - a) + "," + (e - o) + "A" + r + "," + r + ",0,1," + h + "," + (this._x1 = l) + "," + (this._y1 = u) : f > Si && (this._ += "A" + r + "," + r + ",0," + +(f >= yh) + "," + h + "," + (this._x1 = t + r * Math.cos(i)) + "," + (this._y1 = e + r * Math.sin(i))));
  },
  rect: function(t, e, r, n) {
    this._ += "M" + (this._x0 = this._x1 = +t) + "," + (this._y0 = this._y1 = +e) + "h" + +r + "v" + +n + "h" + -r + "Z";
  },
  toString: function() {
    return this._;
  }
};
function f6(t) {
  if (!t.ok)
    throw new Error(t.status + " " + t.statusText);
  return t.text();
}
function d6(t, e) {
  return fetch(t, e).then(f6);
}
function p6(t) {
  return (e, r) => d6(e, r).then((n) => new DOMParser().parseFromString(n, t));
}
var g6 = p6("image/svg+xml");
function y6(t) {
  return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
}
function wl(t, e) {
  if ((r = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0)
    return null;
  var r, n = t.slice(0, r);
  return [
    n.length > 1 ? n[0] + n.slice(2) : n,
    +t.slice(r + 1)
  ];
}
function Cs(t) {
  return t = wl(Math.abs(t)), t ? t[1] : NaN;
}
function m6(t, e) {
  return function(r, n) {
    for (var i = r.length, s = [], a = 0, o = t[0], l = 0; i > 0 && o > 0 && (l + o + 1 > n && (o = Math.max(1, n - l)), s.push(r.substring(i -= o, i + o)), !((l += o + 1) > n)); )
      o = t[a = (a + 1) % t.length];
    return s.reverse().join(e);
  };
}
function b6(t) {
  return function(e) {
    return e.replace(/[0-9]/g, function(r) {
      return t[+r];
    });
  };
}
var _6 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Tl(t) {
  if (!(e = _6.exec(t)))
    throw new Error("invalid format: " + t);
  var e;
  return new P1({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
Tl.prototype = P1.prototype;
function P1(t) {
  this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "";
}
P1.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function x6(t) {
  t:
    for (var e = t.length, r = 1, n = -1, i; r < e; ++r)
      switch (t[r]) {
        case ".":
          n = i = r;
          break;
        case "0":
          n === 0 && (n = r), i = r;
          break;
        default:
          if (!+t[r])
            break t;
          n > 0 && (n = 0);
          break;
      }
  return n > 0 ? t.slice(0, n) + t.slice(i + 1) : t;
}
var Bp;
function v6(t, e) {
  var r = wl(t, e);
  if (!r)
    return t + "";
  var n = r[0], i = r[1], s = i - (Bp = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = n.length;
  return s === a ? n : s > a ? n + new Array(s - a + 1).join("0") : s > 0 ? n.slice(0, s) + "." + n.slice(s) : "0." + new Array(1 - s).join("0") + wl(t, Math.max(0, e + s - 1))[0];
}
function Af(t, e) {
  var r = wl(t, e);
  if (!r)
    return t + "";
  var n = r[0], i = r[1];
  return i < 0 ? "0." + new Array(-i).join("0") + n : n.length > i + 1 ? n.slice(0, i + 1) + "." + n.slice(i + 1) : n + new Array(i - n.length + 2).join("0");
}
const Lf = {
  "%": (t, e) => (t * 100).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + "",
  d: y6,
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => Af(t * 100, e),
  r: Af,
  s: v6,
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16)
};
function Bf(t) {
  return t;
}
var Df = Array.prototype.map, If = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function k6(t) {
  var e = t.grouping === void 0 || t.thousands === void 0 ? Bf : m6(Df.call(t.grouping, Number), t.thousands + ""), r = t.currency === void 0 ? "" : t.currency[0] + "", n = t.currency === void 0 ? "" : t.currency[1] + "", i = t.decimal === void 0 ? "." : t.decimal + "", s = t.numerals === void 0 ? Bf : b6(Df.call(t.numerals, String)), a = t.percent === void 0 ? "%" : t.percent + "", o = t.minus === void 0 ? "" : t.minus + "", l = t.nan === void 0 ? "NaN" : t.nan + "";
  function u(f) {
    f = Tl(f);
    var d = f.fill, p = f.align, m = f.sign, _ = f.symbol, v = f.zero, k = f.width, x = f.comma, D = f.precision, F = f.trim, P = f.type;
    P === "n" ? (x = !0, P = "g") : Lf[P] || (D === void 0 && (D = 12), F = !0, P = "g"), (v || d === "0" && p === "=") && (v = !0, d = "0", p = "=");
    var V = _ === "$" ? r : _ === "#" && /[boxX]/.test(P) ? "0" + P.toLowerCase() : "", R = _ === "$" ? n : /[%p]/.test(P) ? a : "", O = Lf[P], C = /[defgprs%]/.test(P);
    D = D === void 0 ? 6 : /[gprs]/.test(P) ? Math.max(1, Math.min(21, D)) : Math.max(0, Math.min(20, D));
    function S(T) {
      var b = V, w = R, g, M, y;
      if (P === "c")
        w = O(T) + w, T = "";
      else {
        T = +T;
        var N = T < 0 || 1 / T < 0;
        if (T = isNaN(T) ? l : O(Math.abs(T), D), F && (T = x6(T)), N && +T == 0 && m !== "+" && (N = !1), b = (N ? m === "(" ? m : o : m === "-" || m === "(" ? "" : m) + b, w = (P === "s" ? If[8 + Bp / 3] : "") + w + (N && m === "(" ? ")" : ""), C) {
          for (g = -1, M = T.length; ++g < M; )
            if (y = T.charCodeAt(g), 48 > y || y > 57) {
              w = (y === 46 ? i + T.slice(g + 1) : T.slice(g)) + w, T = T.slice(0, g);
              break;
            }
        }
      }
      x && !v && (T = e(T, 1 / 0));
      var it = b.length + T.length + w.length, Y = it < k ? new Array(k - it + 1).join(d) : "";
      switch (x && v && (T = e(Y + T, Y.length ? k - w.length : 1 / 0), Y = ""), p) {
        case "<":
          T = b + T + w + Y;
          break;
        case "=":
          T = b + Y + T + w;
          break;
        case "^":
          T = Y.slice(0, it = Y.length >> 1) + b + T + w + Y.slice(it);
          break;
        default:
          T = Y + b + T + w;
          break;
      }
      return s(T);
    }
    return S.toString = function() {
      return f + "";
    }, S;
  }
  function h(f, d) {
    var p = u((f = Tl(f), f.type = "f", f)), m = Math.max(-8, Math.min(8, Math.floor(Cs(d) / 3))) * 3, _ = Math.pow(10, -m), v = If[8 + m / 3];
    return function(k) {
      return p(_ * k) + v;
    };
  }
  return {
    format: u,
    formatPrefix: h
  };
}
var Io, Dp, Ip;
w6({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function w6(t) {
  return Io = k6(t), Dp = Io.format, Ip = Io.formatPrefix, Io;
}
function T6(t) {
  return Math.max(0, -Cs(Math.abs(t)));
}
function E6(t, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Cs(e) / 3))) * 3 - Cs(Math.abs(t)));
}
function C6(t, e) {
  return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, Cs(e) - Cs(t)) + 1;
}
function V1(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t);
      break;
    default:
      this.range(e).domain(t);
      break;
  }
  return this;
}
const Mf = Symbol("implicit");
function Mp() {
  var t = new uf(), e = [], r = [], n = Mf;
  function i(s) {
    let a = t.get(s);
    if (a === void 0) {
      if (n !== Mf)
        return n;
      t.set(s, a = e.push(s) - 1);
    }
    return r[a % r.length];
  }
  return i.domain = function(s) {
    if (!arguments.length)
      return e.slice();
    e = [], t = new uf();
    for (const a of s)
      t.has(a) || t.set(a, e.push(a) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (r = Array.from(s), i) : r.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (n = s, i) : n;
  }, i.copy = function() {
    return Mp(e, r).unknown(n);
  }, V1.apply(i, arguments), i;
}
function S6(t) {
  return function() {
    return t;
  };
}
function A6(t) {
  return +t;
}
var Nf = [0, 1];
function us(t) {
  return t;
}
function _h(t, e) {
  return (e -= t = +t) ? function(r) {
    return (r - t) / e;
  } : S6(isNaN(e) ? NaN : 0.5);
}
function L6(t, e) {
  var r;
  return t > e && (r = t, t = e, e = r), function(n) {
    return Math.max(t, Math.min(e, n));
  };
}
function B6(t, e, r) {
  var n = t[0], i = t[1], s = e[0], a = e[1];
  return i < n ? (n = _h(i, n), s = r(a, s)) : (n = _h(n, i), s = r(s, a)), function(o) {
    return s(n(o));
  };
}
function D6(t, e, r) {
  var n = Math.min(t.length, e.length) - 1, i = new Array(n), s = new Array(n), a = -1;
  for (t[n] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++a < n; )
    i[a] = _h(t[a], t[a + 1]), s[a] = r(e[a], e[a + 1]);
  return function(o) {
    var l = E5(t, o, 1, n) - 1;
    return s[l](i[l](o));
  };
}
function Np(t, e) {
  return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
}
function I6() {
  var t = Nf, e = Nf, r = M1, n, i, s, a = us, o, l, u;
  function h() {
    var d = Math.min(t.length, e.length);
    return a !== us && (a = L6(t[0], t[d - 1])), o = d > 2 ? D6 : B6, l = u = null, f;
  }
  function f(d) {
    return d == null || isNaN(d = +d) ? s : (l || (l = o(t.map(n), e, r)))(n(a(d)));
  }
  return f.invert = function(d) {
    return a(i((u || (u = o(e, t.map(n), $r)))(d)));
  }, f.domain = function(d) {
    return arguments.length ? (t = Array.from(d, A6), h()) : t.slice();
  }, f.range = function(d) {
    return arguments.length ? (e = Array.from(d), h()) : e.slice();
  }, f.rangeRound = function(d) {
    return e = Array.from(d), r = q_, h();
  }, f.clamp = function(d) {
    return arguments.length ? (a = d ? !0 : us, h()) : a !== us;
  }, f.interpolate = function(d) {
    return arguments.length ? (r = d, h()) : r;
  }, f.unknown = function(d) {
    return arguments.length ? (s = d, f) : s;
  }, function(d, p) {
    return n = d, i = p, h();
  };
}
function Rp() {
  return I6()(us, us);
}
function M6(t, e, r, n) {
  var i = ah(t, e, r), s;
  switch (n = Tl(n ?? ",f"), n.type) {
    case "s": {
      var a = Math.max(Math.abs(t), Math.abs(e));
      return n.precision == null && !isNaN(s = E6(i, a)) && (n.precision = s), Ip(n, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      n.precision == null && !isNaN(s = C6(i, Math.max(Math.abs(t), Math.abs(e)))) && (n.precision = s - (n.type === "e"));
      break;
    }
    case "f":
    case "%": {
      n.precision == null && !isNaN(s = T6(i)) && (n.precision = s - (n.type === "%") * 2);
      break;
    }
  }
  return Dp(n);
}
function N6(t) {
  var e = t.domain;
  return t.ticks = function(r) {
    var n = e();
    return L5(n[0], n[n.length - 1], r ?? 10);
  }, t.tickFormat = function(r, n) {
    var i = e();
    return M6(i[0], i[i.length - 1], r ?? 10, n);
  }, t.nice = function(r) {
    r == null && (r = 10);
    var n = e(), i = 0, s = n.length - 1, a = n[i], o = n[s], l, u, h = 10;
    for (o < a && (u = a, a = o, o = u, u = i, i = s, s = u); h-- > 0; ) {
      if (u = X2(a, o, r), u === l)
        return n[i] = a, n[s] = o, e(n);
      if (u > 0)
        a = Math.floor(a / u) * u, o = Math.ceil(o / u) * u;
      else if (u < 0)
        a = Math.ceil(a * u) / u, o = Math.floor(o * u) / u;
      else
        break;
      l = u;
    }
    return t;
  }, t;
}
function Fp() {
  var t = Rp();
  return t.copy = function() {
    return Np(t, Fp());
  }, V1.apply(t, arguments), N6(t);
}
function R6(t, e) {
  t = t.slice();
  var r = 0, n = t.length - 1, i = t[r], s = t[n], a;
  return s < i && (a = r, r = n, n = a, a = i, i = s, s = a), t[r] = e.floor(i), t[n] = e.ceil(s), t;
}
var xu = new Date(), vu = new Date();
function Ze(t, e, r, n) {
  function i(s) {
    return t(s = arguments.length === 0 ? new Date() : new Date(+s)), s;
  }
  return i.floor = function(s) {
    return t(s = new Date(+s)), s;
  }, i.ceil = function(s) {
    return t(s = new Date(s - 1)), e(s, 1), t(s), s;
  }, i.round = function(s) {
    var a = i(s), o = i.ceil(s);
    return s - a < o - s ? a : o;
  }, i.offset = function(s, a) {
    return e(s = new Date(+s), a == null ? 1 : Math.floor(a)), s;
  }, i.range = function(s, a, o) {
    var l = [], u;
    if (s = i.ceil(s), o = o == null ? 1 : Math.floor(o), !(s < a) || !(o > 0))
      return l;
    do
      l.push(u = new Date(+s)), e(s, o), t(s);
    while (u < s && s < a);
    return l;
  }, i.filter = function(s) {
    return Ze(function(a) {
      if (a >= a)
        for (; t(a), !s(a); )
          a.setTime(a - 1);
    }, function(a, o) {
      if (a >= a)
        if (o < 0)
          for (; ++o <= 0; )
            for (; e(a, -1), !s(a); )
              ;
        else
          for (; --o >= 0; )
            for (; e(a, 1), !s(a); )
              ;
    });
  }, r && (i.count = function(s, a) {
    return xu.setTime(+s), vu.setTime(+a), t(xu), t(vu), Math.floor(r(xu, vu));
  }, i.every = function(s) {
    return s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? i.filter(n ? function(a) {
      return n(a) % s === 0;
    } : function(a) {
      return i.count(0, a) % s === 0;
    }) : i;
  }), i;
}
var El = Ze(function() {
}, function(t, e) {
  t.setTime(+t + e);
}, function(t, e) {
  return e - t;
});
El.every = function(t) {
  return t = Math.floor(t), !isFinite(t) || !(t > 0) ? null : t > 1 ? Ze(function(e) {
    e.setTime(Math.floor(e / t) * t);
  }, function(e, r) {
    e.setTime(+e + r * t);
  }, function(e, r) {
    return (r - e) / t;
  }) : El;
};
const F6 = El;
El.range;
const Un = 1e3, Yr = Un * 60, Wn = Yr * 60, Oi = Wn * 24, Y1 = Oi * 7, Rf = Oi * 30, ku = Oi * 365;
var Op = Ze(function(t) {
  t.setTime(t - t.getMilliseconds());
}, function(t, e) {
  t.setTime(+t + e * Un);
}, function(t, e) {
  return (e - t) / Un;
}, function(t) {
  return t.getUTCSeconds();
});
const ma = Op;
Op.range;
var Pp = Ze(function(t) {
  t.setTime(t - t.getMilliseconds() - t.getSeconds() * Un);
}, function(t, e) {
  t.setTime(+t + e * Yr);
}, function(t, e) {
  return (e - t) / Yr;
}, function(t) {
  return t.getMinutes();
});
const Cl = Pp;
Pp.range;
var Vp = Ze(function(t) {
  t.setTime(t - t.getMilliseconds() - t.getSeconds() * Un - t.getMinutes() * Yr);
}, function(t, e) {
  t.setTime(+t + e * Wn);
}, function(t, e) {
  return (e - t) / Wn;
}, function(t) {
  return t.getHours();
});
const Sl = Vp;
Vp.range;
var Yp = Ze(
  (t) => t.setHours(0, 0, 0, 0),
  (t, e) => t.setDate(t.getDate() + e),
  (t, e) => (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * Yr) / Oi,
  (t) => t.getDate() - 1
);
const Ss = Yp;
Yp.range;
function Ki(t) {
  return Ze(function(e) {
    e.setDate(e.getDate() - (e.getDay() + 7 - t) % 7), e.setHours(0, 0, 0, 0);
  }, function(e, r) {
    e.setDate(e.getDate() + r * 7);
  }, function(e, r) {
    return (r - e - (r.getTimezoneOffset() - e.getTimezoneOffset()) * Yr) / Y1;
  });
}
var As = Ki(0), Al = Ki(1), O6 = Ki(2), P6 = Ki(3), Ls = Ki(4), V6 = Ki(5), Y6 = Ki(6);
As.range;
Al.range;
O6.range;
P6.range;
Ls.range;
V6.range;
Y6.range;
var zp = Ze(function(t) {
  t.setDate(1), t.setHours(0, 0, 0, 0);
}, function(t, e) {
  t.setMonth(t.getMonth() + e);
}, function(t, e) {
  return e.getMonth() - t.getMonth() + (e.getFullYear() - t.getFullYear()) * 12;
}, function(t) {
  return t.getMonth();
});
const Ll = zp;
zp.range;
var z1 = Ze(function(t) {
  t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, function(t, e) {
  t.setFullYear(t.getFullYear() + e);
}, function(t, e) {
  return e.getFullYear() - t.getFullYear();
}, function(t) {
  return t.getFullYear();
});
z1.every = function(t) {
  return !isFinite(t = Math.floor(t)) || !(t > 0) ? null : Ze(function(e) {
    e.setFullYear(Math.floor(e.getFullYear() / t) * t), e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
  }, function(e, r) {
    e.setFullYear(e.getFullYear() + r * t);
  });
};
const Pi = z1;
z1.range;
var Up = Ze(function(t) {
  t.setUTCSeconds(0, 0);
}, function(t, e) {
  t.setTime(+t + e * Yr);
}, function(t, e) {
  return (e - t) / Yr;
}, function(t) {
  return t.getUTCMinutes();
});
const z6 = Up;
Up.range;
var Wp = Ze(function(t) {
  t.setUTCMinutes(0, 0, 0);
}, function(t, e) {
  t.setTime(+t + e * Wn);
}, function(t, e) {
  return (e - t) / Wn;
}, function(t) {
  return t.getUTCHours();
});
const U6 = Wp;
Wp.range;
var Hp = Ze(function(t) {
  t.setUTCHours(0, 0, 0, 0);
}, function(t, e) {
  t.setUTCDate(t.getUTCDate() + e);
}, function(t, e) {
  return (e - t) / Oi;
}, function(t) {
  return t.getUTCDate() - 1;
});
const U1 = Hp;
Hp.range;
function Zi(t) {
  return Ze(function(e) {
    e.setUTCDate(e.getUTCDate() - (e.getUTCDay() + 7 - t) % 7), e.setUTCHours(0, 0, 0, 0);
  }, function(e, r) {
    e.setUTCDate(e.getUTCDate() + r * 7);
  }, function(e, r) {
    return (r - e) / Y1;
  });
}
var W1 = Zi(0), Bl = Zi(1), W6 = Zi(2), H6 = Zi(3), Bs = Zi(4), G6 = Zi(5), q6 = Zi(6);
W1.range;
Bl.range;
W6.range;
H6.range;
Bs.range;
G6.range;
q6.range;
var Gp = Ze(function(t) {
  t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0);
}, function(t, e) {
  t.setUTCMonth(t.getUTCMonth() + e);
}, function(t, e) {
  return e.getUTCMonth() - t.getUTCMonth() + (e.getUTCFullYear() - t.getUTCFullYear()) * 12;
}, function(t) {
  return t.getUTCMonth();
});
const $6 = Gp;
Gp.range;
var H1 = Ze(function(t) {
  t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, function(t, e) {
  t.setUTCFullYear(t.getUTCFullYear() + e);
}, function(t, e) {
  return e.getUTCFullYear() - t.getUTCFullYear();
}, function(t) {
  return t.getUTCFullYear();
});
H1.every = function(t) {
  return !isFinite(t = Math.floor(t)) || !(t > 0) ? null : Ze(function(e) {
    e.setUTCFullYear(Math.floor(e.getUTCFullYear() / t) * t), e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
  }, function(e, r) {
    e.setUTCFullYear(e.getUTCFullYear() + r * t);
  });
};
const Ds = H1;
H1.range;
function qp(t, e, r, n, i, s) {
  const a = [
    [ma, 1, Un],
    [ma, 5, 5 * Un],
    [ma, 15, 15 * Un],
    [ma, 30, 30 * Un],
    [s, 1, Yr],
    [s, 5, 5 * Yr],
    [s, 15, 15 * Yr],
    [s, 30, 30 * Yr],
    [i, 1, Wn],
    [i, 3, 3 * Wn],
    [i, 6, 6 * Wn],
    [i, 12, 12 * Wn],
    [n, 1, Oi],
    [n, 2, 2 * Oi],
    [r, 1, Y1],
    [e, 1, Rf],
    [e, 3, 3 * Rf],
    [t, 1, ku]
  ];
  function o(u, h, f) {
    const d = h < u;
    d && ([u, h] = [h, u]);
    const p = f && typeof f.range == "function" ? f : l(u, h, f), m = p ? p.range(u, +h + 1) : [];
    return d ? m.reverse() : m;
  }
  function l(u, h, f) {
    const d = Math.abs(h - u) / f, p = A1(([, , v]) => v).right(a, d);
    if (p === a.length)
      return t.every(ah(u / ku, h / ku, f));
    if (p === 0)
      return F6.every(Math.max(ah(u, h, f), 1));
    const [m, _] = a[d / a[p - 1][2] < a[p][2] / d ? p - 1 : p];
    return m.every(_);
  }
  return [o, l];
}
qp(Ds, $6, W1, U1, U6, z6);
const [j6, X6] = qp(Pi, Ll, As, Ss, Sl, Cl);
function wu(t) {
  if (0 <= t.y && t.y < 100) {
    var e = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
    return e.setFullYear(t.y), e;
  }
  return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L);
}
function Tu(t) {
  if (0 <= t.y && t.y < 100) {
    var e = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L));
    return e.setUTCFullYear(t.y), e;
  }
  return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L));
}
function sa(t, e, r) {
  return { y: t, m: e, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function K6(t) {
  var e = t.dateTime, r = t.date, n = t.time, i = t.periods, s = t.days, a = t.shortDays, o = t.months, l = t.shortMonths, u = aa(i), h = oa(i), f = aa(s), d = oa(s), p = aa(a), m = oa(a), _ = aa(o), v = oa(o), k = aa(l), x = oa(l), D = {
    a: N,
    A: it,
    b: Y,
    B: Z,
    c: null,
    d: zf,
    e: zf,
    f: _v,
    g: Lv,
    G: Dv,
    H: yv,
    I: mv,
    j: bv,
    L: $p,
    m: xv,
    M: vv,
    p: J,
    q: X,
    Q: Hf,
    s: Gf,
    S: kv,
    u: wv,
    U: Tv,
    V: Ev,
    w: Cv,
    W: Sv,
    x: null,
    X: null,
    y: Av,
    Y: Bv,
    Z: Iv,
    "%": Wf
  }, F = {
    a: tt,
    A: st,
    b: lt,
    B: U,
    c: null,
    d: Uf,
    e: Uf,
    f: Fv,
    g: qv,
    G: jv,
    H: Mv,
    I: Nv,
    j: Rv,
    L: Xp,
    m: Ov,
    M: Pv,
    p: Tt,
    q: $,
    Q: Hf,
    s: Gf,
    S: Vv,
    u: Yv,
    U: zv,
    V: Uv,
    w: Wv,
    W: Hv,
    x: null,
    X: null,
    y: Gv,
    Y: $v,
    Z: Xv,
    "%": Wf
  }, P = {
    a: S,
    A: T,
    b,
    B: w,
    c: g,
    d: Vf,
    e: Vf,
    f: fv,
    g: Pf,
    G: Of,
    H: Yf,
    I: Yf,
    j: lv,
    L: hv,
    m: ov,
    M: cv,
    p: C,
    q: av,
    Q: pv,
    s: gv,
    S: uv,
    u: ev,
    U: rv,
    V: nv,
    w: tv,
    W: iv,
    x: M,
    X: y,
    y: Pf,
    Y: Of,
    Z: sv,
    "%": dv
  };
  D.x = V(r, D), D.X = V(n, D), D.c = V(e, D), F.x = V(r, F), F.X = V(n, F), F.c = V(e, F);
  function V(j, W) {
    return function(z) {
      var A = [], I = -1, G = 0, L = j.length, at, E, Dt;
      for (z instanceof Date || (z = new Date(+z)); ++I < L; )
        j.charCodeAt(I) === 37 && (A.push(j.slice(G, I)), (E = Ff[at = j.charAt(++I)]) != null ? at = j.charAt(++I) : E = at === "e" ? " " : "0", (Dt = W[at]) && (at = Dt(z, E)), A.push(at), G = I + 1);
      return A.push(j.slice(G, I)), A.join("");
    };
  }
  function R(j, W) {
    return function(z) {
      var A = sa(1900, void 0, 1), I = O(A, j, z += "", 0), G, L;
      if (I != z.length)
        return null;
      if ("Q" in A)
        return new Date(A.Q);
      if ("s" in A)
        return new Date(A.s * 1e3 + ("L" in A ? A.L : 0));
      if (W && !("Z" in A) && (A.Z = 0), "p" in A && (A.H = A.H % 12 + A.p * 12), A.m === void 0 && (A.m = "q" in A ? A.q : 0), "V" in A) {
        if (A.V < 1 || A.V > 53)
          return null;
        "w" in A || (A.w = 1), "Z" in A ? (G = Tu(sa(A.y, 0, 1)), L = G.getUTCDay(), G = L > 4 || L === 0 ? Bl.ceil(G) : Bl(G), G = U1.offset(G, (A.V - 1) * 7), A.y = G.getUTCFullYear(), A.m = G.getUTCMonth(), A.d = G.getUTCDate() + (A.w + 6) % 7) : (G = wu(sa(A.y, 0, 1)), L = G.getDay(), G = L > 4 || L === 0 ? Al.ceil(G) : Al(G), G = Ss.offset(G, (A.V - 1) * 7), A.y = G.getFullYear(), A.m = G.getMonth(), A.d = G.getDate() + (A.w + 6) % 7);
      } else
        ("W" in A || "U" in A) && ("w" in A || (A.w = "u" in A ? A.u % 7 : "W" in A ? 1 : 0), L = "Z" in A ? Tu(sa(A.y, 0, 1)).getUTCDay() : wu(sa(A.y, 0, 1)).getDay(), A.m = 0, A.d = "W" in A ? (A.w + 6) % 7 + A.W * 7 - (L + 5) % 7 : A.w + A.U * 7 - (L + 6) % 7);
      return "Z" in A ? (A.H += A.Z / 100 | 0, A.M += A.Z % 100, Tu(A)) : wu(A);
    };
  }
  function O(j, W, z, A) {
    for (var I = 0, G = W.length, L = z.length, at, E; I < G; ) {
      if (A >= L)
        return -1;
      if (at = W.charCodeAt(I++), at === 37) {
        if (at = W.charAt(I++), E = P[at in Ff ? W.charAt(I++) : at], !E || (A = E(j, z, A)) < 0)
          return -1;
      } else if (at != z.charCodeAt(A++))
        return -1;
    }
    return A;
  }
  function C(j, W, z) {
    var A = u.exec(W.slice(z));
    return A ? (j.p = h.get(A[0].toLowerCase()), z + A[0].length) : -1;
  }
  function S(j, W, z) {
    var A = p.exec(W.slice(z));
    return A ? (j.w = m.get(A[0].toLowerCase()), z + A[0].length) : -1;
  }
  function T(j, W, z) {
    var A = f.exec(W.slice(z));
    return A ? (j.w = d.get(A[0].toLowerCase()), z + A[0].length) : -1;
  }
  function b(j, W, z) {
    var A = k.exec(W.slice(z));
    return A ? (j.m = x.get(A[0].toLowerCase()), z + A[0].length) : -1;
  }
  function w(j, W, z) {
    var A = _.exec(W.slice(z));
    return A ? (j.m = v.get(A[0].toLowerCase()), z + A[0].length) : -1;
  }
  function g(j, W, z) {
    return O(j, e, W, z);
  }
  function M(j, W, z) {
    return O(j, r, W, z);
  }
  function y(j, W, z) {
    return O(j, n, W, z);
  }
  function N(j) {
    return a[j.getDay()];
  }
  function it(j) {
    return s[j.getDay()];
  }
  function Y(j) {
    return l[j.getMonth()];
  }
  function Z(j) {
    return o[j.getMonth()];
  }
  function J(j) {
    return i[+(j.getHours() >= 12)];
  }
  function X(j) {
    return 1 + ~~(j.getMonth() / 3);
  }
  function tt(j) {
    return a[j.getUTCDay()];
  }
  function st(j) {
    return s[j.getUTCDay()];
  }
  function lt(j) {
    return l[j.getUTCMonth()];
  }
  function U(j) {
    return o[j.getUTCMonth()];
  }
  function Tt(j) {
    return i[+(j.getUTCHours() >= 12)];
  }
  function $(j) {
    return 1 + ~~(j.getUTCMonth() / 3);
  }
  return {
    format: function(j) {
      var W = V(j += "", D);
      return W.toString = function() {
        return j;
      }, W;
    },
    parse: function(j) {
      var W = R(j += "", !1);
      return W.toString = function() {
        return j;
      }, W;
    },
    utcFormat: function(j) {
      var W = V(j += "", F);
      return W.toString = function() {
        return j;
      }, W;
    },
    utcParse: function(j) {
      var W = R(j += "", !0);
      return W.toString = function() {
        return j;
      }, W;
    }
  };
}
var Ff = { "-": "", _: " ", 0: "0" }, Qe = /^\s*\d+/, Z6 = /^%/, Q6 = /[\\^$*+?|[\]().{}]/g;
function he(t, e, r) {
  var n = t < 0 ? "-" : "", i = (n ? -t : t) + "", s = i.length;
  return n + (s < r ? new Array(r - s + 1).join(e) + i : i);
}
function J6(t) {
  return t.replace(Q6, "\\$&");
}
function aa(t) {
  return new RegExp("^(?:" + t.map(J6).join("|") + ")", "i");
}
function oa(t) {
  return new Map(t.map((e, r) => [e.toLowerCase(), r]));
}
function tv(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 1));
  return n ? (t.w = +n[0], r + n[0].length) : -1;
}
function ev(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 1));
  return n ? (t.u = +n[0], r + n[0].length) : -1;
}
function rv(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 2));
  return n ? (t.U = +n[0], r + n[0].length) : -1;
}
function nv(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 2));
  return n ? (t.V = +n[0], r + n[0].length) : -1;
}
function iv(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 2));
  return n ? (t.W = +n[0], r + n[0].length) : -1;
}
function Of(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 4));
  return n ? (t.y = +n[0], r + n[0].length) : -1;
}
function Pf(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 2));
  return n ? (t.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), r + n[0].length) : -1;
}
function sv(t, e, r) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(r, r + 6));
  return n ? (t.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), r + n[0].length) : -1;
}
function av(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 1));
  return n ? (t.q = n[0] * 3 - 3, r + n[0].length) : -1;
}
function ov(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 2));
  return n ? (t.m = n[0] - 1, r + n[0].length) : -1;
}
function Vf(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 2));
  return n ? (t.d = +n[0], r + n[0].length) : -1;
}
function lv(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 3));
  return n ? (t.m = 0, t.d = +n[0], r + n[0].length) : -1;
}
function Yf(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 2));
  return n ? (t.H = +n[0], r + n[0].length) : -1;
}
function cv(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 2));
  return n ? (t.M = +n[0], r + n[0].length) : -1;
}
function uv(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 2));
  return n ? (t.S = +n[0], r + n[0].length) : -1;
}
function hv(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 3));
  return n ? (t.L = +n[0], r + n[0].length) : -1;
}
function fv(t, e, r) {
  var n = Qe.exec(e.slice(r, r + 6));
  return n ? (t.L = Math.floor(n[0] / 1e3), r + n[0].length) : -1;
}
function dv(t, e, r) {
  var n = Z6.exec(e.slice(r, r + 1));
  return n ? r + n[0].length : -1;
}
function pv(t, e, r) {
  var n = Qe.exec(e.slice(r));
  return n ? (t.Q = +n[0], r + n[0].length) : -1;
}
function gv(t, e, r) {
  var n = Qe.exec(e.slice(r));
  return n ? (t.s = +n[0], r + n[0].length) : -1;
}
function zf(t, e) {
  return he(t.getDate(), e, 2);
}
function yv(t, e) {
  return he(t.getHours(), e, 2);
}
function mv(t, e) {
  return he(t.getHours() % 12 || 12, e, 2);
}
function bv(t, e) {
  return he(1 + Ss.count(Pi(t), t), e, 3);
}
function $p(t, e) {
  return he(t.getMilliseconds(), e, 3);
}
function _v(t, e) {
  return $p(t, e) + "000";
}
function xv(t, e) {
  return he(t.getMonth() + 1, e, 2);
}
function vv(t, e) {
  return he(t.getMinutes(), e, 2);
}
function kv(t, e) {
  return he(t.getSeconds(), e, 2);
}
function wv(t) {
  var e = t.getDay();
  return e === 0 ? 7 : e;
}
function Tv(t, e) {
  return he(As.count(Pi(t) - 1, t), e, 2);
}
function jp(t) {
  var e = t.getDay();
  return e >= 4 || e === 0 ? Ls(t) : Ls.ceil(t);
}
function Ev(t, e) {
  return t = jp(t), he(Ls.count(Pi(t), t) + (Pi(t).getDay() === 4), e, 2);
}
function Cv(t) {
  return t.getDay();
}
function Sv(t, e) {
  return he(Al.count(Pi(t) - 1, t), e, 2);
}
function Av(t, e) {
  return he(t.getFullYear() % 100, e, 2);
}
function Lv(t, e) {
  return t = jp(t), he(t.getFullYear() % 100, e, 2);
}
function Bv(t, e) {
  return he(t.getFullYear() % 1e4, e, 4);
}
function Dv(t, e) {
  var r = t.getDay();
  return t = r >= 4 || r === 0 ? Ls(t) : Ls.ceil(t), he(t.getFullYear() % 1e4, e, 4);
}
function Iv(t) {
  var e = t.getTimezoneOffset();
  return (e > 0 ? "-" : (e *= -1, "+")) + he(e / 60 | 0, "0", 2) + he(e % 60, "0", 2);
}
function Uf(t, e) {
  return he(t.getUTCDate(), e, 2);
}
function Mv(t, e) {
  return he(t.getUTCHours(), e, 2);
}
function Nv(t, e) {
  return he(t.getUTCHours() % 12 || 12, e, 2);
}
function Rv(t, e) {
  return he(1 + U1.count(Ds(t), t), e, 3);
}
function Xp(t, e) {
  return he(t.getUTCMilliseconds(), e, 3);
}
function Fv(t, e) {
  return Xp(t, e) + "000";
}
function Ov(t, e) {
  return he(t.getUTCMonth() + 1, e, 2);
}
function Pv(t, e) {
  return he(t.getUTCMinutes(), e, 2);
}
function Vv(t, e) {
  return he(t.getUTCSeconds(), e, 2);
}
function Yv(t) {
  var e = t.getUTCDay();
  return e === 0 ? 7 : e;
}
function zv(t, e) {
  return he(W1.count(Ds(t) - 1, t), e, 2);
}
function Kp(t) {
  var e = t.getUTCDay();
  return e >= 4 || e === 0 ? Bs(t) : Bs.ceil(t);
}
function Uv(t, e) {
  return t = Kp(t), he(Bs.count(Ds(t), t) + (Ds(t).getUTCDay() === 4), e, 2);
}
function Wv(t) {
  return t.getUTCDay();
}
function Hv(t, e) {
  return he(Bl.count(Ds(t) - 1, t), e, 2);
}
function Gv(t, e) {
  return he(t.getUTCFullYear() % 100, e, 2);
}
function qv(t, e) {
  return t = Kp(t), he(t.getUTCFullYear() % 100, e, 2);
}
function $v(t, e) {
  return he(t.getUTCFullYear() % 1e4, e, 4);
}
function jv(t, e) {
  var r = t.getUTCDay();
  return t = r >= 4 || r === 0 ? Bs(t) : Bs.ceil(t), he(t.getUTCFullYear() % 1e4, e, 4);
}
function Xv() {
  return "+0000";
}
function Wf() {
  return "%";
}
function Hf(t) {
  return +t;
}
function Gf(t) {
  return Math.floor(+t / 1e3);
}
var as, Dl;
Kv({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function Kv(t) {
  return as = K6(t), Dl = as.format, as.parse, as.utcFormat, as.utcParse, as;
}
function Zv(t) {
  return new Date(t);
}
function Qv(t) {
  return t instanceof Date ? +t : +new Date(+t);
}
function Zp(t, e, r, n, i, s, a, o, l, u) {
  var h = Rp(), f = h.invert, d = h.domain, p = u(".%L"), m = u(":%S"), _ = u("%I:%M"), v = u("%I %p"), k = u("%a %d"), x = u("%b %d"), D = u("%B"), F = u("%Y");
  function P(V) {
    return (l(V) < V ? p : o(V) < V ? m : a(V) < V ? _ : s(V) < V ? v : n(V) < V ? i(V) < V ? k : x : r(V) < V ? D : F)(V);
  }
  return h.invert = function(V) {
    return new Date(f(V));
  }, h.domain = function(V) {
    return arguments.length ? d(Array.from(V, Qv)) : d().map(Zv);
  }, h.ticks = function(V) {
    var R = d();
    return t(R[0], R[R.length - 1], V ?? 10);
  }, h.tickFormat = function(V, R) {
    return R == null ? P : u(R);
  }, h.nice = function(V) {
    var R = d();
    return (!V || typeof V.range != "function") && (V = e(R[0], R[R.length - 1], V ?? 10)), V ? d(R6(R, V)) : h;
  }, h.copy = function() {
    return Np(h, Zp(t, e, r, n, i, s, a, o, l, u));
  }, h;
}
function Jv() {
  return V1.apply(Zp(j6, X6, Pi, Ll, As, Ss, Sl, Cl, ma, Dl).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function Le(t) {
  return function() {
    return t;
  };
}
const qf = Math.abs, nr = Math.atan2, wi = Math.cos, tk = Math.max, Eu = Math.min, fn = Math.sin, hs = Math.sqrt, ir = 1e-12, Pa = Math.PI, Il = Pa / 2, Ko = 2 * Pa;
function ek(t) {
  return t > 1 ? 0 : t < -1 ? Pa : Math.acos(t);
}
function $f(t) {
  return t >= 1 ? Il : t <= -1 ? -Il : Math.asin(t);
}
function rk(t) {
  return t.innerRadius;
}
function nk(t) {
  return t.outerRadius;
}
function ik(t) {
  return t.startAngle;
}
function sk(t) {
  return t.endAngle;
}
function ak(t) {
  return t && t.padAngle;
}
function ok(t, e, r, n, i, s, a, o) {
  var l = r - t, u = n - e, h = a - i, f = o - s, d = f * l - h * u;
  if (!(d * d < ir))
    return d = (h * (e - s) - f * (t - i)) / d, [t + d * l, e + d * u];
}
function Mo(t, e, r, n, i, s, a) {
  var o = t - r, l = e - n, u = (a ? s : -s) / hs(o * o + l * l), h = u * l, f = -u * o, d = t + h, p = e + f, m = r + h, _ = n + f, v = (d + m) / 2, k = (p + _) / 2, x = m - d, D = _ - p, F = x * x + D * D, P = i - s, V = d * _ - m * p, R = (D < 0 ? -1 : 1) * hs(tk(0, P * P * F - V * V)), O = (V * D - x * R) / F, C = (-V * x - D * R) / F, S = (V * D + x * R) / F, T = (-V * x + D * R) / F, b = O - v, w = C - k, g = S - v, M = T - k;
  return b * b + w * w > g * g + M * M && (O = S, C = T), {
    cx: O,
    cy: C,
    x01: -h,
    y01: -f,
    x11: O * (i / P - 1),
    y11: C * (i / P - 1)
  };
}
function xh() {
  var t = rk, e = nk, r = Le(0), n = null, i = ik, s = sk, a = ak, o = null;
  function l() {
    var u, h, f = +t.apply(this, arguments), d = +e.apply(this, arguments), p = i.apply(this, arguments) - Il, m = s.apply(this, arguments) - Il, _ = qf(m - p), v = m > p;
    if (o || (o = u = O1()), d < f && (h = d, d = f, f = h), !(d > ir))
      o.moveTo(0, 0);
    else if (_ > Ko - ir)
      o.moveTo(d * wi(p), d * fn(p)), o.arc(0, 0, d, p, m, !v), f > ir && (o.moveTo(f * wi(m), f * fn(m)), o.arc(0, 0, f, m, p, v));
    else {
      var k = p, x = m, D = p, F = m, P = _, V = _, R = a.apply(this, arguments) / 2, O = R > ir && (n ? +n.apply(this, arguments) : hs(f * f + d * d)), C = Eu(qf(d - f) / 2, +r.apply(this, arguments)), S = C, T = C, b, w;
      if (O > ir) {
        var g = $f(O / f * fn(R)), M = $f(O / d * fn(R));
        (P -= g * 2) > ir ? (g *= v ? 1 : -1, D += g, F -= g) : (P = 0, D = F = (p + m) / 2), (V -= M * 2) > ir ? (M *= v ? 1 : -1, k += M, x -= M) : (V = 0, k = x = (p + m) / 2);
      }
      var y = d * wi(k), N = d * fn(k), it = f * wi(F), Y = f * fn(F);
      if (C > ir) {
        var Z = d * wi(x), J = d * fn(x), X = f * wi(D), tt = f * fn(D), st;
        if (_ < Pa && (st = ok(y, N, X, tt, Z, J, it, Y))) {
          var lt = y - st[0], U = N - st[1], Tt = Z - st[0], $ = J - st[1], j = 1 / fn(ek((lt * Tt + U * $) / (hs(lt * lt + U * U) * hs(Tt * Tt + $ * $))) / 2), W = hs(st[0] * st[0] + st[1] * st[1]);
          S = Eu(C, (f - W) / (j - 1)), T = Eu(C, (d - W) / (j + 1));
        }
      }
      V > ir ? T > ir ? (b = Mo(X, tt, y, N, d, T, v), w = Mo(Z, J, it, Y, d, T, v), o.moveTo(b.cx + b.x01, b.cy + b.y01), T < C ? o.arc(b.cx, b.cy, T, nr(b.y01, b.x01), nr(w.y01, w.x01), !v) : (o.arc(b.cx, b.cy, T, nr(b.y01, b.x01), nr(b.y11, b.x11), !v), o.arc(0, 0, d, nr(b.cy + b.y11, b.cx + b.x11), nr(w.cy + w.y11, w.cx + w.x11), !v), o.arc(w.cx, w.cy, T, nr(w.y11, w.x11), nr(w.y01, w.x01), !v))) : (o.moveTo(y, N), o.arc(0, 0, d, k, x, !v)) : o.moveTo(y, N), !(f > ir) || !(P > ir) ? o.lineTo(it, Y) : S > ir ? (b = Mo(it, Y, Z, J, f, -S, v), w = Mo(y, N, X, tt, f, -S, v), o.lineTo(b.cx + b.x01, b.cy + b.y01), S < C ? o.arc(b.cx, b.cy, S, nr(b.y01, b.x01), nr(w.y01, w.x01), !v) : (o.arc(b.cx, b.cy, S, nr(b.y01, b.x01), nr(b.y11, b.x11), !v), o.arc(0, 0, f, nr(b.cy + b.y11, b.cx + b.x11), nr(w.cy + w.y11, w.cx + w.x11), v), o.arc(w.cx, w.cy, S, nr(w.y11, w.x11), nr(w.y01, w.x01), !v))) : o.arc(0, 0, f, F, D, v);
    }
    if (o.closePath(), u)
      return o = null, u + "" || null;
  }
  return l.centroid = function() {
    var u = (+t.apply(this, arguments) + +e.apply(this, arguments)) / 2, h = (+i.apply(this, arguments) + +s.apply(this, arguments)) / 2 - Pa / 2;
    return [wi(h) * u, fn(h) * u];
  }, l.innerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Le(+u), l) : t;
  }, l.outerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Le(+u), l) : e;
  }, l.cornerRadius = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Le(+u), l) : r;
  }, l.padRadius = function(u) {
    return arguments.length ? (n = u == null ? null : typeof u == "function" ? u : Le(+u), l) : n;
  }, l.startAngle = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : Le(+u), l) : i;
  }, l.endAngle = function(u) {
    return arguments.length ? (s = typeof u == "function" ? u : Le(+u), l) : s;
  }, l.padAngle = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : Le(+u), l) : a;
  }, l.context = function(u) {
    return arguments.length ? (o = u ?? null, l) : o;
  }, l;
}
function Qp(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function Jp(t) {
  this._context = t;
}
Jp.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(t, e);
        break;
    }
  }
};
function Ar(t) {
  return new Jp(t);
}
function lk(t) {
  return t[0];
}
function ck(t) {
  return t[1];
}
function js(t, e) {
  var r = Le(!0), n = null, i = Ar, s = null;
  t = typeof t == "function" ? t : t === void 0 ? lk : Le(t), e = typeof e == "function" ? e : e === void 0 ? ck : Le(e);
  function a(o) {
    var l, u = (o = Qp(o)).length, h, f = !1, d;
    for (n == null && (s = i(d = O1())), l = 0; l <= u; ++l)
      !(l < u && r(h = o[l], l, o)) === f && ((f = !f) ? s.lineStart() : s.lineEnd()), f && s.point(+t(h, l, o), +e(h, l, o));
    if (d)
      return s = null, d + "" || null;
  }
  return a.x = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : Le(+o), a) : t;
  }, a.y = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Le(+o), a) : e;
  }, a.defined = function(o) {
    return arguments.length ? (r = typeof o == "function" ? o : Le(!!o), a) : r;
  }, a.curve = function(o) {
    return arguments.length ? (i = o, n != null && (s = i(n)), a) : i;
  }, a.context = function(o) {
    return arguments.length ? (o == null ? n = s = null : s = i(n = o), a) : n;
  }, a;
}
function uk(t, e) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function hk(t) {
  return t;
}
function fk() {
  var t = hk, e = uk, r = null, n = Le(0), i = Le(Ko), s = Le(0);
  function a(o) {
    var l, u = (o = Qp(o)).length, h, f, d = 0, p = new Array(u), m = new Array(u), _ = +n.apply(this, arguments), v = Math.min(Ko, Math.max(-Ko, i.apply(this, arguments) - _)), k, x = Math.min(Math.abs(v) / u, s.apply(this, arguments)), D = x * (v < 0 ? -1 : 1), F;
    for (l = 0; l < u; ++l)
      (F = m[p[l] = l] = +t(o[l], l, o)) > 0 && (d += F);
    for (e != null ? p.sort(function(P, V) {
      return e(m[P], m[V]);
    }) : r != null && p.sort(function(P, V) {
      return r(o[P], o[V]);
    }), l = 0, f = d ? (v - u * D) / d : 0; l < u; ++l, _ = k)
      h = p[l], F = m[h], k = _ + (F > 0 ? F * f : 0) + D, m[h] = {
        data: o[h],
        index: l,
        value: F,
        startAngle: _,
        endAngle: k,
        padAngle: x
      };
    return m;
  }
  return a.value = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : Le(+o), a) : t;
  }, a.sortValues = function(o) {
    return arguments.length ? (e = o, r = null, a) : e;
  }, a.sort = function(o) {
    return arguments.length ? (r = o, e = null, a) : r;
  }, a.startAngle = function(o) {
    return arguments.length ? (n = typeof o == "function" ? o : Le(+o), a) : n;
  }, a.endAngle = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : Le(+o), a) : i;
  }, a.padAngle = function(o) {
    return arguments.length ? (s = typeof o == "function" ? o : Le(+o), a) : s;
  }, a;
}
class tg {
  constructor(e, r) {
    this._context = e, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, r) {
    switch (e = +e, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, r, e, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, e, this._y0, e, r);
        break;
      }
    }
    this._x0 = e, this._y0 = r;
  }
}
function dk(t) {
  return new tg(t, !0);
}
function pk(t) {
  return new tg(t, !1);
}
function pi() {
}
function Ml(t, e, r) {
  t._context.bezierCurveTo(
    (2 * t._x0 + t._x1) / 3,
    (2 * t._y0 + t._y1) / 3,
    (t._x0 + 2 * t._x1) / 3,
    (t._y0 + 2 * t._y1) / 3,
    (t._x0 + 4 * t._x1 + e) / 6,
    (t._y0 + 4 * t._y1 + r) / 6
  );
}
function Tc(t) {
  this._context = t;
}
Tc.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        Ml(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        Ml(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function Is(t) {
  return new Tc(t);
}
function eg(t) {
  this._context = t;
}
eg.prototype = {
  areaStart: pi,
  areaEnd: pi,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._x2 = t, this._y2 = e;
        break;
      case 1:
        this._point = 2, this._x3 = t, this._y3 = e;
        break;
      case 2:
        this._point = 3, this._x4 = t, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + e) / 6);
        break;
      default:
        Ml(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function gk(t) {
  return new eg(t);
}
function rg(t) {
  this._context = t;
}
rg.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var r = (this._x0 + 4 * this._x1 + t) / 6, n = (this._y0 + 4 * this._y1 + e) / 6;
        this._line ? this._context.lineTo(r, n) : this._context.moveTo(r, n);
        break;
      case 3:
        this._point = 4;
      default:
        Ml(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function yk(t) {
  return new rg(t);
}
function ng(t, e) {
  this._basis = new Tc(t), this._beta = e;
}
ng.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var t = this._x, e = this._y, r = t.length - 1;
    if (r > 0)
      for (var n = t[0], i = e[0], s = t[r] - n, a = e[r] - i, o = -1, l; ++o <= r; )
        l = o / r, this._basis.point(
          this._beta * t[o] + (1 - this._beta) * (n + l * s),
          this._beta * e[o] + (1 - this._beta) * (i + l * a)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(t, e) {
    this._x.push(+t), this._y.push(+e);
  }
};
const mk = function t(e) {
  function r(n) {
    return e === 1 ? new Tc(n) : new ng(n, e);
  }
  return r.beta = function(n) {
    return t(+n);
  }, r;
}(0.85);
function Nl(t, e, r) {
  t._context.bezierCurveTo(
    t._x1 + t._k * (t._x2 - t._x0),
    t._y1 + t._k * (t._y2 - t._y0),
    t._x2 + t._k * (t._x1 - e),
    t._y2 + t._k * (t._y1 - r),
    t._x2,
    t._y2
  );
}
function G1(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
G1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        Nl(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2, this._x1 = t, this._y1 = e;
        break;
      case 2:
        this._point = 3;
      default:
        Nl(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const bk = function t(e) {
  function r(n) {
    return new G1(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
}(0);
function q1(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
q1.prototype = {
  areaStart: pi,
  areaEnd: pi,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._x3 = t, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t, this._y5 = e;
        break;
      default:
        Nl(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const _k = function t(e) {
  function r(n) {
    return new q1(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
}(0);
function $1(t, e) {
  this._context = t, this._k = (1 - e) / 6;
}
$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        Nl(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const xk = function t(e) {
  function r(n) {
    return new $1(n, e);
  }
  return r.tension = function(n) {
    return t(+n);
  }, r;
}(0);
function j1(t, e, r) {
  var n = t._x1, i = t._y1, s = t._x2, a = t._y2;
  if (t._l01_a > ir) {
    var o = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a, l = 3 * t._l01_a * (t._l01_a + t._l12_a);
    n = (n * o - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / l, i = (i * o - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / l;
  }
  if (t._l23_a > ir) {
    var u = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a, h = 3 * t._l23_a * (t._l23_a + t._l12_a);
    s = (s * u + t._x1 * t._l23_2a - e * t._l12_2a) / h, a = (a * u + t._y1 * t._l23_2a - r * t._l12_2a) / h;
  }
  t._context.bezierCurveTo(n, i, s, a, t._x2, t._y2);
}
function ig(t, e) {
  this._context = t, this._alpha = e;
}
ig.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        j1(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const vk = function t(e) {
  function r(n) {
    return e ? new ig(n, e) : new G1(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
}(0.5);
function sg(t, e) {
  this._context = t, this._alpha = e;
}
sg.prototype = {
  areaStart: pi,
  areaEnd: pi,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = t, this._y3 = e;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = t, this._y4 = e);
        break;
      case 2:
        this._point = 3, this._x5 = t, this._y5 = e;
        break;
      default:
        j1(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const kk = function t(e) {
  function r(n) {
    return e ? new sg(n, e) : new q1(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
}(0.5);
function ag(t, e) {
  this._context = t, this._alpha = e;
}
ag.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    if (t = +t, e = +e, this._point) {
      var r = this._x2 - t, n = this._y2 - e;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        j1(this, t, e);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = t, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const wk = function t(e) {
  function r(n) {
    return e ? new ag(n, e) : new $1(n, 0);
  }
  return r.alpha = function(n) {
    return t(+n);
  }, r;
}(0.5);
function og(t) {
  this._context = t;
}
og.prototype = {
  areaStart: pi,
  areaEnd: pi,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(t, e) {
    t = +t, e = +e, this._point ? this._context.lineTo(t, e) : (this._point = 1, this._context.moveTo(t, e));
  }
};
function Tk(t) {
  return new og(t);
}
function jf(t) {
  return t < 0 ? -1 : 1;
}
function Xf(t, e, r) {
  var n = t._x1 - t._x0, i = e - t._x1, s = (t._y1 - t._y0) / (n || i < 0 && -0), a = (r - t._y1) / (i || n < 0 && -0), o = (s * i + a * n) / (n + i);
  return (jf(s) + jf(a)) * Math.min(Math.abs(s), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function Kf(t, e) {
  var r = t._x1 - t._x0;
  return r ? (3 * (t._y1 - t._y0) / r - e) / 2 : e;
}
function Cu(t, e, r) {
  var n = t._x0, i = t._y0, s = t._x1, a = t._y1, o = (s - n) / 3;
  t._context.bezierCurveTo(n + o, i + o * e, s - o, a - o * r, s, a);
}
function Rl(t) {
  this._context = t;
}
Rl.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Cu(this, this._t0, Kf(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    var r = NaN;
    if (t = +t, e = +e, !(t === this._x1 && e === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Cu(this, Kf(this, r = Xf(this, t, e)), r);
          break;
        default:
          Cu(this, this._t0, r = Xf(this, t, e));
          break;
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e, this._t0 = r;
    }
  }
};
function lg(t) {
  this._context = new cg(t);
}
(lg.prototype = Object.create(Rl.prototype)).point = function(t, e) {
  Rl.prototype.point.call(this, e, t);
};
function cg(t) {
  this._context = t;
}
cg.prototype = {
  moveTo: function(t, e) {
    this._context.moveTo(e, t);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(t, e) {
    this._context.lineTo(e, t);
  },
  bezierCurveTo: function(t, e, r, n, i, s) {
    this._context.bezierCurveTo(e, t, n, r, s, i);
  }
};
function Ek(t) {
  return new Rl(t);
}
function Ck(t) {
  return new lg(t);
}
function ug(t) {
  this._context = t;
}
ug.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var t = this._x, e = this._y, r = t.length;
    if (r)
      if (this._line ? this._context.lineTo(t[0], e[0]) : this._context.moveTo(t[0], e[0]), r === 2)
        this._context.lineTo(t[1], e[1]);
      else
        for (var n = Zf(t), i = Zf(e), s = 0, a = 1; a < r; ++s, ++a)
          this._context.bezierCurveTo(n[0][s], i[0][s], n[1][s], i[1][s], t[a], e[a]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(t, e) {
    this._x.push(+t), this._y.push(+e);
  }
};
function Zf(t) {
  var e, r = t.length - 1, n, i = new Array(r), s = new Array(r), a = new Array(r);
  for (i[0] = 0, s[0] = 2, a[0] = t[0] + 2 * t[1], e = 1; e < r - 1; ++e)
    i[e] = 1, s[e] = 4, a[e] = 4 * t[e] + 2 * t[e + 1];
  for (i[r - 1] = 2, s[r - 1] = 7, a[r - 1] = 8 * t[r - 1] + t[r], e = 1; e < r; ++e)
    n = i[e] / s[e - 1], s[e] -= n, a[e] -= n * a[e - 1];
  for (i[r - 1] = a[r - 1] / s[r - 1], e = r - 2; e >= 0; --e)
    i[e] = (a[e] - i[e + 1]) / s[e];
  for (s[r - 1] = (t[r] + i[r - 1]) / 2, e = 0; e < r - 1; ++e)
    s[e] = 2 * t[e + 1] - i[e + 1];
  return [i, s];
}
function Sk(t) {
  return new ug(t);
}
function Ec(t, e) {
  this._context = t, this._t = e;
}
Ec.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(t, e);
        else {
          var r = this._x * (1 - this._t) + t * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, e);
        }
        break;
      }
    }
    this._x = t, this._y = e;
  }
};
function Ak(t) {
  return new Ec(t, 0.5);
}
function Lk(t) {
  return new Ec(t, 0);
}
function Bk(t) {
  return new Ec(t, 1);
}
function ba(t, e, r) {
  this.k = t, this.x = e, this.y = r;
}
ba.prototype = {
  constructor: ba,
  scale: function(t) {
    return t === 1 ? this : new ba(this.k * t, this.x, this.y);
  },
  translate: function(t, e) {
    return t === 0 & e === 0 ? this : new ba(this.k, this.x + this.k * t, this.y + this.k * e);
  },
  apply: function(t) {
    return [t[0] * this.k + this.x, t[1] * this.k + this.y];
  },
  applyX: function(t) {
    return t * this.k + this.x;
  },
  applyY: function(t) {
    return t * this.k + this.y;
  },
  invert: function(t) {
    return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k];
  },
  invertX: function(t) {
    return (t - this.x) / this.k;
  },
  invertY: function(t) {
    return (t - this.y) / this.k;
  },
  rescaleX: function(t) {
    return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t));
  },
  rescaleY: function(t) {
    return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
ba.prototype;
/*! @license DOMPurify 2.4.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.3/LICENSE */
function ai(t) {
  return ai = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ai(t);
}
function vh(t, e) {
  return vh = Object.setPrototypeOf || function(n, i) {
    return n.__proto__ = i, n;
  }, vh(t, e);
}
function Dk() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Zo(t, e, r) {
  return Dk() ? Zo = Reflect.construct : Zo = function(i, s, a) {
    var o = [null];
    o.push.apply(o, s);
    var l = Function.bind.apply(i, o), u = new l();
    return a && vh(u, a.prototype), u;
  }, Zo.apply(null, arguments);
}
function qr(t) {
  return Ik(t) || Mk(t) || Nk(t) || Rk();
}
function Ik(t) {
  if (Array.isArray(t))
    return kh(t);
}
function Mk(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function Nk(t, e) {
  if (t) {
    if (typeof t == "string")
      return kh(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set")
      return Array.from(t);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return kh(t, e);
  }
}
function kh(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, n = new Array(e); r < e; r++)
    n[r] = t[r];
  return n;
}
function Rk() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var Fk = Object.hasOwnProperty, Qf = Object.setPrototypeOf, Ok = Object.isFrozen, Pk = Object.getPrototypeOf, Vk = Object.getOwnPropertyDescriptor, yr = Object.freeze, rn = Object.seal, Yk = Object.create, hg = typeof Reflect < "u" && Reflect, Fl = hg.apply, wh = hg.construct;
Fl || (Fl = function(e, r, n) {
  return e.apply(r, n);
});
yr || (yr = function(e) {
  return e;
});
rn || (rn = function(e) {
  return e;
});
wh || (wh = function(e, r) {
  return Zo(e, qr(r));
});
var zk = zr(Array.prototype.forEach), Jf = zr(Array.prototype.pop), la = zr(Array.prototype.push), Qo = zr(String.prototype.toLowerCase), Su = zr(String.prototype.toString), Uk = zr(String.prototype.match), Gr = zr(String.prototype.replace), Wk = zr(String.prototype.indexOf), Hk = zr(String.prototype.trim), ur = zr(RegExp.prototype.test), Au = Gk(TypeError);
function zr(t) {
  return function(e) {
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
      n[i - 1] = arguments[i];
    return Fl(t, e, n);
  };
}
function Gk(t) {
  return function() {
    for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++)
      r[n] = arguments[n];
    return wh(t, r);
  };
}
function le(t, e, r) {
  r = r || Qo, Qf && Qf(t, null);
  for (var n = e.length; n--; ) {
    var i = e[n];
    if (typeof i == "string") {
      var s = r(i);
      s !== i && (Ok(e) || (e[n] = s), i = s);
    }
    t[i] = !0;
  }
  return t;
}
function Ti(t) {
  var e = Yk(null), r;
  for (r in t)
    Fl(Fk, t, [r]) === !0 && (e[r] = t[r]);
  return e;
}
function No(t, e) {
  for (; t !== null; ) {
    var r = Vk(t, e);
    if (r) {
      if (r.get)
        return zr(r.get);
      if (typeof r.value == "function")
        return zr(r.value);
    }
    t = Pk(t);
  }
  function n(i) {
    return console.warn("fallback value for", i), null;
  }
  return n;
}
var td = yr(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Lu = yr(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Bu = yr(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), qk = yr(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Du = yr(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), $k = yr(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), ed = yr(["#text"]), rd = yr(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), Iu = yr(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), nd = yr(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Ro = yr(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), jk = rn(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Xk = rn(/<%[\w\W]*|[\w\W]*%>/gm), Kk = rn(/\${[\w\W]*}/gm), Zk = rn(/^data-[\-\w.\u00B7-\uFFFF]/), Qk = rn(/^aria-[\-\w]+$/), Jk = rn(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), t8 = rn(/^(?:\w+script|data):/i), e8 = rn(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), r8 = rn(/^html$/i), n8 = function() {
  return typeof window > "u" ? null : window;
}, i8 = function(e, r) {
  if (ai(e) !== "object" || typeof e.createPolicy != "function")
    return null;
  var n = null, i = "data-tt-policy-suffix";
  r.currentScript && r.currentScript.hasAttribute(i) && (n = r.currentScript.getAttribute(i));
  var s = "dompurify" + (n ? "#" + n : "");
  try {
    return e.createPolicy(s, {
      createHTML: function(o) {
        return o;
      },
      createScriptURL: function(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
};
function fg() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : n8(), e = function(K) {
    return fg(K);
  };
  if (e.version = "2.4.3", e.removed = [], !t || !t.document || t.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var r = t.document, n = t.document, i = t.DocumentFragment, s = t.HTMLTemplateElement, a = t.Node, o = t.Element, l = t.NodeFilter, u = t.NamedNodeMap, h = u === void 0 ? t.NamedNodeMap || t.MozNamedAttrMap : u, f = t.HTMLFormElement, d = t.DOMParser, p = t.trustedTypes, m = o.prototype, _ = No(m, "cloneNode"), v = No(m, "nextSibling"), k = No(m, "childNodes"), x = No(m, "parentNode");
  if (typeof s == "function") {
    var D = n.createElement("template");
    D.content && D.content.ownerDocument && (n = D.content.ownerDocument);
  }
  var F = i8(p, r), P = F ? F.createHTML("") : "", V = n, R = V.implementation, O = V.createNodeIterator, C = V.createDocumentFragment, S = V.getElementsByTagName, T = r.importNode, b = {};
  try {
    b = Ti(n).documentMode ? n.documentMode : {};
  } catch {
  }
  var w = {};
  e.isSupported = typeof x == "function" && R && typeof R.createHTMLDocument < "u" && b !== 9;
  var g = jk, M = Xk, y = Kk, N = Zk, it = Qk, Y = t8, Z = e8, J = Jk, X = null, tt = le({}, [].concat(qr(td), qr(Lu), qr(Bu), qr(Du), qr(ed))), st = null, lt = le({}, [].concat(qr(rd), qr(Iu), qr(nd), qr(Ro))), U = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Tt = null, $ = null, j = !0, W = !0, z = !1, A = !1, I = !1, G = !1, L = !1, at = !1, E = !1, Dt = !1, et = !0, Et = !1, vt = "user-content-", pt = !0, ht = !1, gt = {}, ut = null, yt = le({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), ue = null, re = le({}, ["audio", "video", "img", "source", "image", "track"]), Mt = null, Nt = le({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Kt = "http://www.w3.org/1998/Math/MathML", fe = "http://www.w3.org/2000/svg", Gt = "http://www.w3.org/1999/xhtml", Ot = Gt, Bt = !1, bt = null, mt = le({}, [Kt, fe, Gt], Su), wt, ft = ["application/xhtml+xml", "text/html"], It = "text/html", nt, Wt = null, ct = n.createElement("form"), qt = function(K) {
    return K instanceof RegExp || K instanceof Function;
  }, Jt = function(K) {
    Wt && Wt === K || ((!K || ai(K) !== "object") && (K = {}), K = Ti(K), wt = // eslint-disable-next-line unicorn/prefer-includes
    ft.indexOf(K.PARSER_MEDIA_TYPE) === -1 ? wt = It : wt = K.PARSER_MEDIA_TYPE, nt = wt === "application/xhtml+xml" ? Su : Qo, X = "ALLOWED_TAGS" in K ? le({}, K.ALLOWED_TAGS, nt) : tt, st = "ALLOWED_ATTR" in K ? le({}, K.ALLOWED_ATTR, nt) : lt, bt = "ALLOWED_NAMESPACES" in K ? le({}, K.ALLOWED_NAMESPACES, Su) : mt, Mt = "ADD_URI_SAFE_ATTR" in K ? le(
      Ti(Nt),
      // eslint-disable-line indent
      K.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      nt
      // eslint-disable-line indent
    ) : Nt, ue = "ADD_DATA_URI_TAGS" in K ? le(
      Ti(re),
      // eslint-disable-line indent
      K.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      nt
      // eslint-disable-line indent
    ) : re, ut = "FORBID_CONTENTS" in K ? le({}, K.FORBID_CONTENTS, nt) : yt, Tt = "FORBID_TAGS" in K ? le({}, K.FORBID_TAGS, nt) : {}, $ = "FORBID_ATTR" in K ? le({}, K.FORBID_ATTR, nt) : {}, gt = "USE_PROFILES" in K ? K.USE_PROFILES : !1, j = K.ALLOW_ARIA_ATTR !== !1, W = K.ALLOW_DATA_ATTR !== !1, z = K.ALLOW_UNKNOWN_PROTOCOLS || !1, A = K.SAFE_FOR_TEMPLATES || !1, I = K.WHOLE_DOCUMENT || !1, at = K.RETURN_DOM || !1, E = K.RETURN_DOM_FRAGMENT || !1, Dt = K.RETURN_TRUSTED_TYPE || !1, L = K.FORCE_BODY || !1, et = K.SANITIZE_DOM !== !1, Et = K.SANITIZE_NAMED_PROPS || !1, pt = K.KEEP_CONTENT !== !1, ht = K.IN_PLACE || !1, J = K.ALLOWED_URI_REGEXP || J, Ot = K.NAMESPACE || Gt, K.CUSTOM_ELEMENT_HANDLING && qt(K.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (U.tagNameCheck = K.CUSTOM_ELEMENT_HANDLING.tagNameCheck), K.CUSTOM_ELEMENT_HANDLING && qt(K.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (U.attributeNameCheck = K.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), K.CUSTOM_ELEMENT_HANDLING && typeof K.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (U.allowCustomizedBuiltInElements = K.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), A && (W = !1), E && (at = !0), gt && (X = le({}, qr(ed)), st = [], gt.html === !0 && (le(X, td), le(st, rd)), gt.svg === !0 && (le(X, Lu), le(st, Iu), le(st, Ro)), gt.svgFilters === !0 && (le(X, Bu), le(st, Iu), le(st, Ro)), gt.mathMl === !0 && (le(X, Du), le(st, nd), le(st, Ro))), K.ADD_TAGS && (X === tt && (X = Ti(X)), le(X, K.ADD_TAGS, nt)), K.ADD_ATTR && (st === lt && (st = Ti(st)), le(st, K.ADD_ATTR, nt)), K.ADD_URI_SAFE_ATTR && le(Mt, K.ADD_URI_SAFE_ATTR, nt), K.FORBID_CONTENTS && (ut === yt && (ut = Ti(ut)), le(ut, K.FORBID_CONTENTS, nt)), pt && (X["#text"] = !0), I && le(X, ["html", "head", "body"]), X.table && (le(X, ["tbody"]), delete Tt.tbody), yr && yr(K), Wt = K);
  }, se = le({}, ["mi", "mo", "mn", "ms", "mtext"]), ne = le({}, ["foreignobject", "desc", "title", "annotation-xml"]), ae = le({}, ["title", "style", "font", "a", "script"]), Rt = le({}, Lu);
  le(Rt, Bu), le(Rt, qk);
  var Ht = le({}, Du);
  le(Ht, $k);
  var ie = function(K) {
    var xt = x(K);
    (!xt || !xt.tagName) && (xt = {
      namespaceURI: Ot,
      tagName: "template"
    });
    var Ct = Qo(K.tagName), te = Qo(xt.tagName);
    return bt[K.namespaceURI] ? K.namespaceURI === fe ? xt.namespaceURI === Gt ? Ct === "svg" : xt.namespaceURI === Kt ? Ct === "svg" && (te === "annotation-xml" || se[te]) : Boolean(Rt[Ct]) : K.namespaceURI === Kt ? xt.namespaceURI === Gt ? Ct === "math" : xt.namespaceURI === fe ? Ct === "math" && ne[te] : Boolean(Ht[Ct]) : K.namespaceURI === Gt ? xt.namespaceURI === fe && !ne[te] || xt.namespaceURI === Kt && !se[te] ? !1 : !Ht[Ct] && (ae[Ct] || !Rt[Ct]) : !!(wt === "application/xhtml+xml" && bt[K.namespaceURI]) : !1;
  }, Ut = function(K) {
    la(e.removed, {
      element: K
    });
    try {
      K.parentNode.removeChild(K);
    } catch {
      try {
        K.outerHTML = P;
      } catch {
        K.remove();
      }
    }
  }, Sn = function(K, xt) {
    try {
      la(e.removed, {
        attribute: xt.getAttributeNode(K),
        from: xt
      });
    } catch {
      la(e.removed, {
        attribute: null,
        from: xt
      });
    }
    if (xt.removeAttribute(K), K === "is" && !st[K])
      if (at || E)
        try {
          Ut(xt);
        } catch {
        }
      else
        try {
          xt.setAttribute(K, "");
        } catch {
        }
  }, xi = function(K) {
    var xt, Ct;
    if (L)
      K = "<remove></remove>" + K;
    else {
      var te = Uk(K, /^[\r\n\t ]+/);
      Ct = te && te[0];
    }
    wt === "application/xhtml+xml" && Ot === Gt && (K = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + K + "</body></html>");
    var de = F ? F.createHTML(K) : K;
    if (Ot === Gt)
      try {
        xt = new d().parseFromString(de, wt);
      } catch {
      }
    if (!xt || !xt.documentElement) {
      xt = R.createDocument(Ot, "template", null);
      try {
        xt.documentElement.innerHTML = Bt ? P : de;
      } catch {
      }
    }
    var ge = xt.body || xt.documentElement;
    return K && Ct && ge.insertBefore(n.createTextNode(Ct), ge.childNodes[0] || null), Ot === Gt ? S.call(xt, I ? "html" : "body")[0] : I ? xt.documentElement : ge;
  }, me = function(K) {
    return O.call(
      K.ownerDocument || K,
      K,
      // eslint-disable-next-line no-bitwise
      l.SHOW_ELEMENT | l.SHOW_COMMENT | l.SHOW_TEXT,
      null,
      !1
    );
  }, $t = function(K) {
    return K instanceof f && (typeof K.nodeName != "string" || typeof K.textContent != "string" || typeof K.removeChild != "function" || !(K.attributes instanceof h) || typeof K.removeAttribute != "function" || typeof K.setAttribute != "function" || typeof K.namespaceURI != "string" || typeof K.insertBefore != "function" || typeof K.hasChildNodes != "function");
  }, Ce = function(K) {
    return ai(a) === "object" ? K instanceof a : K && ai(K) === "object" && typeof K.nodeType == "number" && typeof K.nodeName == "string";
  }, rr = function(K, xt, Ct) {
    w[K] && zk(w[K], function(te) {
      te.call(e, xt, Ct, Wt);
    });
  }, Se = function(K) {
    var xt;
    if (rr("beforeSanitizeElements", K, null), $t(K) || ur(/[\u0080-\uFFFF]/, K.nodeName))
      return Ut(K), !0;
    var Ct = nt(K.nodeName);
    if (rr("uponSanitizeElement", K, {
      tagName: Ct,
      allowedTags: X
    }), K.hasChildNodes() && !Ce(K.firstElementChild) && (!Ce(K.content) || !Ce(K.content.firstElementChild)) && ur(/<[/\w]/g, K.innerHTML) && ur(/<[/\w]/g, K.textContent) || Ct === "select" && ur(/<template/i, K.innerHTML))
      return Ut(K), !0;
    if (!X[Ct] || Tt[Ct]) {
      if (!Tt[Ct] && be(Ct) && (U.tagNameCheck instanceof RegExp && ur(U.tagNameCheck, Ct) || U.tagNameCheck instanceof Function && U.tagNameCheck(Ct)))
        return !1;
      if (pt && !ut[Ct]) {
        var te = x(K) || K.parentNode, de = k(K) || K.childNodes;
        if (de && te)
          for (var ge = de.length, Me = ge - 1; Me >= 0; --Me)
            te.insertBefore(_(de[Me], !0), v(K));
      }
      return Ut(K), !0;
    }
    return K instanceof o && !ie(K) || (Ct === "noscript" || Ct === "noembed") && ur(/<\/no(script|embed)/i, K.innerHTML) ? (Ut(K), !0) : (A && K.nodeType === 3 && (xt = K.textContent, xt = Gr(xt, g, " "), xt = Gr(xt, M, " "), xt = Gr(xt, y, " "), K.textContent !== xt && (la(e.removed, {
      element: K.cloneNode()
    }), K.textContent = xt)), rr("afterSanitizeElements", K, null), !1);
  }, Ye = function(K, xt, Ct) {
    if (et && (xt === "id" || xt === "name") && (Ct in n || Ct in ct))
      return !1;
    if (!(W && !$[xt] && ur(N, xt))) {
      if (!(j && ur(it, xt))) {
        if (!st[xt] || $[xt]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(be(K) && (U.tagNameCheck instanceof RegExp && ur(U.tagNameCheck, K) || U.tagNameCheck instanceof Function && U.tagNameCheck(K)) && (U.attributeNameCheck instanceof RegExp && ur(U.attributeNameCheck, xt) || U.attributeNameCheck instanceof Function && U.attributeNameCheck(xt)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            xt === "is" && U.allowCustomizedBuiltInElements && (U.tagNameCheck instanceof RegExp && ur(U.tagNameCheck, Ct) || U.tagNameCheck instanceof Function && U.tagNameCheck(Ct)))
          )
            return !1;
        } else if (!Mt[xt]) {
          if (!ur(J, Gr(Ct, Z, ""))) {
            if (!((xt === "src" || xt === "xlink:href" || xt === "href") && K !== "script" && Wk(Ct, "data:") === 0 && ue[K])) {
              if (!(z && !ur(Y, Gr(Ct, Z, "")))) {
                if (Ct)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, be = function(K) {
    return K.indexOf("-") > 0;
  }, Je = function(K) {
    var xt, Ct, te, de;
    rr("beforeSanitizeAttributes", K, null);
    var ge = K.attributes;
    if (ge) {
      var Me = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: st
      };
      for (de = ge.length; de--; ) {
        xt = ge[de];
        var qe = xt, we = qe.name, ra = qe.namespaceURI;
        if (Ct = we === "value" ? xt.value : Hk(xt.value), te = nt(we), Me.attrName = te, Me.attrValue = Ct, Me.keepAttr = !0, Me.forceKeepAttr = void 0, rr("uponSanitizeAttribute", K, Me), Ct = Me.attrValue, !Me.forceKeepAttr && (Sn(we, K), !!Me.keepAttr)) {
          if (ur(/\/>/i, Ct)) {
            Sn(we, K);
            continue;
          }
          A && (Ct = Gr(Ct, g, " "), Ct = Gr(Ct, M, " "), Ct = Gr(Ct, y, " "));
          var is = nt(K.nodeName);
          if (Ye(is, te, Ct)) {
            if (Et && (te === "id" || te === "name") && (Sn(we, K), Ct = vt + Ct), F && ai(p) === "object" && typeof p.getAttributeType == "function" && !ra)
              switch (p.getAttributeType(is, te)) {
                case "TrustedHTML":
                  Ct = F.createHTML(Ct);
                  break;
                case "TrustedScriptURL":
                  Ct = F.createScriptURL(Ct);
                  break;
              }
            try {
              ra ? K.setAttributeNS(ra, we, Ct) : K.setAttribute(we, Ct), Jf(e.removed);
            } catch {
            }
          }
        }
      }
      rr("afterSanitizeAttributes", K, null);
    }
  }, Ge = function Lt(K) {
    var xt, Ct = me(K);
    for (rr("beforeSanitizeShadowDOM", K, null); xt = Ct.nextNode(); )
      rr("uponSanitizeShadowNode", xt, null), !Se(xt) && (xt.content instanceof i && Lt(xt.content), Je(xt));
    rr("afterSanitizeShadowDOM", K, null);
  };
  return e.sanitize = function(Lt) {
    var K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, xt, Ct, te, de, ge;
    if (Bt = !Lt, Bt && (Lt = "<!-->"), typeof Lt != "string" && !Ce(Lt)) {
      if (typeof Lt.toString != "function")
        throw Au("toString is not a function");
      if (Lt = Lt.toString(), typeof Lt != "string")
        throw Au("dirty is not a string, aborting");
    }
    if (!e.isSupported) {
      if (ai(t.toStaticHTML) === "object" || typeof t.toStaticHTML == "function") {
        if (typeof Lt == "string")
          return t.toStaticHTML(Lt);
        if (Ce(Lt))
          return t.toStaticHTML(Lt.outerHTML);
      }
      return Lt;
    }
    if (G || Jt(K), e.removed = [], typeof Lt == "string" && (ht = !1), ht) {
      if (Lt.nodeName) {
        var Me = nt(Lt.nodeName);
        if (!X[Me] || Tt[Me])
          throw Au("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Lt instanceof a)
      xt = xi("<!---->"), Ct = xt.ownerDocument.importNode(Lt, !0), Ct.nodeType === 1 && Ct.nodeName === "BODY" || Ct.nodeName === "HTML" ? xt = Ct : xt.appendChild(Ct);
    else {
      if (!at && !A && !I && // eslint-disable-next-line unicorn/prefer-includes
      Lt.indexOf("<") === -1)
        return F && Dt ? F.createHTML(Lt) : Lt;
      if (xt = xi(Lt), !xt)
        return at ? null : Dt ? P : "";
    }
    xt && L && Ut(xt.firstChild);
    for (var qe = me(ht ? Lt : xt); te = qe.nextNode(); )
      te.nodeType === 3 && te === de || Se(te) || (te.content instanceof i && Ge(te.content), Je(te), de = te);
    if (de = null, ht)
      return Lt;
    if (at) {
      if (E)
        for (ge = C.call(xt.ownerDocument); xt.firstChild; )
          ge.appendChild(xt.firstChild);
      else
        ge = xt;
      return st.shadowroot && (ge = T.call(r, ge, !0)), ge;
    }
    var we = I ? xt.outerHTML : xt.innerHTML;
    return I && X["!doctype"] && xt.ownerDocument && xt.ownerDocument.doctype && xt.ownerDocument.doctype.name && ur(r8, xt.ownerDocument.doctype.name) && (we = "<!DOCTYPE " + xt.ownerDocument.doctype.name + `>
` + we), A && (we = Gr(we, g, " "), we = Gr(we, M, " "), we = Gr(we, y, " ")), F && Dt ? F.createHTML(we) : we;
  }, e.setConfig = function(Lt) {
    Jt(Lt), G = !0;
  }, e.clearConfig = function() {
    Wt = null, G = !1;
  }, e.isValidAttribute = function(Lt, K, xt) {
    Wt || Jt({});
    var Ct = nt(Lt), te = nt(K);
    return Ye(Ct, te, xt);
  }, e.addHook = function(Lt, K) {
    typeof K == "function" && (w[Lt] = w[Lt] || [], la(w[Lt], K));
  }, e.removeHook = function(Lt) {
    if (w[Lt])
      return Jf(w[Lt]);
  }, e.removeHooks = function(Lt) {
    w[Lt] && (w[Lt] = []);
  }, e.removeAllHooks = function() {
    w = {};
  }, e;
}
var Va = fg();
const s8 = (t) => t ? pg(t).replace(/\\n/g, "#br#").split("#br#") : [""], dg = (t) => Va.sanitize(t), id = (t, e) => {
  var r;
  if (((r = e.flowchart) == null ? void 0 : r.htmlLabels) !== !1) {
    const n = e.securityLevel;
    n === "antiscript" || n === "strict" ? t = dg(t) : n !== "loose" && (t = pg(t), t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;"), t = t.replace(/=/g, "&equals;"), t = c8(t));
  }
  return t;
}, Ur = (t, e) => t && (e.dompurifyConfig ? t = Va.sanitize(id(t, e), e.dompurifyConfig).toString() : t = Va.sanitize(id(t, e), {
  FORBID_TAGS: ["style"]
}).toString(), t), a8 = (t, e) => typeof t == "string" ? Ur(t, e) : t.flat().map((r) => Ur(r, e)), Cc = /<br\s*\/?>/gi, o8 = (t) => Cc.test(t), l8 = (t) => t.split(Cc), c8 = (t) => t.replace(/#br#/g, "<br/>"), pg = (t) => t.replace(Cc, "#br#"), u8 = (t) => {
  let e = "";
  return t && (e = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, e = e.replaceAll(/\(/g, "\\("), e = e.replaceAll(/\)/g, "\\)")), e;
}, Ke = (t) => !(t === !1 || ["false", "null", "0"].includes(String(t).trim().toLowerCase())), ci = function(t) {
  let e = t;
  if (t.split("~").length - 1 >= 2) {
    let r = e;
    do
      e = r, r = e.replace(/~([^\s,:;]+)~/, "<$1>");
    while (r != e);
    return ci(r);
  } else
    return e;
}, Xt = {
  getRows: s8,
  sanitizeText: Ur,
  sanitizeTextOrArray: a8,
  hasBreaks: o8,
  splitBreaks: l8,
  lineBreakRegex: Cc,
  removeScript: dg,
  getUrl: u8,
  evaluate: Ke
}, Jo = {
  /* CLAMP */
  min: {
    r: 0,
    g: 0,
    b: 0,
    s: 0,
    l: 0,
    a: 0
  },
  max: {
    r: 255,
    g: 255,
    b: 255,
    h: 360,
    s: 100,
    l: 100,
    a: 1
  },
  clamp: {
    r: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    g: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    b: (t) => t >= 255 ? 255 : t < 0 ? 0 : t,
    h: (t) => t % 360,
    s: (t) => t >= 100 ? 100 : t < 0 ? 0 : t,
    l: (t) => t >= 100 ? 100 : t < 0 ? 0 : t,
    a: (t) => t >= 1 ? 1 : t < 0 ? 0 : t
  },
  /* CONVERSION */
  //SOURCE: https://planetcalc.com/7779
  toLinear: (t) => {
    const e = t / 255;
    return t > 0.03928 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92;
  },
  //SOURCE: https://gist.github.com/mjackson/5311256
  hue2rgb: (t, e, r) => (r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t),
  hsl2rgb: ({ h: t, s: e, l: r }, n) => {
    if (!e)
      return r * 2.55;
    t /= 360, e /= 100, r /= 100;
    const i = r < 0.5 ? r * (1 + e) : r + e - r * e, s = 2 * r - i;
    switch (n) {
      case "r":
        return Jo.hue2rgb(s, i, t + 1 / 3) * 255;
      case "g":
        return Jo.hue2rgb(s, i, t) * 255;
      case "b":
        return Jo.hue2rgb(s, i, t - 1 / 3) * 255;
    }
  },
  rgb2hsl: ({ r: t, g: e, b: r }, n) => {
    t /= 255, e /= 255, r /= 255;
    const i = Math.max(t, e, r), s = Math.min(t, e, r), a = (i + s) / 2;
    if (n === "l")
      return a * 100;
    if (i === s)
      return 0;
    const o = i - s, l = a > 0.5 ? o / (2 - i - s) : o / (i + s);
    if (n === "s")
      return l * 100;
    switch (i) {
      case t:
        return ((e - r) / o + (e < r ? 6 : 0)) * 60;
      case e:
        return ((r - t) / o + 2) * 60;
      case r:
        return ((t - e) / o + 4) * 60;
      default:
        return -1;
    }
  }
}, h8 = Jo, f8 = {
  /* API */
  clamp: (t, e, r) => e > r ? Math.min(e, Math.max(r, t)) : Math.min(r, Math.max(e, t)),
  round: (t) => Math.round(t * 1e10) / 1e10
}, d8 = f8, p8 = {
  /* API */
  dec2hex: (t) => {
    const e = Math.round(t).toString(16);
    return e.length > 1 ? e : `0${e}`;
  }
}, g8 = p8, y8 = {
  channel: h8,
  lang: d8,
  unit: g8
}, ee = y8, ii = {};
for (let t = 0; t <= 255; t++)
  ii[t] = ee.unit.dec2hex(t);
const sr = {
  ALL: 0,
  RGB: 1,
  HSL: 2
};
class m8 {
  constructor() {
    this.type = sr.ALL;
  }
  /* API */
  get() {
    return this.type;
  }
  set(e) {
    if (this.type && this.type !== e)
      throw new Error("Cannot change both RGB and HSL channels at the same time");
    this.type = e;
  }
  reset() {
    this.type = sr.ALL;
  }
  is(e) {
    return this.type === e;
  }
}
const b8 = m8;
class _8 {
  /* CONSTRUCTOR */
  constructor(e, r) {
    this.color = r, this.changed = !1, this.data = e, this.type = new b8();
  }
  /* API */
  set(e, r) {
    return this.color = r, this.changed = !1, this.data = e, this.type.type = sr.ALL, this;
  }
  /* HELPERS */
  _ensureHSL() {
    const e = this.data, { h: r, s: n, l: i } = e;
    r === void 0 && (e.h = ee.channel.rgb2hsl(e, "h")), n === void 0 && (e.s = ee.channel.rgb2hsl(e, "s")), i === void 0 && (e.l = ee.channel.rgb2hsl(e, "l"));
  }
  _ensureRGB() {
    const e = this.data, { r, g: n, b: i } = e;
    r === void 0 && (e.r = ee.channel.hsl2rgb(e, "r")), n === void 0 && (e.g = ee.channel.hsl2rgb(e, "g")), i === void 0 && (e.b = ee.channel.hsl2rgb(e, "b"));
  }
  /* GETTERS */
  get r() {
    const e = this.data, r = e.r;
    return !this.type.is(sr.HSL) && r !== void 0 ? r : (this._ensureHSL(), ee.channel.hsl2rgb(e, "r"));
  }
  get g() {
    const e = this.data, r = e.g;
    return !this.type.is(sr.HSL) && r !== void 0 ? r : (this._ensureHSL(), ee.channel.hsl2rgb(e, "g"));
  }
  get b() {
    const e = this.data, r = e.b;
    return !this.type.is(sr.HSL) && r !== void 0 ? r : (this._ensureHSL(), ee.channel.hsl2rgb(e, "b"));
  }
  get h() {
    const e = this.data, r = e.h;
    return !this.type.is(sr.RGB) && r !== void 0 ? r : (this._ensureRGB(), ee.channel.rgb2hsl(e, "h"));
  }
  get s() {
    const e = this.data, r = e.s;
    return !this.type.is(sr.RGB) && r !== void 0 ? r : (this._ensureRGB(), ee.channel.rgb2hsl(e, "s"));
  }
  get l() {
    const e = this.data, r = e.l;
    return !this.type.is(sr.RGB) && r !== void 0 ? r : (this._ensureRGB(), ee.channel.rgb2hsl(e, "l"));
  }
  get a() {
    return this.data.a;
  }
  /* SETTERS */
  set r(e) {
    this.type.set(sr.RGB), this.changed = !0, this.data.r = e;
  }
  set g(e) {
    this.type.set(sr.RGB), this.changed = !0, this.data.g = e;
  }
  set b(e) {
    this.type.set(sr.RGB), this.changed = !0, this.data.b = e;
  }
  set h(e) {
    this.type.set(sr.HSL), this.changed = !0, this.data.h = e;
  }
  set s(e) {
    this.type.set(sr.HSL), this.changed = !0, this.data.s = e;
  }
  set l(e) {
    this.type.set(sr.HSL), this.changed = !0, this.data.l = e;
  }
  set a(e) {
    this.changed = !0, this.data.a = e;
  }
}
const x8 = _8, v8 = new x8({ r: 0, g: 0, b: 0, a: 0 }, "transparent"), Sc = v8, gg = {
  /* VARIABLES */
  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
  /* API */
  parse: (t) => {
    if (t.charCodeAt(0) !== 35)
      return;
    const e = t.match(gg.re);
    if (!e)
      return;
    const r = e[1], n = parseInt(r, 16), i = r.length, s = i % 4 === 0, a = i > 4, o = a ? 1 : 17, l = a ? 8 : 4, u = s ? 0 : -1, h = a ? 255 : 15;
    return Sc.set({
      r: (n >> l * (u + 3) & h) * o,
      g: (n >> l * (u + 2) & h) * o,
      b: (n >> l * (u + 1) & h) * o,
      a: s ? (n & h) * o / 255 : 1
    }, t);
  },
  stringify: (t) => {
    const { r: e, g: r, b: n, a: i } = t;
    return i < 1 ? `#${ii[Math.round(e)]}${ii[Math.round(r)]}${ii[Math.round(n)]}${ii[Math.round(i * 255)]}` : `#${ii[Math.round(e)]}${ii[Math.round(r)]}${ii[Math.round(n)]}`;
  }
}, Ta = gg, tl = {
  /* VARIABLES */
  re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
  /* HELPERS */
  _hue2deg: (t) => {
    const e = t.match(tl.hueRe);
    if (e) {
      const [, r, n] = e;
      switch (n) {
        case "grad":
          return ee.channel.clamp.h(parseFloat(r) * 0.9);
        case "rad":
          return ee.channel.clamp.h(parseFloat(r) * 180 / Math.PI);
        case "turn":
          return ee.channel.clamp.h(parseFloat(r) * 360);
      }
    }
    return ee.channel.clamp.h(parseFloat(t));
  },
  /* API */
  parse: (t) => {
    const e = t.charCodeAt(0);
    if (e !== 104 && e !== 72)
      return;
    const r = t.match(tl.re);
    if (!r)
      return;
    const [, n, i, s, a, o] = r;
    return Sc.set({
      h: tl._hue2deg(n),
      s: ee.channel.clamp.s(parseFloat(i)),
      l: ee.channel.clamp.l(parseFloat(s)),
      a: a ? ee.channel.clamp.a(o ? parseFloat(a) / 100 : parseFloat(a)) : 1
    }, t);
  },
  stringify: (t) => {
    const { h: e, s: r, l: n, a: i } = t;
    return i < 1 ? `hsla(${ee.lang.round(e)}, ${ee.lang.round(r)}%, ${ee.lang.round(n)}%, ${i})` : `hsl(${ee.lang.round(e)}, ${ee.lang.round(r)}%, ${ee.lang.round(n)}%)`;
  }
}, Fo = tl, el = {
  /* VARIABLES */
  colors: {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyanaqua: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    transparent: "#00000000",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  },
  /* API */
  parse: (t) => {
    t = t.toLowerCase();
    const e = el.colors[t];
    if (e)
      return Ta.parse(e);
  },
  stringify: (t) => {
    const e = Ta.stringify(t);
    for (const r in el.colors)
      if (el.colors[r] === e)
        return r;
  }
}, sd = el, yg = {
  /* VARIABLES */
  re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
  /* API */
  parse: (t) => {
    const e = t.charCodeAt(0);
    if (e !== 114 && e !== 82)
      return;
    const r = t.match(yg.re);
    if (!r)
      return;
    const [, n, i, s, a, o, l, u, h] = r;
    return Sc.set({
      r: ee.channel.clamp.r(i ? parseFloat(n) * 2.55 : parseFloat(n)),
      g: ee.channel.clamp.g(a ? parseFloat(s) * 2.55 : parseFloat(s)),
      b: ee.channel.clamp.b(l ? parseFloat(o) * 2.55 : parseFloat(o)),
      a: u ? ee.channel.clamp.a(h ? parseFloat(u) / 100 : parseFloat(u)) : 1
    }, t);
  },
  stringify: (t) => {
    const { r: e, g: r, b: n, a: i } = t;
    return i < 1 ? `rgba(${ee.lang.round(e)}, ${ee.lang.round(r)}, ${ee.lang.round(n)}, ${ee.lang.round(i)})` : `rgb(${ee.lang.round(e)}, ${ee.lang.round(r)}, ${ee.lang.round(n)})`;
  }
}, Oo = yg, k8 = {
  /* VARIABLES */
  format: {
    keyword: sd,
    hex: Ta,
    rgb: Oo,
    rgba: Oo,
    hsl: Fo,
    hsla: Fo
  },
  /* API */
  parse: (t) => {
    if (typeof t != "string")
      return t;
    const e = Ta.parse(t) || Oo.parse(t) || Fo.parse(t) || sd.parse(t);
    if (e)
      return e;
    throw new Error(`Unsupported color format: "${t}"`);
  },
  stringify: (t) => !t.changed && t.color ? t.color : t.type.is(sr.HSL) || t.data.r === void 0 ? Fo.stringify(t) : t.a < 1 || !Number.isInteger(t.r) || !Number.isInteger(t.g) || !Number.isInteger(t.b) ? Oo.stringify(t) : Ta.stringify(t)
}, Zn = k8, w8 = (t, e) => {
  const r = Zn.parse(t);
  for (const n in e)
    r[n] = ee.channel.clamp[n](e[n]);
  return Zn.stringify(r);
}, mg = w8, T8 = (t, e, r = 0, n = 1) => {
  if (typeof t != "number")
    return mg(t, { a: e });
  const i = Sc.set({
    r: ee.channel.clamp.r(t),
    g: ee.channel.clamp.g(e),
    b: ee.channel.clamp.b(r),
    a: ee.channel.clamp.a(n)
  });
  return Zn.stringify(i);
}, Ea = T8, E8 = (t, e, r) => {
  const n = Zn.parse(t), i = n[e], s = ee.channel.clamp[e](i + r);
  return i !== s && (n[e] = s), Zn.stringify(n);
}, bg = E8, C8 = (t, e) => bg(t, "l", e), zt = C8, S8 = (t, e) => bg(t, "l", -e), Zt = S8, A8 = (t, e) => {
  const r = Zn.parse(t), n = {};
  for (const i in e)
    e[i] && (n[i] = r[i] + e[i]);
  return mg(t, n);
}, ot = A8, L8 = (t, e, r = 50) => {
  const { r: n, g: i, b: s, a } = Zn.parse(t), { r: o, g: l, b: u, a: h } = Zn.parse(e), f = r / 100, d = f * 2 - 1, p = a - h, _ = ((d * p === -1 ? d : (d + p) / (1 + d * p)) + 1) / 2, v = 1 - _, k = n * _ + o * v, x = i * _ + l * v, D = s * _ + u * v, F = a * f + h * (1 - f);
  return Ea(k, x, D, F);
}, B8 = L8, D8 = (t, e = 100) => {
  const r = Zn.parse(t);
  return r.r = 255 - r.r, r.g = 255 - r.g, r.b = 255 - r.b, B8(r, t, e);
}, At = D8, fr = (t, e) => e ? ot(t, { s: -40, l: 10 }) : ot(t, { s: -40, l: -10 }), Ac = "#ffffff", Lc = "#f2f2f2";
let I8 = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#fff4dd", this.noteBkgColor = "#fff5ad", this.noteTextColor = "#333", this.THEME_COLOR_LIMIT = 12, this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px";
  }
  updateColors() {
    if (this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333"), this.secondaryColor = this.secondaryColor || ot(this.primaryColor, { h: -120 }), this.tertiaryColor = this.tertiaryColor || ot(this.primaryColor, { h: 180, l: 5 }), this.primaryBorderColor = this.primaryBorderColor || fr(this.primaryColor, this.darkMode), this.secondaryBorderColor = this.secondaryBorderColor || fr(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = this.tertiaryBorderColor || fr(this.tertiaryColor, this.darkMode), this.noteBorderColor = this.noteBorderColor || fr(this.noteBkgColor, this.darkMode), this.noteBkgColor = this.noteBkgColor || "#fff5ad", this.noteTextColor = this.noteTextColor || "#333", this.secondaryTextColor = this.secondaryTextColor || At(this.secondaryColor), this.tertiaryTextColor = this.tertiaryTextColor || At(this.tertiaryColor), this.lineColor = this.lineColor || At(this.background), this.textColor = this.textColor || this.primaryTextColor, this.nodeBkg = this.nodeBkg || this.primaryColor, this.mainBkg = this.mainBkg || this.primaryColor, this.nodeBorder = this.nodeBorder || this.primaryBorderColor, this.clusterBkg = this.clusterBkg || this.tertiaryColor, this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor, this.defaultLinkColor = this.defaultLinkColor || this.lineColor, this.titleColor = this.titleColor || this.tertiaryTextColor, this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? Zt(this.secondaryColor, 30) : this.secondaryColor), this.nodeTextColor = this.nodeTextColor || this.primaryTextColor, this.actorBorder = this.actorBorder || this.primaryBorderColor, this.actorBkg = this.actorBkg || this.mainBkg, this.actorTextColor = this.actorTextColor || this.primaryTextColor, this.actorLineColor = this.actorLineColor || "grey", this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg, this.signalColor = this.signalColor || this.textColor, this.signalTextColor = this.signalTextColor || this.textColor, this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder, this.labelTextColor = this.labelTextColor || this.actorTextColor, this.loopTextColor = this.loopTextColor || this.actorTextColor, this.activationBorderColor = this.activationBorderColor || Zt(this.secondaryColor, 10), this.activationBkgColor = this.activationBkgColor || this.secondaryColor, this.sequenceNumberColor = this.sequenceNumberColor || At(this.lineColor), this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor, this.altSectionBkgColor = this.altSectionBkgColor || "white", this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor, this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor, this.excludeBkgColor = this.excludeBkgColor || "#eeeeee", this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor, this.taskBkgColor = this.taskBkgColor || this.primaryColor, this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor, this.activeTaskBkgColor = this.activeTaskBkgColor || zt(this.primaryColor, 23), this.gridColor = this.gridColor || "lightgrey", this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey", this.doneTaskBorderColor = this.doneTaskBorderColor || "grey", this.critBorderColor = this.critBorderColor || "#ff8888", this.critBkgColor = this.critBkgColor || "red", this.todayLineColor = this.todayLineColor || "red", this.taskTextColor = this.taskTextColor || this.textColor, this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor, this.taskTextLightColor = this.taskTextLightColor || this.textColor, this.taskTextColor = this.taskTextColor || this.primaryTextColor, this.taskTextDarkColor = this.taskTextDarkColor || this.textColor, this.taskTextClickableColor = this.taskTextClickableColor || "#003163", this.personBorder = this.personBorder || this.primaryBorderColor, this.personBkg = this.personBkg || this.mainBkg, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || this.tertiaryColor, this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.specialStateColor = this.lineColor, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || ot(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || ot(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || ot(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || ot(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || ot(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || ot(this.primaryColor, { h: 210, l: 150 }), this.cScale9 = this.cScale9 || ot(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || ot(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || ot(this.primaryColor, { h: 330 }), this.darkMode)
      for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
        this["cScale" + r] = Zt(this["cScale" + r], 75);
    else
      for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
        this["cScale" + r] = Zt(this["cScale" + r], 25);
    for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
      this["cScaleInv" + r] = this["cScaleInv" + r] || At(this["cScale" + r]);
    for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
      this.darkMode ? this["cScalePeer" + r] = this["cScalePeer" + r] || zt(this["cScale" + r], 10) : this["cScalePeer" + r] = this["cScalePeer" + r] || Zt(this["cScale" + r], 10);
    this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
    for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
      this["cScaleLabel" + r] = this["cScaleLabel" + r] || this.scaleLabelColor;
    const e = this.darkMode ? -4 : -1;
    for (let r = 0; r < 5; r++)
      this["surface" + r] = this["surface" + r] || ot(this.mainBkg, { h: 180, s: -15, l: e * (5 + r * 3) }), this["surfacePeer" + r] = this["surfacePeer" + r] || ot(this.mainBkg, { h: 180, s: -15, l: e * (8 + r * 3) });
    this.classText = this.classText || this.textColor, this.fillType0 = this.fillType0 || this.primaryColor, this.fillType1 = this.fillType1 || this.secondaryColor, this.fillType2 = this.fillType2 || ot(this.primaryColor, { h: 64 }), this.fillType3 = this.fillType3 || ot(this.secondaryColor, { h: 64 }), this.fillType4 = this.fillType4 || ot(this.primaryColor, { h: -64 }), this.fillType5 = this.fillType5 || ot(this.secondaryColor, { h: -64 }), this.fillType6 = this.fillType6 || ot(this.primaryColor, { h: 128 }), this.fillType7 = this.fillType7 || ot(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || ot(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || ot(this.secondaryColor, { l: -10 }), this.pie6 = this.pie6 || ot(this.tertiaryColor, { l: -10 }), this.pie7 = this.pie7 || ot(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || ot(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || ot(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || ot(this.primaryColor, { h: 60, l: -20 }), this.pie11 = this.pie11 || ot(this.primaryColor, { h: -60, l: -20 }), this.pie12 = this.pie12 || ot(this.primaryColor, { h: 120, l: -10 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOpacity = this.pieOpacity || "0.7", this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor, this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? Zt(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || ot(this.primaryColor, { h: -30 }), this.git4 = this.git4 || ot(this.primaryColor, { h: -60 }), this.git5 = this.git5 || ot(this.primaryColor, { h: -90 }), this.git6 = this.git6 || ot(this.primaryColor, { h: 60 }), this.git7 = this.git7 || ot(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = zt(this.git0, 25), this.git1 = zt(this.git1, 25), this.git2 = zt(this.git2, 25), this.git3 = zt(this.git3, 25), this.git4 = zt(this.git4, 25), this.git5 = zt(this.git5, 25), this.git6 = zt(this.git6, 25), this.git7 = zt(this.git7, 25)) : (this.git0 = Zt(this.git0, 25), this.git1 = Zt(this.git1, 25), this.git2 = Zt(this.git2, 25), this.git3 = Zt(this.git3, 25), this.git4 = Zt(this.git4, 25), this.git5 = Zt(this.git5, 25), this.git6 = Zt(this.git6, 25), this.git7 = Zt(this.git7, 25)), this.gitInv0 = this.gitInv0 || At(this.git0), this.gitInv1 = this.gitInv1 || At(this.git1), this.gitInv2 = this.gitInv2 || At(this.git2), this.gitInv3 = this.gitInv3 || At(this.git3), this.gitInv4 = this.gitInv4 || At(this.git4), this.gitInv5 = this.gitInv5 || At(this.git5), this.gitInv6 = this.gitInv6 || At(this.git6), this.gitInv7 = this.gitInv7 || At(this.git7), this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor, this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor, this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor, this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Ac, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Lc;
  }
  calculate(e) {
    if (typeof e != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(e);
    r.forEach((n) => {
      this[n] = e[n];
    }), this.updateColors(), r.forEach((n) => {
      this[n] = e[n];
    });
  }
};
const M8 = (t) => {
  const e = new I8();
  return e.calculate(t), e;
};
let N8 = class {
  constructor() {
    this.background = "#333", this.primaryColor = "#1f2020", this.secondaryColor = zt(this.primaryColor, 16), this.tertiaryColor = ot(this.primaryColor, { h: -160 }), this.primaryBorderColor = At(this.background), this.secondaryBorderColor = fr(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = fr(this.tertiaryColor, this.darkMode), this.primaryTextColor = At(this.primaryColor), this.secondaryTextColor = At(this.secondaryColor), this.tertiaryTextColor = At(this.tertiaryColor), this.lineColor = At(this.background), this.textColor = At(this.background), this.mainBkg = "#1f2020", this.secondBkg = "calculated", this.mainContrastColor = "lightgrey", this.darkTextColor = zt(At("#323D47"), 10), this.lineColor = "calculated", this.border1 = "#81B1DB", this.border2 = Ea(255, 255, 255, 0.25), this.arrowheadColor = "calculated", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "#181818", this.textColor = "#ccc", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#F9FFFE", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "calculated", this.activationBkgColor = "calculated", this.sequenceNumberColor = "black", this.sectionBkgColor = Zt("#EAE8D9", 30), this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "#EAE8D9", this.taskBorderColor = Ea(255, 255, 255, 70), this.taskBkgColor = "calculated", this.taskTextColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = Ea(255, 255, 255, 50), this.activeTaskBkgColor = "#81B1DB", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "grey", this.critBorderColor = "#E83737", this.critBkgColor = "#E83737", this.taskTextDarkColor = "calculated", this.todayLineColor = "#DB5757", this.personBorder = "calculated", this.personBkg = "calculated", this.labelColor = "calculated", this.errorBkgColor = "#a44141", this.errorTextColor = "#ddd";
  }
  updateColors() {
    this.secondBkg = zt(this.mainBkg, 16), this.lineColor = this.mainContrastColor, this.arrowheadColor = this.mainContrastColor, this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.edgeLabelBackground = zt(this.labelBackground, 25), this.actorBorder = this.border1, this.actorBkg = this.mainBkg, this.actorTextColor = this.mainContrastColor, this.actorLineColor = this.mainContrastColor, this.signalColor = this.mainContrastColor, this.signalTextColor = this.mainContrastColor, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.mainContrastColor, this.loopTextColor = this.mainContrastColor, this.noteBorderColor = this.secondaryBorderColor, this.noteBkgColor = this.secondBkg, this.noteTextColor = this.secondaryTextColor, this.activationBorderColor = this.border1, this.activationBkgColor = this.secondBkg, this.altSectionBkgColor = this.background, this.taskBkgColor = zt(this.mainBkg, 23), this.taskTextColor = this.darkTextColor, this.taskTextLightColor = this.mainContrastColor, this.taskTextOutsideColor = this.taskTextLightColor, this.gridColor = this.mainContrastColor, this.doneTaskBkgColor = this.mainContrastColor, this.taskTextDarkColor = this.darkTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#555", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#f4f4f4", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = ot(this.primaryColor, { h: 64 }), this.fillType3 = ot(this.secondaryColor, { h: 64 }), this.fillType4 = ot(this.primaryColor, { h: -64 }), this.fillType5 = ot(this.secondaryColor, { h: -64 }), this.fillType6 = ot(this.primaryColor, { h: 128 }), this.fillType7 = ot(this.secondaryColor, { h: 128 }), this.cScale1 = this.cScale1 || "#0b0000", this.cScale2 = this.cScale2 || "#4d1037", this.cScale3 = this.cScale3 || "#3f5258", this.cScale4 = this.cScale4 || "#4f2f1b", this.cScale5 = this.cScale5 || "#6e0a0a", this.cScale6 = this.cScale6 || "#3b0048", this.cScale7 = this.cScale7 || "#995a01", this.cScale8 = this.cScale8 || "#154706", this.cScale9 = this.cScale9 || "#161722", this.cScale10 = this.cScale10 || "#00296f", this.cScale11 = this.cScale11 || "#01629c", this.cScale12 = this.cScale12 || "#010029", this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || ot(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || ot(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || ot(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || ot(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || ot(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || ot(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || ot(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || ot(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || ot(this.primaryColor, { h: 330 });
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || At(this["cScale" + e]);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScalePeer" + e] = this["cScalePeer" + e] || zt(this["cScale" + e], 10);
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || ot(this.mainBkg, { h: 30, s: -30, l: -(-10 + e * 4) }), this["surfacePeer" + e] = this["surfacePeer" + e] || ot(this.mainBkg, { h: 30, s: -30, l: -(-7 + e * 4) });
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["pie" + e] = this["cScale" + e];
    this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOpacity = this.pieOpacity || "0.7", this.classText = this.primaryTextColor, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor, this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? Zt(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = zt(this.secondaryColor, 20), this.git1 = zt(this.pie2 || this.secondaryColor, 20), this.git2 = zt(this.pie3 || this.tertiaryColor, 20), this.git3 = zt(this.pie4 || ot(this.primaryColor, { h: -30 }), 20), this.git4 = zt(this.pie5 || ot(this.primaryColor, { h: -60 }), 20), this.git5 = zt(this.pie6 || ot(this.primaryColor, { h: -90 }), 10), this.git6 = zt(this.pie7 || ot(this.primaryColor, { h: 60 }), 10), this.git7 = zt(this.pie8 || ot(this.primaryColor, { h: 120 }), 20), this.gitInv0 = this.gitInv0 || At(this.git0), this.gitInv1 = this.gitInv1 || At(this.git1), this.gitInv2 = this.gitInv2 || At(this.git2), this.gitInv3 = this.gitInv3 || At(this.git3), this.gitInv4 = this.gitInv4 || At(this.git4), this.gitInv5 = this.gitInv5 || At(this.git5), this.gitInv6 = this.gitInv6 || At(this.git6), this.gitInv7 = this.gitInv7 || At(this.git7), this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || zt(this.background, 12), this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || zt(this.background, 2);
  }
  calculate(e) {
    if (typeof e != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(e);
    r.forEach((n) => {
      this[n] = e[n];
    }), this.updateColors(), r.forEach((n) => {
      this[n] = e[n];
    });
  }
};
const R8 = (t) => {
  const e = new N8();
  return e.calculate(t), e;
};
let F8 = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#ECECFF", this.secondaryColor = ot(this.primaryColor, { h: 120 }), this.secondaryColor = "#ffffde", this.tertiaryColor = ot(this.primaryColor, { h: -160 }), this.primaryBorderColor = fr(this.primaryColor, this.darkMode), this.secondaryBorderColor = fr(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = fr(this.tertiaryColor, this.darkMode), this.primaryTextColor = At(this.primaryColor), this.secondaryTextColor = At(this.secondaryColor), this.tertiaryTextColor = At(this.tertiaryColor), this.lineColor = At(this.background), this.textColor = At(this.background), this.background = "white", this.mainBkg = "#ECECFF", this.secondBkg = "#ffffde", this.lineColor = "#333333", this.border1 = "#9370DB", this.border2 = "#aaaa33", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.labelBackground = "#e8e8e8", this.textColor = "#333", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "grey", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = this.taskTextDarkColor, this.taskTextClickableColor = "calculated", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBorderColor = "calculated", this.critBkgColor = "calculated", this.todayLineColor = "calculated", this.sectionBkgColor = Ea(102, 102, 255, 0.49), this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#fff400", this.taskBorderColor = "#534fbc", this.taskBkgColor = "#8a90dd", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "#534fbc", this.activeTaskBkgColor = "#bfc7ff", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.personBorder = "calculated", this.personBkg = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222", this.updateColors();
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || ot(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || ot(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || ot(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || ot(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || ot(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || ot(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || ot(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || ot(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || ot(this.primaryColor, { h: 330 }), this["cScalePeer" + 1] = this["cScalePeer" + 1] || Zt(this.secondaryColor, 45), this["cScalePeer" + 2] = this["cScalePeer" + 2] || Zt(this.tertiaryColor, 40);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScale" + e] = Zt(this["cScale" + e], 10), this["cScalePeer" + e] = this["cScalePeer" + e] || Zt(this["cScale" + e], 25);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || ot(this["cScale" + e], { h: 180 });
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || ot(this.mainBkg, { h: 30, l: -(5 + e * 5) }), this["surfacePeer" + e] = this["surfacePeer" + e] || ot(this.mainBkg, { h: 30, l: -(7 + e * 5) });
    if (this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor, this.labelTextColor !== "calculated") {
      this.cScaleLabel0 = this.cScaleLabel0 || At(this.labelTextColor), this.cScaleLabel3 = this.cScaleLabel3 || At(this.labelTextColor);
      for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
        this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.labelTextColor;
    }
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.textColor, this.edgeLabelBackground = this.labelBackground, this.actorBorder = zt(this.border1, 23), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.signalColor = this.textColor, this.signalTextColor = this.textColor, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = ot(this.primaryColor, { h: 64 }), this.fillType3 = ot(this.secondaryColor, { h: 64 }), this.fillType4 = ot(this.primaryColor, { h: -64 }), this.fillType5 = ot(this.secondaryColor, { h: -64 }), this.fillType6 = ot(this.primaryColor, { h: 128 }), this.fillType7 = ot(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || ot(this.tertiaryColor, { l: -40 }), this.pie4 = this.pie4 || ot(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || ot(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || ot(this.tertiaryColor, { l: -20 }), this.pie7 = this.pie7 || ot(this.primaryColor, { h: 60, l: -20 }), this.pie8 = this.pie8 || ot(this.primaryColor, { h: -60, l: -40 }), this.pie9 = this.pie9 || ot(this.primaryColor, { h: 120, l: -40 }), this.pie10 = this.pie10 || ot(this.primaryColor, { h: 60, l: -40 }), this.pie11 = this.pie11 || ot(this.primaryColor, { h: -90, l: -40 }), this.pie12 = this.pie12 || ot(this.primaryColor, { h: 120, l: -30 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOpacity = this.pieOpacity || "0.7", this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor, this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.labelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || ot(this.primaryColor, { h: -30 }), this.git4 = this.git4 || ot(this.primaryColor, { h: -60 }), this.git5 = this.git5 || ot(this.primaryColor, { h: -90 }), this.git6 = this.git6 || ot(this.primaryColor, { h: 60 }), this.git7 = this.git7 || ot(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = zt(this.git0, 25), this.git1 = zt(this.git1, 25), this.git2 = zt(this.git2, 25), this.git3 = zt(this.git3, 25), this.git4 = zt(this.git4, 25), this.git5 = zt(this.git5, 25), this.git6 = zt(this.git6, 25), this.git7 = zt(this.git7, 25)) : (this.git0 = Zt(this.git0, 25), this.git1 = Zt(this.git1, 25), this.git2 = Zt(this.git2, 25), this.git3 = Zt(this.git3, 25), this.git4 = Zt(this.git4, 25), this.git5 = Zt(this.git5, 25), this.git6 = Zt(this.git6, 25), this.git7 = Zt(this.git7, 25)), this.gitInv0 = this.gitInv0 || Zt(At(this.git0), 25), this.gitInv1 = this.gitInv1 || At(this.git1), this.gitInv2 = this.gitInv2 || At(this.git2), this.gitInv3 = this.gitInv3 || At(this.git3), this.gitInv4 = this.gitInv4 || At(this.git4), this.gitInv5 = this.gitInv5 || At(this.git5), this.gitInv6 = this.gitInv6 || At(this.git6), this.gitInv7 = this.gitInv7 || At(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || At(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || At(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Ac, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Lc;
  }
  calculate(e) {
    if (typeof e != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(e);
    r.forEach((n) => {
      this[n] = e[n];
    }), this.updateColors(), r.forEach((n) => {
      this[n] = e[n];
    });
  }
};
const O8 = (t) => {
  const e = new F8();
  return e.calculate(t), e;
};
let P8 = class {
  constructor() {
    this.background = "#f4f4f4", this.primaryColor = "#cde498", this.secondaryColor = "#cdffb2", this.background = "white", this.mainBkg = "#cde498", this.secondBkg = "#cdffb2", this.lineColor = "green", this.border1 = "#13540c", this.border2 = "#6eaa49", this.arrowheadColor = "green", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.tertiaryColor = zt("#cde498", 10), this.primaryBorderColor = fr(this.primaryColor, this.darkMode), this.secondaryBorderColor = fr(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = fr(this.tertiaryColor, this.darkMode), this.primaryTextColor = At(this.primaryColor), this.secondaryTextColor = At(this.secondaryColor), this.tertiaryTextColor = At(this.primaryColor), this.lineColor = At(this.background), this.textColor = At(this.background), this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#333", this.edgeLabelBackground = "#e8e8e8", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "grey", this.signalColor = "#333", this.signalTextColor = "#333", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "#326932", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "#6eaa49", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#6eaa49", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "#487e3a", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.personBorder = "calculated", this.personBkg = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || ot(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || ot(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || ot(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || ot(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || ot(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || ot(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || ot(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || ot(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || ot(this.primaryColor, { h: 330 }), this["cScalePeer" + 1] = this["cScalePeer" + 1] || Zt(this.secondaryColor, 45), this["cScalePeer" + 2] = this["cScalePeer" + 2] || Zt(this.tertiaryColor, 40);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScale" + e] = Zt(this["cScale" + e], 10), this["cScalePeer" + e] = this["cScalePeer" + e] || Zt(this["cScale" + e], 25);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || ot(this["cScale" + e], { h: 180 });
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || ot(this.mainBkg, { h: 30, s: -30, l: -(5 + e * 5) }), this["surfacePeer" + e] = this["surfacePeer" + e] || ot(this.mainBkg, { h: 30, s: -30, l: -(8 + e * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.actorBorder = Zt(this.mainBkg, 20), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.taskBorderColor = this.border1, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = ot(this.primaryColor, { h: 64 }), this.fillType3 = ot(this.secondaryColor, { h: 64 }), this.fillType4 = ot(this.primaryColor, { h: -64 }), this.fillType5 = ot(this.secondaryColor, { h: -64 }), this.fillType6 = ot(this.primaryColor, { h: 128 }), this.fillType7 = ot(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || ot(this.primaryColor, { l: -30 }), this.pie5 = this.pie5 || ot(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || ot(this.tertiaryColor, { h: 40, l: -40 }), this.pie7 = this.pie7 || ot(this.primaryColor, { h: 60, l: -10 }), this.pie8 = this.pie8 || ot(this.primaryColor, { h: -60, l: -10 }), this.pie9 = this.pie9 || ot(this.primaryColor, { h: 120, l: 0 }), this.pie10 = this.pie10 || ot(this.primaryColor, { h: 60, l: -50 }), this.pie11 = this.pie11 || ot(this.primaryColor, { h: -60, l: -50 }), this.pie12 = this.pie12 || ot(this.primaryColor, { h: 120, l: -50 }), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOpacity = this.pieOpacity || "0.7", this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor, this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || ot(this.primaryColor, { h: -30 }), this.git4 = this.git4 || ot(this.primaryColor, { h: -60 }), this.git5 = this.git5 || ot(this.primaryColor, { h: -90 }), this.git6 = this.git6 || ot(this.primaryColor, { h: 60 }), this.git7 = this.git7 || ot(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = zt(this.git0, 25), this.git1 = zt(this.git1, 25), this.git2 = zt(this.git2, 25), this.git3 = zt(this.git3, 25), this.git4 = zt(this.git4, 25), this.git5 = zt(this.git5, 25), this.git6 = zt(this.git6, 25), this.git7 = zt(this.git7, 25)) : (this.git0 = Zt(this.git0, 25), this.git1 = Zt(this.git1, 25), this.git2 = Zt(this.git2, 25), this.git3 = Zt(this.git3, 25), this.git4 = Zt(this.git4, 25), this.git5 = Zt(this.git5, 25), this.git6 = Zt(this.git6, 25), this.git7 = Zt(this.git7, 25)), this.gitInv0 = this.gitInv0 || At(this.git0), this.gitInv1 = this.gitInv1 || At(this.git1), this.gitInv2 = this.gitInv2 || At(this.git2), this.gitInv3 = this.gitInv3 || At(this.git3), this.gitInv4 = this.gitInv4 || At(this.git4), this.gitInv5 = this.gitInv5 || At(this.git5), this.gitInv6 = this.gitInv6 || At(this.git6), this.gitInv7 = this.gitInv7 || At(this.git7), this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Ac, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Lc;
  }
  calculate(e) {
    if (typeof e != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(e);
    r.forEach((n) => {
      this[n] = e[n];
    }), this.updateColors(), r.forEach((n) => {
      this[n] = e[n];
    });
  }
};
const V8 = (t) => {
  const e = new P8();
  return e.calculate(t), e;
};
class Y8 {
  constructor() {
    this.primaryColor = "#eee", this.contrast = "#707070", this.secondaryColor = zt(this.contrast, 55), this.background = "#ffffff", this.tertiaryColor = ot(this.primaryColor, { h: -160 }), this.primaryBorderColor = fr(this.primaryColor, this.darkMode), this.secondaryBorderColor = fr(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = fr(this.tertiaryColor, this.darkMode), this.primaryTextColor = At(this.primaryColor), this.secondaryTextColor = At(this.secondaryColor), this.tertiaryTextColor = At(this.tertiaryColor), this.lineColor = At(this.background), this.textColor = At(this.background), this.mainBkg = "#eee", this.secondBkg = "calculated", this.lineColor = "#666", this.border1 = "#999", this.border2 = "calculated", this.note = "#ffa", this.text = "#333", this.critical = "#d42", this.done = "#bbb", this.arrowheadColor = "#333333", this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif', this.fontSize = "16px", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "white", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "calculated", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBkgColor = "calculated", this.critBorderColor = "calculated", this.todayLineColor = "calculated", this.personBorder = "calculated", this.personBkg = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
  }
  updateColors() {
    this.secondBkg = zt(this.contrast, 55), this.border2 = this.contrast, this.cScale0 = this.cScale0 || "#555", this.cScale1 = this.cScale1 || "#F4F4F4", this.cScale2 = this.cScale2 || "#555", this.cScale3 = this.cScale3 || "#BBB", this.cScale4 = this.cScale4 || "#777", this.cScale5 = this.cScale5 || "#999", this.cScale6 = this.cScale6 || "#DDD", this.cScale7 = this.cScale7 || "#FFF", this.cScale8 = this.cScale8 || "#DDD", this.cScale9 = this.cScale9 || "#BBB", this.cScale10 = this.cScale10 || "#999", this.cScale11 = this.cScale11 || "#777";
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleInv" + e] = this["cScaleInv" + e] || At(this["cScale" + e]);
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this.darkMode ? this["cScalePeer" + e] = this["cScalePeer" + e] || zt(this["cScale" + e], 10) : this["cScalePeer" + e] = this["cScalePeer" + e] || Zt(this["cScale" + e], 10);
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1, this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
    for (let e = 0; e < 5; e++)
      this["surface" + e] = this["surface" + e] || ot(this.mainBkg, { l: -(5 + e * 5) }), this["surfacePeer" + e] = this["surfacePeer" + e] || ot(this.mainBkg, { l: -(8 + e * 5) });
    this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.text, this.actorBorder = zt(this.border1, 23), this.actorBkg = this.mainBkg, this.actorTextColor = this.text, this.actorLineColor = this.lineColor, this.signalColor = this.text, this.signalTextColor = this.text, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.text, this.loopTextColor = this.text, this.noteBorderColor = "#999", this.noteBkgColor = "#666", this.noteTextColor = "#fff", this.sectionBkgColor = zt(this.contrast, 30), this.sectionBkgColor2 = zt(this.contrast, 30), this.taskBorderColor = Zt(this.contrast, 10), this.taskBkgColor = this.contrast, this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = this.text, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.gridColor = zt(this.border1, 30), this.doneTaskBkgColor = this.done, this.doneTaskBorderColor = this.lineColor, this.critBkgColor = this.critical, this.critBorderColor = Zt(this.critBkgColor, 10), this.todayLineColor = this.critBkgColor, this.transitionColor = this.transitionColor || "#000", this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f4f4f4", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.stateBorder = this.stateBorder || "#000", this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#222", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = ot(this.primaryColor, { h: 64 }), this.fillType3 = ot(this.secondaryColor, { h: 64 }), this.fillType4 = ot(this.primaryColor, { h: -64 }), this.fillType5 = ot(this.secondaryColor, { h: -64 }), this.fillType6 = ot(this.primaryColor, { h: 128 }), this.fillType7 = ot(this.secondaryColor, { h: 128 });
    for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
      this["pie" + e] = this["cScale" + e];
    this.pie12 = this.pie0, this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOpacity = this.pieOpacity || "0.7", this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor, this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = Zt(this.pie1, 25) || this.primaryColor, this.git1 = this.pie2 || this.secondaryColor, this.git2 = this.pie3 || this.tertiaryColor, this.git3 = this.pie4 || ot(this.primaryColor, { h: -30 }), this.git4 = this.pie5 || ot(this.primaryColor, { h: -60 }), this.git5 = this.pie6 || ot(this.primaryColor, { h: -90 }), this.git6 = this.pie7 || ot(this.primaryColor, { h: 60 }), this.git7 = this.pie8 || ot(this.primaryColor, { h: 120 }), this.gitInv0 = this.gitInv0 || At(this.git0), this.gitInv1 = this.gitInv1 || At(this.git1), this.gitInv2 = this.gitInv2 || At(this.git2), this.gitInv3 = this.gitInv3 || At(this.git3), this.gitInv4 = this.gitInv4 || At(this.git4), this.gitInv5 = this.gitInv5 || At(this.git5), this.gitInv6 = this.gitInv6 || At(this.git6), this.gitInv7 = this.gitInv7 || At(this.git7), this.branchLabelColor = this.branchLabelColor || this.labelTextColor, this.gitBranchLabel0 = this.branchLabelColor, this.gitBranchLabel1 = "white", this.gitBranchLabel2 = this.branchLabelColor, this.gitBranchLabel3 = "white", this.gitBranchLabel4 = this.branchLabelColor, this.gitBranchLabel5 = this.branchLabelColor, this.gitBranchLabel6 = this.branchLabelColor, this.gitBranchLabel7 = this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Ac, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Lc;
  }
  calculate(e) {
    if (typeof e != "object") {
      this.updateColors();
      return;
    }
    const r = Object.keys(e);
    r.forEach((n) => {
      this[n] = e[n];
    }), this.updateColors(), r.forEach((n) => {
      this[n] = e[n];
    });
  }
}
const z8 = (t) => {
  const e = new Y8();
  return e.calculate(t), e;
}, jn = {
  base: {
    getThemeVariables: M8
  },
  dark: {
    getThemeVariables: R8
  },
  default: {
    getThemeVariables: O8
  },
  forest: {
    getThemeVariables: V8
  },
  neutral: {
    getThemeVariables: z8
  }
}, ui = {
  /**
   * Theme , the CSS style sheet
   *
   * | Parameter | Description     | Type   | Required | Values                                         |
   * | --------- | --------------- | ------ | -------- | ---------------------------------------------- |
   * | theme     | Built in Themes | string | Optional | 'default', 'forest', 'dark', 'neutral', 'null' |
   *
   * **Notes:** To disable any pre-defined mermaid theme, use "null".
   *
   * @example
   *
   * ```js
   * {
   *   "theme": "forest",
   *   "themeCSS": ".node rect { fill: red; }"
   * }
   * ```
   */
  theme: "default",
  themeVariables: jn.default.getThemeVariables(),
  themeCSS: void 0,
  /* **maxTextSize** - The maximum allowed size of the users text diagram */
  maxTextSize: 5e4,
  darkMode: !1,
  /**
   * | Parameter  | Description                                            | Type   | Required | Values                      |
   * | ---------- | ------------------------------------------------------ | ------ | -------- | --------------------------- |
   * | fontFamily | specifies the font to be used in the rendered diagrams | string | Required | Any Possible CSS FontFamily |
   *
   * **Notes:** Default value: '"trebuchet ms", verdana, arial, sans-serif;'.
   */
  fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
  /**
   * | Parameter | Description                                           | Type             | Required | Values                                        |
   * | --------- | ----------------------------------------------------- | ---------------- | -------- | --------------------------------------------- |
   * | logLevel  | This option decides the amount of logging to be used. | string \| number | Required | 'trace','debug','info','warn','error','fatal' |
   *
   * **Notes:**
   *
   * - Trace: 0
   * - Debug: 1
   * - Info: 2
   * - Warn: 3
   * - Error: 4
   * - Fatal: 5 (default)
   */
  logLevel: 5,
  /**
   * | Parameter     | Description                       | Type   | Required | Values                                     |
   * | ------------- | --------------------------------- | ------ | -------- | ------------------------------------------ |
   * | securityLevel | Level of trust for parsed diagram | string | Required | 'sandbox', 'strict', 'loose', 'antiscript' |
   *
   * **Notes**:
   *
   * - **strict**: (**default**) tags in text are encoded, click functionality is disabled
   * - **loose**: tags in text are allowed, click functionality is enabled
   * - **antiscript**: html tags in text are allowed, (only script element is removed), click
   *   functionality is enabled
   * - **sandbox**: With this security level all rendering takes place in a sandboxed iframe. This
   *   prevent any JavaScript from running in the context. This may hinder interactive functionality
   *   of the diagram like scripts, popups in sequence diagram or links to other tabs/targets etc.
   */
  securityLevel: "strict",
  /**
   * | Parameter   | Description                                  | Type    | Required | Values      |
   * | ----------- | -------------------------------------------- | ------- | -------- | ----------- |
   * | startOnLoad | Dictates whether mermaid starts on Page load | boolean | Required | true, false |
   *
   * **Notes:** Default value: true
   */
  startOnLoad: !0,
  /**
   * | Parameter           | Description                                                                  | Type    | Required | Values      |
   * | ------------------- | ---------------------------------------------------------------------------- | ------- | -------- | ----------- |
   * | arrowMarkerAbsolute | Controls whether or arrow markers in html code are absolute paths or anchors | boolean | Required | true, false |
   *
   * **Notes**:
   *
   * This matters if you are using base tag settings.
   *
   * Default value: false
   */
  arrowMarkerAbsolute: !1,
  /**
   * This option controls which currentConfig keys are considered _secure_ and can only be changed
   * via call to mermaidAPI.initialize. Calls to mermaidAPI.reinitialize cannot make changes to the
   * `secure` keys in the current currentConfig. This prevents malicious graph directives from
   * overriding a site's default security.
   *
   * **Notes**:
   *
   * Default value: ['secure', 'securityLevel', 'startOnLoad', 'maxTextSize']
   */
  secure: ["secure", "securityLevel", "startOnLoad", "maxTextSize"],
  /**
   * This option controls if the generated ids of nodes in the SVG are generated randomly or based
   * on a seed. If set to false, the IDs are generated based on the current date and thus are not
   * deterministic. This is the default behavior.
   *
   * **Notes**:
   *
   * This matters if your files are checked into source control e.g. git and should not change unless
   * content is changed.
   *
   * Default value: false
   */
  deterministicIds: !1,
  /**
   * This option is the optional seed for deterministic ids. if set to undefined but
   * deterministicIds is true, a simple number iterator is used. You can set this attribute to base
   * the seed on a static string.
   */
  deterministicIDSeed: void 0,
  /** The object containing configurations specific for flowcharts */
  flowchart: {
    /**
     * ### titleTopMargin
     *
     * | Parameter      | Description                                    | Type    | Required | Values             |
     * | -------------- | ---------------------------------------------- | ------- | -------- | ------------------ |
     * | titleTopMargin | Margin top for the text over the flowchart     | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 25
     */
    titleTopMargin: 25,
    /**
     * | Parameter      | Description                                     | Type    | Required | Values             |
     * | -------------- | ----------------------------------------------- | ------- | -------- | ------------------ |
     * | diagramPadding | Amount of padding around the diagram as a whole | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     *
     * The amount of padding around the diagram as a whole so that embedded diagrams have margins,
     * expressed in pixels
     *
     * Default value: 8
     */
    diagramPadding: 8,
    /**
     * | Parameter  | Description                                                                                  | Type    | Required | Values      |
     * | ---------- | -------------------------------------------------------------------------------------------- | ------- | -------- | ----------- |
     * | htmlLabels | Flag for setting whether or not a html tag should be used for rendering labels on the edges. | boolean | Required | true, false |
     *
     * **Notes:** Default value: true.
     */
    htmlLabels: !0,
    /**
     * | Parameter   | Description                                         | Type    | Required | Values              |
     * | ----------- | --------------------------------------------------- | ------- | -------- | ------------------- |
     * | nodeSpacing | Defines the spacing between nodes on the same level | Integer | Required | Any positive Number |
     *
     * **Notes:**
     *
     * Pertains to horizontal spacing for TB (top to bottom) or BT (bottom to top) graphs, and the
     * vertical spacing for LR as well as RL graphs.**
     *
     * Default value: 50
     */
    nodeSpacing: 50,
    /**
     * | Parameter   | Description                                           | Type    | Required | Values              |
     * | ----------- | ----------------------------------------------------- | ------- | -------- | ------------------- |
     * | rankSpacing | Defines the spacing between nodes on different levels | Integer | Required | Any Positive Number |
     *
     * **Notes**:
     *
     * Pertains to vertical spacing for TB (top to bottom) or BT (bottom to top), and the horizontal
     * spacing for LR as well as RL graphs.
     *
     * Default value 50
     */
    rankSpacing: 50,
    /**
     * | Parameter | Description                                        | Type   | Required | Values                        |
     * | --------- | -------------------------------------------------- | ------ | -------- | ----------------------------- |
     * | curve     | Defines how mermaid renders curves for flowcharts. | string | Required | 'basis', 'linear', 'cardinal' |
     *
     * **Notes:**
     *
     * Default Value: 'basis'
     */
    curve: "basis",
    // Only used in new experimental rendering
    // represents the padding between the labels and the shape
    padding: 15,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See notes   | boolean | 4        | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: !0,
    /**
     * | Parameter       | Description | Type    | Required | Values                  |
     * | --------------- | ----------- | ------- | -------- | ----------------------- |
     * | defaultRenderer | See notes   | boolean | 4        | dagre-d3, dagre-wrapper, elk |
     *
     * **Notes:**
     *
     * Decides which rendering engine that is to be used for the rendering. Legal values are:
     * dagre-d3 dagre-wrapper - wrapper for dagre implemented in mermaid, elk for layout using
     * elkjs
     *
     * Default value: 'dagre-wrapper'
     */
    defaultRenderer: "dagre-wrapper"
  },
  /** The object containing configurations specific for sequence diagrams */
  sequence: {
    hideUnusedParticipants: !1,
    /**
     * | Parameter       | Description                  | Type    | Required | Values             |
     * | --------------- | ---------------------------- | ------- | -------- | ------------------ |
     * | activationWidth | Width of the activation rect | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value :10
     */
    activationWidth: 10,
    /**
     * | Parameter      | Description                                          | Type    | Required | Values             |
     * | -------------- | ---------------------------------------------------- | ------- | -------- | ------------------ |
     * | diagramMarginX | Margin to the right and left of the sequence diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 50
     */
    diagramMarginX: 50,
    /**
     * | Parameter      | Description                                       | Type    | Required | Values             |
     * | -------------- | ------------------------------------------------- | ------- | -------- | ------------------ |
     * | diagramMarginY | Margin to the over and under the sequence diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    diagramMarginY: 10,
    /**
     * | Parameter   | Description           | Type    | Required | Values             |
     * | ----------- | --------------------- | ------- | -------- | ------------------ |
     * | actorMargin | Margin between actors | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 50
     */
    actorMargin: 50,
    /**
     * | Parameter | Description          | Type    | Required | Values             |
     * | --------- | -------------------- | ------- | -------- | ------------------ |
     * | width     | Width of actor boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 150
     */
    width: 150,
    /**
     * | Parameter | Description           | Type    | Required | Values             |
     * | --------- | --------------------- | ------- | -------- | ------------------ |
     * | height    | Height of actor boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 65
     */
    height: 65,
    /**
     * | Parameter | Description              | Type    | Required | Values             |
     * | --------- | ------------------------ | ------- | -------- | ------------------ |
     * | boxMargin | Margin around loop boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    boxMargin: 10,
    /**
     * | Parameter     | Description                                  | Type    | Required | Values             |
     * | ------------- | -------------------------------------------- | ------- | -------- | ------------------ |
     * | boxTextMargin | Margin around the text in loop/alt/opt boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 5
     */
    boxTextMargin: 5,
    /**
     * | Parameter  | Description         | Type    | Required | Values             |
     * | ---------- | ------------------- | ------- | -------- | ------------------ |
     * | noteMargin | margin around notes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    noteMargin: 10,
    /**
     * | Parameter     | Description            | Type    | Required | Values             |
     * | ------------- | ---------------------- | ------- | -------- | ------------------ |
     * | messageMargin | Space between messages | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 35
     */
    messageMargin: 35,
    /**
     * | Parameter    | Description                 | Type   | Required | Values                    |
     * | ------------ | --------------------------- | ------ | -------- | ------------------------- |
     * | messageAlign | Multiline message alignment | string | Required | 'left', 'center', 'right' |
     *
     * **Notes:** Default value: 'center'
     */
    messageAlign: "center",
    /**
     * | Parameter    | Description                 | Type    | Required | Values      |
     * | ------------ | --------------------------- | ------- | -------- | ----------- |
     * | mirrorActors | Mirror actors under diagram | boolean | Required | true, false |
     *
     * **Notes:** Default value: true
     */
    mirrorActors: !0,
    /**
     * | Parameter  | Description                                                             | Type    | Required | Values      |
     * | ---------- | ----------------------------------------------------------------------- | ------- | -------- | ----------- |
     * | forceMenus | forces actor popup menus to always be visible (to support E2E testing). | Boolean | Required | True, False |
     *
     * **Notes:**
     *
     * Default value: false.
     */
    forceMenus: !1,
    /**
     * | Parameter       | Description                                | Type    | Required | Values             |
     * | --------------- | ------------------------------------------ | ------- | -------- | ------------------ |
     * | bottomMarginAdj | Prolongs the edge of the diagram downwards | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     *
     * Depending on css styling this might need adjustment.
     *
     * Default value: 1
     */
    bottomMarginAdj: 1,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See Notes   | boolean | Required | true, false |
     *
     * **Notes:** When this flag is set to true, the height and width is set to 100% and is then
     * scaling with the available space. If set to false, the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: !0,
    /**
     * | Parameter   | Description                          | Type    | Required | Values      |
     * | ----------- | ------------------------------------ | ------- | -------- | ----------- |
     * | rightAngles | display curve arrows as right angles | boolean | Required | true, false |
     *
     * **Notes:**
     *
     * This will display arrows that start and begin at the same node as right angles, rather than a
     * curve
     *
     * Default value: false
     */
    rightAngles: !1,
    /**
     * | Parameter           | Description                     | Type    | Required | Values      |
     * | ------------------- | ------------------------------- | ------- | -------- | ----------- |
     * | showSequenceNumbers | This will show the node numbers | boolean | Required | true, false |
     *
     * **Notes:** Default value: false
     */
    showSequenceNumbers: !1,
    /**
     * | Parameter     | Description                                        | Type    | Required | Values             |
     * | ------------- | -------------------------------------------------- | ------- | -------- | ------------------ |
     * | actorFontSize | This sets the font size of the actor's description | Integer | Require  | Any Positive Value |
     *
     * **Notes:** **Default value 14**..
     */
    actorFontSize: 14,
    /**
     * | Parameter       | Description                                          | Type   | Required | Values                      |
     * | --------------- | ---------------------------------------------------- | ------ | -------- | --------------------------- |
     * | actorFontFamily | This sets the font family of the actor's description | string | Required | Any Possible CSS FontFamily |
     *
     * **Notes:** Default value: "'Open Sans", sans-serif'
     */
    actorFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of the actor's description
     *
     * **Notes:** Default value: 400.
     */
    actorFontWeight: 400,
    /**
     * | Parameter    | Description                                     | Type    | Required | Values             |
     * | ------------ | ----------------------------------------------- | ------- | -------- | ------------------ |
     * | noteFontSize | This sets the font size of actor-attached notes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 14
     */
    noteFontSize: 14,
    /**
     * | Parameter      | Description                                        | Type   | Required | Values                      |
     * | -------------- | -------------------------------------------------- | ------ | -------- | --------------------------- |
     * | noteFontFamily | This sets the font family of actor-attached notes. | string | Required | Any Possible CSS FontFamily |
     *
     * **Notes:** Default value: ''"trebuchet ms", verdana, arial, sans-serif'
     */
    noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    /**
     * This sets the font weight of the note's description
     *
     * **Notes:** Default value: 400
     */
    noteFontWeight: 400,
    /**
     * | Parameter | Description                                          | Type   | Required | Values                    |
     * | --------- | ---------------------------------------------------- | ------ | -------- | ------------------------- |
     * | noteAlign | This sets the text alignment of actor-attached notes | string | required | 'left', 'center', 'right' |
     *
     * **Notes:** Default value: 'center'
     */
    noteAlign: "center",
    /**
     * | Parameter       | Description                               | Type    | Required | Values              |
     * | --------------- | ----------------------------------------- | ------- | -------- | ------------------- |
     * | messageFontSize | This sets the font size of actor messages | Integer | Required | Any Positive Number |
     *
     * **Notes:** Default value: 16
     */
    messageFontSize: 16,
    /**
     * | Parameter         | Description                                 | Type   | Required | Values                      |
     * | ----------------- | ------------------------------------------- | ------ | -------- | --------------------------- |
     * | messageFontFamily | This sets the font family of actor messages | string | Required | Any Possible CSS FontFamily |
     *
     * **Notes:** Default value: '"trebuchet ms", verdana, arial, sans-serif'
     */
    messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    /**
     * This sets the font weight of the message's description
     *
     * **Notes:** Default value: 400.
     */
    messageFontWeight: 400,
    /**
     * This sets the auto-wrap state for the diagram
     *
     * **Notes:** Default value: false.
     */
    wrap: !1,
    /**
     * This sets the auto-wrap padding for the diagram (sides only)
     *
     * **Notes:** Default value: 0.
     */
    wrapPadding: 10,
    /**
     * This sets the width of the loop-box (loop, alt, opt, par)
     *
     * **Notes:** Default value: 50.
     */
    labelBoxWidth: 50,
    /**
     * This sets the height of the loop-box (loop, alt, opt, par)
     *
     * **Notes:** Default value: 20.
     */
    labelBoxHeight: 20,
    messageFont: function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    },
    noteFont: function() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    },
    actorFont: function() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }
  },
  /** The object containing configurations specific for gantt diagrams */
  gantt: {
    /**
     * ### titleTopMargin
     *
     * | Parameter      | Description                                    | Type    | Required | Values             |
     * | -------------- | ---------------------------------------------- | ------- | -------- | ------------------ |
     * | titleTopMargin | Margin top for the text over the gantt diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 25
     */
    titleTopMargin: 25,
    /**
     * | Parameter | Description                         | Type    | Required | Values             |
     * | --------- | ----------------------------------- | ------- | -------- | ------------------ |
     * | barHeight | The height of the bars in the graph | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 20
     */
    barHeight: 20,
    /**
     * | Parameter | Description                                                      | Type    | Required | Values             |
     * | --------- | ---------------------------------------------------------------- | ------- | -------- | ------------------ |
     * | barGap    | The margin between the different activities in the gantt diagram | Integer | Optional | Any Positive Value |
     *
     * **Notes:** Default value: 4
     */
    barGap: 4,
    /**
     * | Parameter  | Description                                                                | Type    | Required | Values             |
     * | ---------- | -------------------------------------------------------------------------- | ------- | -------- | ------------------ |
     * | topPadding | Margin between title and gantt diagram and between axis and gantt diagram. | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 50
     */
    topPadding: 50,
    /**
     * | Parameter    | Description                                                             | Type    | Required | Values             |
     * | ------------ | ----------------------------------------------------------------------- | ------- | -------- | ------------------ |
     * | rightPadding | The space allocated for the section name to the right of the activities | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 75
     */
    rightPadding: 75,
    /**
     * | Parameter   | Description                                                            | Type    | Required | Values             |
     * | ----------- | ---------------------------------------------------------------------- | ------- | -------- | ------------------ |
     * | leftPadding | The space allocated for the section name to the left of the activities | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 75
     */
    leftPadding: 75,
    /**
     * | Parameter            | Description                                  | Type    | Required | Values             |
     * | -------------------- | -------------------------------------------- | ------- | -------- | ------------------ |
     * | gridLineStartPadding | Vertical starting position of the grid lines | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 35
     */
    gridLineStartPadding: 35,
    /**
     * | Parameter | Description | Type    | Required | Values             |
     * | --------- | ----------- | ------- | -------- | ------------------ |
     * | fontSize  | Font size   | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 11
     */
    fontSize: 11,
    /**
     * | Parameter       | Description            | Type    | Required | Values             |
     * | --------------- | ---------------------- | ------- | -------- | ------------------ |
     * | sectionFontSize | Font size for sections | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 11
     */
    sectionFontSize: 11,
    /**
     * | Parameter           | Description                              | Type    | Required | Values             |
     * | ------------------- | ---------------------------------------- | ------- | -------- | ------------------ |
     * | numberSectionStyles | The number of alternating section styles | Integer | 4        | Any Positive Value |
     *
     * **Notes:** Default value: 4
     */
    numberSectionStyles: 4,
    /**
     * | Parameter  | Description                  | Type | Required | Values           |
     * | ---------- | ---------------------------- | ---- | -------- | ---------------- |
     * | axisFormat | Date/time format of the axis | 3    | Required | Date in yy-mm-dd |
     *
     * **Notes:**
     *
     * This might need adjustment to match your locale and preferences
     *
     * Default value: '%Y-%m-%d'.
     */
    axisFormat: "%Y-%m-%d",
    /**
     * | Parameter    | Description | Type   | Required | Values  |
     * | ------------ | ------------| ------ | -------- | ------- |
     * | tickInterval | axis ticks  | string | Optional | string  |
     *
     * **Notes:**
     *
     * Pattern is /^([1-9][0-9]*)(minute|hour|day|week|month)$/
     *
     * Default value: undefined
     */
    tickInterval: void 0,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See notes   | boolean | 4        | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: !0,
    /**
     * | Parameter | Description | Type    | Required | Values      |
     * | --------- | ----------- | ------- | -------- | ----------- |
     * | topAxis   | See notes   | Boolean | 4        | True, False |
     *
     * **Notes:** when this flag is set date labels will be added to the top of the chart
     *
     * **Default value false**.
     */
    topAxis: !1,
    useWidth: void 0
  },
  /** The object containing configurations specific for journey diagrams */
  journey: {
    /**
     * | Parameter      | Description                                          | Type    | Required | Values             |
     * | -------------- | ---------------------------------------------------- | ------- | -------- | ------------------ |
     * | diagramMarginX | Margin to the right and left of the sequence diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 50
     */
    diagramMarginX: 50,
    /**
     * | Parameter      | Description                                        | Type    | Required | Values             |
     * | -------------- | -------------------------------------------------- | ------- | -------- | ------------------ |
     * | diagramMarginY | Margin to the over and under the sequence diagram. | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    diagramMarginY: 10,
    /**
     * | Parameter   | Description           | Type    | Required | Values             |
     * | ----------- | --------------------- | ------- | -------- | ------------------ |
     * | actorMargin | Margin between actors | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 50
     */
    leftMargin: 150,
    /**
     * | Parameter | Description          | Type    | Required | Values             |
     * | --------- | -------------------- | ------- | -------- | ------------------ |
     * | width     | Width of actor boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 150
     */
    width: 150,
    /**
     * | Parameter | Description           | Type    | Required | Values             |
     * | --------- | --------------------- | ------- | -------- | ------------------ |
     * | height    | Height of actor boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 65
     */
    height: 50,
    /**
     * | Parameter | Description              | Type    | Required | Values             |
     * | --------- | ------------------------ | ------- | -------- | ------------------ |
     * | boxMargin | Margin around loop boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    boxMargin: 10,
    /**
     * | Parameter     | Description                                  | Type    | Required | Values             |
     * | ------------- | -------------------------------------------- | ------- | -------- | ------------------ |
     * | boxTextMargin | Margin around the text in loop/alt/opt boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 5
     */
    boxTextMargin: 5,
    /**
     * | Parameter  | Description         | Type    | Required | Values             |
     * | ---------- | ------------------- | ------- | -------- | ------------------ |
     * | noteMargin | Margin around notes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    noteMargin: 10,
    /**
     * | Parameter     | Description             | Type    | Required | Values             |
     * | ------------- | ----------------------- | ------- | -------- | ------------------ |
     * | messageMargin | Space between messages. | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     *
     * Space between messages.
     *
     * Default value: 35
     */
    messageMargin: 35,
    /**
     * | Parameter    | Description                 | Type | Required | Values                    |
     * | ------------ | --------------------------- | ---- | -------- | ------------------------- |
     * | messageAlign | Multiline message alignment | 3    | 4        | 'left', 'center', 'right' |
     *
     * **Notes:** Default value: 'center'
     */
    messageAlign: "center",
    /**
     * | Parameter       | Description                                | Type    | Required | Values             |
     * | --------------- | ------------------------------------------ | ------- | -------- | ------------------ |
     * | bottomMarginAdj | Prolongs the edge of the diagram downwards | Integer | 4        | Any Positive Value |
     *
     * **Notes:**
     *
     * Depending on css styling this might need adjustment.
     *
     * Default value: 1
     */
    bottomMarginAdj: 1,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See notes   | boolean | 4        | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: !0,
    /**
     * | Parameter   | Description                       | Type | Required | Values      |
     * | ----------- | --------------------------------- | ---- | -------- | ----------- |
     * | rightAngles | Curved Arrows become Right Angles | 3    | 4        | true, false |
     *
     * **Notes:**
     *
     * This will display arrows that start and begin at the same node as right angles, rather than a
     * curves
     *
     * Default value: false
     */
    rightAngles: !1,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    // width of activation box
    activationWidth: 10,
    // text placement as: tspan | fo | old only text as before
    textPlacement: "fo",
    actorColours: ["#8FBC8F", "#7CFC00", "#00FFFF", "#20B2AA", "#B0E0E6", "#FFFFE0"],
    sectionFills: ["#191970", "#8B008B", "#4B0082", "#2F4F4F", "#800000", "#8B4513", "#00008B"],
    sectionColours: ["#fff"]
  },
  /** The object containing configurations specific for timeline diagrams */
  timeline: {
    /**
     * | Parameter      | Description                                          | Type    | Required | Values             |
     * | -------------- | ---------------------------------------------------- | ------- | -------- | ------------------ |
     * | diagramMarginX | Margin to the right and left of the sequence diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 50
     */
    diagramMarginX: 50,
    /**
     * | Parameter      | Description                                        | Type    | Required | Values             |
     * | -------------- | -------------------------------------------------- | ------- | -------- | ------------------ |
     * | diagramMarginY | Margin to the over and under the sequence diagram. | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    diagramMarginY: 10,
    /**
     * | Parameter   | Description           | Type    | Required | Values             |
     * | ----------- | --------------------- | ------- | -------- | ------------------ |
     * | actorMargin | Margin between actors | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 50
     */
    leftMargin: 150,
    /**
     * | Parameter | Description          | Type    | Required | Values             |
     * | --------- | -------------------- | ------- | -------- | ------------------ |
     * | width     | Width of actor boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 150
     */
    width: 150,
    /**
     * | Parameter | Description           | Type    | Required | Values             |
     * | --------- | --------------------- | ------- | -------- | ------------------ |
     * | height    | Height of actor boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 65
     */
    height: 50,
    /**
     * | Parameter | Description              | Type    | Required | Values             |
     * | --------- | ------------------------ | ------- | -------- | ------------------ |
     * | boxMargin | Margin around loop boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    boxMargin: 10,
    /**
     * | Parameter     | Description                                  | Type    | Required | Values             |
     * | ------------- | -------------------------------------------- | ------- | -------- | ------------------ |
     * | boxTextMargin | Margin around the text in loop/alt/opt boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 5
     */
    boxTextMargin: 5,
    /**
     * | Parameter  | Description         | Type    | Required | Values             |
     * | ---------- | ------------------- | ------- | -------- | ------------------ |
     * | noteMargin | Margin around notes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    noteMargin: 10,
    /**
     * | Parameter     | Description             | Type    | Required | Values             |
     * | ------------- | ----------------------- | ------- | -------- | ------------------ |
     * | messageMargin | Space between messages. | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     *
     * Space between messages.
     *
     * Default value: 35
     */
    messageMargin: 35,
    /**
     * | Parameter    | Description                 | Type | Required | Values                    |
     * | ------------ | --------------------------- | ---- | -------- | ------------------------- |
     * | messageAlign | Multiline message alignment | 3    | 4        | 'left', 'center', 'right' |
     *
     * **Notes:** Default value: 'center'
     */
    messageAlign: "center",
    /**
     * | Parameter       | Description                                | Type    | Required | Values             |
     * | --------------- | ------------------------------------------ | ------- | -------- | ------------------ |
     * | bottomMarginAdj | Prolongs the edge of the diagram downwards | Integer | 4        | Any Positive Value |
     *
     * **Notes:**
     *
     * Depending on css styling this might need adjustment.
     *
     * Default value: 1
     */
    bottomMarginAdj: 1,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See notes   | boolean | 4        | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: !0,
    /**
     * | Parameter   | Description                       | Type | Required | Values      |
     * | ----------- | --------------------------------- | ---- | -------- | ----------- |
     * | rightAngles | Curved Arrows become Right Angles | 3    | 4        | true, false |
     *
     * **Notes:**
     *
     * This will display arrows that start and begin at the same node as right angles, rather than a
     * curves
     *
     * Default value: false
     */
    rightAngles: !1,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    // width of activation box
    activationWidth: 10,
    // text placement as: tspan | fo | old only text as before
    textPlacement: "fo",
    actorColours: ["#8FBC8F", "#7CFC00", "#00FFFF", "#20B2AA", "#B0E0E6", "#FFFFE0"],
    sectionFills: ["#191970", "#8B008B", "#4B0082", "#2F4F4F", "#800000", "#8B4513", "#00008B"],
    sectionColours: ["#fff"],
    disableMulticolor: !1
  },
  class: {
    /**
     * ### titleTopMargin
     *
     * | Parameter      | Description                                    | Type    | Required | Values             |
     * | -------------- | ---------------------------------------------- | ------- | -------- | ------------------ |
     * | titleTopMargin | Margin top for the text over the class diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 25
     */
    titleTopMargin: 25,
    arrowMarkerAbsolute: !1,
    dividerMargin: 10,
    padding: 5,
    textHeight: 10,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See notes   | boolean | 4        | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: !0,
    /**
     * | Parameter       | Description | Type    | Required | Values                  |
     * | --------------- | ----------- | ------- | -------- | ----------------------- |
     * | defaultRenderer | See notes   | boolean | 4        | dagre-d3, dagre-wrapper |
     *
     * **Notes**:
     *
     * Decides which rendering engine that is to be used for the rendering. Legal values are:
     * dagre-d3 dagre-wrapper - wrapper for dagre implemented in mermaid
     *
     * Default value: 'dagre-d3'
     */
    defaultRenderer: "dagre-wrapper"
  },
  state: {
    /**
     * ### titleTopMargin
     *
     * | Parameter      | Description                                    | Type    | Required | Values             |
     * | -------------- | ---------------------------------------------- | ------- | -------- | ------------------ |
     * | titleTopMargin | Margin top for the text over the state diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 25
     */
    titleTopMargin: 25,
    dividerMargin: 10,
    sizeUnit: 5,
    padding: 8,
    textHeight: 10,
    titleShift: -15,
    noteMargin: 10,
    forkWidth: 70,
    forkHeight: 7,
    // Used
    miniPadding: 2,
    // Font size factor, this is used to guess the width of the edges labels before rendering by dagre
    // layout. This might need updating if/when switching font
    fontSizeFactor: 5.02,
    fontSize: 24,
    labelHeight: 16,
    edgeLengthFactor: "20",
    compositTitleSize: 35,
    radius: 5,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See notes   | boolean | 4        | true, false |
     *
     * **Notes:**
     *
     * When this flag is set the height and width is set to 100% and is then scaling with the
     * available space if not the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: !0,
    /**
     * | Parameter       | Description | Type    | Required | Values                  |
     * | --------------- | ----------- | ------- | -------- | ----------------------- |
     * | defaultRenderer | See notes   | boolean | 4        | dagre-d3, dagre-wrapper |
     *
     * **Notes:**
     *
     * Decides which rendering engine that is to be used for the rendering. Legal values are:
     * dagre-d3 dagre-wrapper - wrapper for dagre implemented in mermaid
     *
     * Default value: 'dagre-d3'
     */
    defaultRenderer: "dagre-wrapper"
  },
  /** The object containing configurations specific for entity relationship diagrams */
  er: {
    /**
     * ### titleTopMargin
     *
     * | Parameter      | Description                                    | Type    | Required | Values             |
     * | -------------- | ---------------------------------------------- | ------- | -------- | ------------------ |
     * | titleTopMargin | Margin top for the text over the diagram       | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 25
     */
    titleTopMargin: 25,
    /**
     * | Parameter      | Description                                     | Type    | Required | Values             |
     * | -------------- | ----------------------------------------------- | ------- | -------- | ------------------ |
     * | diagramPadding | Amount of padding around the diagram as a whole | Integer | Required | Any Positive Value |
     *
     * **Notes:**
     *
     * The amount of padding around the diagram as a whole so that embedded diagrams have margins,
     * expressed in pixels
     *
     * Default value: 20
     */
    diagramPadding: 20,
    /**
     * | Parameter       | Description                              | Type   | Required | Values                 |
     * | --------------- | ---------------------------------------- | ------ | -------- | ---------------------- |
     * | layoutDirection | Directional bias for layout of entities. | string | Required | "TB", "BT", "LR", "RL" |
     *
     * **Notes:**
     *
     * 'TB' for Top-Bottom, 'BT'for Bottom-Top, 'LR' for Left-Right, or 'RL' for Right to Left.
     *
     * T = top, B = bottom, L = left, and R = right.
     *
     * Default value: 'TB'
     */
    layoutDirection: "TB",
    /**
     * | Parameter      | Description                        | Type    | Required | Values             |
     * | -------------- | ---------------------------------- | ------- | -------- | ------------------ |
     * | minEntityWidth | The minimum width of an entity box | Integer | Required | Any Positive Value |
     *
     * **Notes:** Expressed in pixels. Default value: 100
     */
    minEntityWidth: 100,
    /**
     * | Parameter       | Description                         | Type    | Required | Values             |
     * | --------------- | ----------------------------------- | ------- | -------- | ------------------ |
     * | minEntityHeight | The minimum height of an entity box | Integer | 4        | Any Positive Value |
     *
     * **Notes:** Expressed in pixels Default value: 75
     */
    minEntityHeight: 75,
    /**
     * | Parameter     | Description                                                  | Type    | Required | Values             |
     * | ------------- | ------------------------------------------------------------ | ------- | -------- | ------------------ |
     * | entityPadding | Minimum internal padding between text in box and box borders | Integer | 4        | Any Positive Value |
     *
     * **Notes:**
     *
     * The minimum internal padding between text in an entity box and the enclosing box borders,
     * expressed in pixels.
     *
     * Default value: 15
     */
    entityPadding: 15,
    /**
     * | Parameter | Description                         | Type   | Required | Values               |
     * | --------- | ----------------------------------- | ------ | -------- | -------------------- |
     * | stroke    | Stroke color of box edges and lines | string | 4        | Any recognized color |
     *
     * **Notes:** Default value: 'gray'
     */
    stroke: "gray",
    /**
     * | Parameter | Description                | Type   | Required | Values               |
     * | --------- | -------------------------- | ------ | -------- | -------------------- |
     * | fill      | Fill color of entity boxes | string | 4        | Any recognized color |
     *
     * **Notes:** Default value: 'honeydew'
     */
    fill: "honeydew",
    /**
     * | Parameter | Description         | Type    | Required | Values             |
     * | --------- | ------------------- | ------- | -------- | ------------------ |
     * | fontSize  | Font Size in pixels | Integer |          | Any Positive Value |
     *
     * **Notes:**
     *
     * Font size (expressed as an integer representing a number of pixels) Default value: 12
     */
    fontSize: 12,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See Notes   | boolean | Required | true, false |
     *
     * **Notes:**
     *
     * When this flag is set to true, the diagram width is locked to 100% and scaled based on
     * available space. If set to false, the diagram reserves its absolute width.
     *
     * Default value: true
     */
    useMaxWidth: !0
  },
  /** The object containing configurations specific for pie diagrams */
  pie: {
    useWidth: void 0,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See Notes   | boolean | Required | true, false |
     *
     * **Notes:**
     *
     * When this flag is set to true, the diagram width is locked to 100% and scaled based on
     * available space. If set to false, the diagram reserves its absolute width.
     *
     * Default value: true
     */
    useMaxWidth: !0
  },
  /** The object containing configurations specific for req diagrams */
  requirement: {
    useWidth: void 0,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See Notes   | boolean | Required | true, false |
     *
     * **Notes:**
     *
     * When this flag is set to true, the diagram width is locked to 100% and scaled based on
     * available space. If set to false, the diagram reserves its absolute width.
     *
     * Default value: true
     */
    useMaxWidth: !0,
    rect_fill: "#f9f9f9",
    text_color: "#333",
    rect_border_size: "0.5px",
    rect_border_color: "#bbb",
    rect_min_width: 200,
    rect_min_height: 200,
    fontSize: 14,
    rect_padding: 10,
    line_height: 20
  },
  gitGraph: {
    /**
     * ### titleTopMargin
     *
     * | Parameter      | Description                                    | Type    | Required | Values             |
     * | -------------- | ---------------------------------------------- | ------- | -------- | ------------------ |
     * | titleTopMargin | Margin top for the text over the Git diagram   | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 25
     */
    titleTopMargin: 25,
    diagramPadding: 8,
    nodeLabel: {
      width: 75,
      height: 100,
      x: -25,
      y: 0
    },
    mainBranchName: "main",
    mainBranchOrder: 0,
    showCommitLabel: !0,
    showBranches: !0,
    rotateCommitLabel: !0
  },
  /** The object containing configurations specific for c4 diagrams */
  c4: {
    useWidth: void 0,
    /**
     * | Parameter      | Description                                    | Type    | Required | Values             |
     * | -------------- | ---------------------------------------------- | ------- | -------- | ------------------ |
     * | diagramMarginX | Margin to the right and left of the c4 diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 50
     */
    diagramMarginX: 50,
    /**
     * | Parameter      | Description                                 | Type    | Required | Values             |
     * | -------------- | ------------------------------------------- | ------- | -------- | ------------------ |
     * | diagramMarginY | Margin to the over and under the c4 diagram | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    diagramMarginY: 10,
    /**
     * | Parameter     | Description           | Type    | Required | Values             |
     * | ------------- | --------------------- | ------- | -------- | ------------------ |
     * | c4ShapeMargin | Margin between shapes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 50
     */
    c4ShapeMargin: 50,
    /**
     * | Parameter      | Description            | Type    | Required | Values             |
     * | -------------- | ---------------------- | ------- | -------- | ------------------ |
     * | c4ShapePadding | Padding between shapes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 20
     */
    c4ShapePadding: 20,
    /**
     * | Parameter | Description           | Type    | Required | Values             |
     * | --------- | --------------------- | ------- | -------- | ------------------ |
     * | width     | Width of person boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 216
     */
    width: 216,
    /**
     * | Parameter | Description            | Type    | Required | Values             |
     * | --------- | ---------------------- | ------- | -------- | ------------------ |
     * | height    | Height of person boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 60
     */
    height: 60,
    /**
     * | Parameter | Description         | Type    | Required | Values             |
     * | --------- | ------------------- | ------- | -------- | ------------------ |
     * | boxMargin | Margin around boxes | Integer | Required | Any Positive Value |
     *
     * **Notes:** Default value: 10
     */
    boxMargin: 10,
    /**
     * | Parameter   | Description | Type    | Required | Values      |
     * | ----------- | ----------- | ------- | -------- | ----------- |
     * | useMaxWidth | See Notes   | boolean | Required | true, false |
     *
     * **Notes:** When this flag is set to true, the height and width is set to 100% and is then
     * scaling with the available space. If set to false, the absolute space required is used.
     *
     * Default value: true
     */
    useMaxWidth: !0,
    /**
     * | Parameter    | Description | Type    | Required | Values             |
     * | ------------ | ----------- | ------- | -------- | ------------------ |
     * | c4ShapeInRow | See Notes   | Integer | Required | Any Positive Value |
     *
     * **Notes:** How many shapes to place in each row.
     *
     * Default value: 4
     */
    c4ShapeInRow: 4,
    nextLinePaddingX: 0,
    /**
     * | Parameter       | Description | Type    | Required | Values             |
     * | --------------- | ----------- | ------- | -------- | ------------------ |
     * | c4BoundaryInRow | See Notes   | Integer | Required | Any Positive Value |
     *
     * **Notes:** How many boundaries to place in each row.
     *
     * Default value: 2
     */
    c4BoundaryInRow: 2,
    /**
     * This sets the font size of Person shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    personFontSize: 14,
    /**
     * This sets the font family of Person shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    personFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of Person shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    personFontWeight: "normal",
    /**
     * This sets the font size of External Person shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    external_personFontSize: 14,
    /**
     * This sets the font family of External Person shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    external_personFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of External Person shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    external_personFontWeight: "normal",
    /**
     * This sets the font size of System shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    systemFontSize: 14,
    /**
     * This sets the font family of System shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    systemFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of System shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    systemFontWeight: "normal",
    /**
     * This sets the font size of External System shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    external_systemFontSize: 14,
    /**
     * This sets the font family of External System shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    external_systemFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of External System shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    external_systemFontWeight: "normal",
    /**
     * This sets the font size of System DB shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    system_dbFontSize: 14,
    /**
     * This sets the font family of System DB shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    system_dbFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of System DB shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    system_dbFontWeight: "normal",
    /**
     * This sets the font size of External System DB shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    external_system_dbFontSize: 14,
    /**
     * This sets the font family of External System DB shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    external_system_dbFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of External System DB shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    external_system_dbFontWeight: "normal",
    /**
     * This sets the font size of System Queue shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    system_queueFontSize: 14,
    /**
     * This sets the font family of System Queue shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    system_queueFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of System Queue shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    system_queueFontWeight: "normal",
    /**
     * This sets the font size of External System Queue shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    external_system_queueFontSize: 14,
    /**
     * This sets the font family of External System Queue shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    external_system_queueFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of External System Queue shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    external_system_queueFontWeight: "normal",
    /**
     * This sets the font size of Boundary shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    boundaryFontSize: 14,
    /**
     * This sets the font family of Boundary shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    boundaryFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of Boundary shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    boundaryFontWeight: "normal",
    /**
     * This sets the font size of Message shape for the diagram
     *
     * **Notes:** Default value: 12.
     */
    messageFontSize: 12,
    /**
     * This sets the font family of Message shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    messageFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of Message shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    messageFontWeight: "normal",
    /**
     * This sets the font size of Container shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    containerFontSize: 14,
    /**
     * This sets the font family of Container shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    containerFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of Container shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    containerFontWeight: "normal",
    /**
     * This sets the font size of External Container shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    external_containerFontSize: 14,
    /**
     * This sets the font family of External Container shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    external_containerFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of External Container shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    external_containerFontWeight: "normal",
    /**
     * This sets the font size of Container DB shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    container_dbFontSize: 14,
    /**
     * This sets the font family of Container DB shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    container_dbFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of Container DB shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    container_dbFontWeight: "normal",
    /**
     * This sets the font size of External Container DB shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    external_container_dbFontSize: 14,
    /**
     * This sets the font family of External Container DB shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    external_container_dbFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of External Container DB shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    external_container_dbFontWeight: "normal",
    /**
     * This sets the font size of Container Queue shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    container_queueFontSize: 14,
    /**
     * This sets the font family of Container Queue shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    container_queueFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of Container Queue shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    container_queueFontWeight: "normal",
    /**
     * This sets the font size of External Container Queue shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    external_container_queueFontSize: 14,
    /**
     * This sets the font family of External Container Queue shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    external_container_queueFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of External Container Queue shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    external_container_queueFontWeight: "normal",
    /**
     * This sets the font size of Component shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    componentFontSize: 14,
    /**
     * This sets the font family of Component shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    componentFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of Component shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    componentFontWeight: "normal",
    /**
     * This sets the font size of External Component shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    external_componentFontSize: 14,
    /**
     * This sets the font family of External Component shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    external_componentFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of External Component shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    external_componentFontWeight: "normal",
    /**
     * This sets the font size of Component DB shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    component_dbFontSize: 14,
    /**
     * This sets the font family of Component DB shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    component_dbFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of Component DB shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    component_dbFontWeight: "normal",
    /**
     * This sets the font size of External Component DB shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    external_component_dbFontSize: 14,
    /**
     * This sets the font family of External Component DB shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    external_component_dbFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of External Component DB shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    external_component_dbFontWeight: "normal",
    /**
     * This sets the font size of Component Queue shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    component_queueFontSize: 14,
    /**
     * This sets the font family of Component Queue shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    component_queueFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of Component Queue shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    component_queueFontWeight: "normal",
    /**
     * This sets the font size of External Component Queue shape for the diagram
     *
     * **Notes:** Default value: 14.
     */
    external_component_queueFontSize: 14,
    /**
     * This sets the font family of External Component Queue shape for the diagram
     *
     * **Notes:** Default value: "Open Sans", sans-serif.
     */
    external_component_queueFontFamily: '"Open Sans", sans-serif',
    /**
     * This sets the font weight of External Component Queue shape for the diagram
     *
     * **Notes:** Default value: normal.
     */
    external_component_queueFontWeight: "normal",
    /**
     * This sets the auto-wrap state for the diagram
     *
     * **Notes:** Default value: true.
     */
    wrap: !0,
    /**
     * This sets the auto-wrap padding for the diagram (sides only)
     *
     * **Notes:** Default value: 0.
     */
    wrapPadding: 10,
    personFont: function() {
      return {
        fontFamily: this.personFontFamily,
        fontSize: this.personFontSize,
        fontWeight: this.personFontWeight
      };
    },
    external_personFont: function() {
      return {
        fontFamily: this.external_personFontFamily,
        fontSize: this.external_personFontSize,
        fontWeight: this.external_personFontWeight
      };
    },
    systemFont: function() {
      return {
        fontFamily: this.systemFontFamily,
        fontSize: this.systemFontSize,
        fontWeight: this.systemFontWeight
      };
    },
    external_systemFont: function() {
      return {
        fontFamily: this.external_systemFontFamily,
        fontSize: this.external_systemFontSize,
        fontWeight: this.external_systemFontWeight
      };
    },
    system_dbFont: function() {
      return {
        fontFamily: this.system_dbFontFamily,
        fontSize: this.system_dbFontSize,
        fontWeight: this.system_dbFontWeight
      };
    },
    external_system_dbFont: function() {
      return {
        fontFamily: this.external_system_dbFontFamily,
        fontSize: this.external_system_dbFontSize,
        fontWeight: this.external_system_dbFontWeight
      };
    },
    system_queueFont: function() {
      return {
        fontFamily: this.system_queueFontFamily,
        fontSize: this.system_queueFontSize,
        fontWeight: this.system_queueFontWeight
      };
    },
    external_system_queueFont: function() {
      return {
        fontFamily: this.external_system_queueFontFamily,
        fontSize: this.external_system_queueFontSize,
        fontWeight: this.external_system_queueFontWeight
      };
    },
    containerFont: function() {
      return {
        fontFamily: this.containerFontFamily,
        fontSize: this.containerFontSize,
        fontWeight: this.containerFontWeight
      };
    },
    external_containerFont: function() {
      return {
        fontFamily: this.external_containerFontFamily,
        fontSize: this.external_containerFontSize,
        fontWeight: this.external_containerFontWeight
      };
    },
    container_dbFont: function() {
      return {
        fontFamily: this.container_dbFontFamily,
        fontSize: this.container_dbFontSize,
        fontWeight: this.container_dbFontWeight
      };
    },
    external_container_dbFont: function() {
      return {
        fontFamily: this.external_container_dbFontFamily,
        fontSize: this.external_container_dbFontSize,
        fontWeight: this.external_container_dbFontWeight
      };
    },
    container_queueFont: function() {
      return {
        fontFamily: this.container_queueFontFamily,
        fontSize: this.container_queueFontSize,
        fontWeight: this.container_queueFontWeight
      };
    },
    external_container_queueFont: function() {
      return {
        fontFamily: this.external_container_queueFontFamily,
        fontSize: this.external_container_queueFontSize,
        fontWeight: this.external_container_queueFontWeight
      };
    },
    componentFont: function() {
      return {
        fontFamily: this.componentFontFamily,
        fontSize: this.componentFontSize,
        fontWeight: this.componentFontWeight
      };
    },
    external_componentFont: function() {
      return {
        fontFamily: this.external_componentFontFamily,
        fontSize: this.external_componentFontSize,
        fontWeight: this.external_componentFontWeight
      };
    },
    component_dbFont: function() {
      return {
        fontFamily: this.component_dbFontFamily,
        fontSize: this.component_dbFontSize,
        fontWeight: this.component_dbFontWeight
      };
    },
    external_component_dbFont: function() {
      return {
        fontFamily: this.external_component_dbFontFamily,
        fontSize: this.external_component_dbFontSize,
        fontWeight: this.external_component_dbFontWeight
      };
    },
    component_queueFont: function() {
      return {
        fontFamily: this.component_queueFontFamily,
        fontSize: this.component_queueFontSize,
        fontWeight: this.component_queueFontWeight
      };
    },
    external_component_queueFont: function() {
      return {
        fontFamily: this.external_component_queueFontFamily,
        fontSize: this.external_component_queueFontSize,
        fontWeight: this.external_component_queueFontWeight
      };
    },
    boundaryFont: function() {
      return {
        fontFamily: this.boundaryFontFamily,
        fontSize: this.boundaryFontSize,
        fontWeight: this.boundaryFontWeight
      };
    },
    messageFont: function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    },
    // ' Colors
    // ' ##################################
    person_bg_color: "#08427B",
    person_border_color: "#073B6F",
    external_person_bg_color: "#686868",
    external_person_border_color: "#8A8A8A",
    system_bg_color: "#1168BD",
    system_border_color: "#3C7FC0",
    system_db_bg_color: "#1168BD",
    system_db_border_color: "#3C7FC0",
    system_queue_bg_color: "#1168BD",
    system_queue_border_color: "#3C7FC0",
    external_system_bg_color: "#999999",
    external_system_border_color: "#8A8A8A",
    external_system_db_bg_color: "#999999",
    external_system_db_border_color: "#8A8A8A",
    external_system_queue_bg_color: "#999999",
    external_system_queue_border_color: "#8A8A8A",
    container_bg_color: "#438DD5",
    container_border_color: "#3C7FC0",
    container_db_bg_color: "#438DD5",
    container_db_border_color: "#3C7FC0",
    container_queue_bg_color: "#438DD5",
    container_queue_border_color: "#3C7FC0",
    external_container_bg_color: "#B3B3B3",
    external_container_border_color: "#A6A6A6",
    external_container_db_bg_color: "#B3B3B3",
    external_container_db_border_color: "#A6A6A6",
    external_container_queue_bg_color: "#B3B3B3",
    external_container_queue_border_color: "#A6A6A6",
    component_bg_color: "#85BBF0",
    component_border_color: "#78A8D8",
    component_db_bg_color: "#85BBF0",
    component_db_border_color: "#78A8D8",
    component_queue_bg_color: "#85BBF0",
    component_queue_border_color: "#78A8D8",
    external_component_bg_color: "#CCCCCC",
    external_component_border_color: "#BFBFBF",
    external_component_db_bg_color: "#CCCCCC",
    external_component_db_border_color: "#BFBFBF",
    external_component_queue_bg_color: "#CCCCCC",
    external_component_queue_border_color: "#BFBFBF"
  },
  mindmap: {
    useMaxWidth: !0,
    padding: 10,
    maxNodeWidth: 200
  },
  fontSize: 16
};
ui.class && (ui.class.arrowMarkerAbsolute = ui.arrowMarkerAbsolute);
ui.gitGraph && (ui.gitGraph.arrowMarkerAbsolute = ui.arrowMarkerAbsolute);
const _g = (t, e = "") => Object.keys(t).reduce((r, n) => Array.isArray(t[n]) ? r : typeof t[n] == "object" && t[n] !== null ? [...r, e + n, ..._g(t[n], "")] : [...r, e + n], []), U8 = _g(ui, ""), W8 = ui;
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function xg(t) {
  return typeof t > "u" || t === null;
}
function H8(t) {
  return typeof t == "object" && t !== null;
}
function G8(t) {
  return Array.isArray(t) ? t : xg(t) ? [] : [t];
}
function q8(t, e) {
  var r, n, i, s;
  if (e)
    for (s = Object.keys(e), r = 0, n = s.length; r < n; r += 1)
      i = s[r], t[i] = e[i];
  return t;
}
function $8(t, e) {
  var r = "", n;
  for (n = 0; n < e; n += 1)
    r += t;
  return r;
}
function j8(t) {
  return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
}
var X8 = xg, K8 = H8, Z8 = G8, Q8 = $8, J8 = j8, t7 = q8, hr = {
  isNothing: X8,
  isObject: K8,
  toArray: Z8,
  repeat: Q8,
  isNegativeZero: J8,
  extend: t7
};
function vg(t, e) {
  var r = "", n = t.reason || "(unknown reason)";
  return t.mark ? (t.mark.name && (r += 'in "' + t.mark.name + '" '), r += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")", !e && t.mark.snippet && (r += `

` + t.mark.snippet), n + " " + r) : n;
}
function Ya(t, e) {
  Error.call(this), this.name = "YAMLException", this.reason = t, this.mark = e, this.message = vg(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
Ya.prototype = Object.create(Error.prototype);
Ya.prototype.constructor = Ya;
Ya.prototype.toString = function(e) {
  return this.name + ": " + vg(this, e);
};
var Vn = Ya;
function Mu(t, e, r, n, i) {
  var s = "", a = "", o = Math.floor(i / 2) - 1;
  return n - e > o && (s = " ... ", e = n - o + s.length), r - n > o && (a = " ...", r = n + o - a.length), {
    str: s + t.slice(e, r).replace(/\t/g, "") + a,
    pos: n - e + s.length
    // relative position
  };
}
function Nu(t, e) {
  return hr.repeat(" ", e - t.length) + t;
}
function e7(t, e) {
  if (e = Object.create(e || null), !t.buffer)
    return null;
  e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
  for (var r = /\r?\n|\r|\0/g, n = [0], i = [], s, a = -1; s = r.exec(t.buffer); )
    i.push(s.index), n.push(s.index + s[0].length), t.position <= s.index && a < 0 && (a = n.length - 2);
  a < 0 && (a = n.length - 1);
  var o = "", l, u, h = Math.min(t.line + e.linesAfter, i.length).toString().length, f = e.maxLength - (e.indent + h + 3);
  for (l = 1; l <= e.linesBefore && !(a - l < 0); l++)
    u = Mu(
      t.buffer,
      n[a - l],
      i[a - l],
      t.position - (n[a] - n[a - l]),
      f
    ), o = hr.repeat(" ", e.indent) + Nu((t.line - l + 1).toString(), h) + " | " + u.str + `
` + o;
  for (u = Mu(t.buffer, n[a], i[a], t.position, f), o += hr.repeat(" ", e.indent) + Nu((t.line + 1).toString(), h) + " | " + u.str + `
`, o += hr.repeat("-", e.indent + h + 3 + u.pos) + `^
`, l = 1; l <= e.linesAfter && !(a + l >= i.length); l++)
    u = Mu(
      t.buffer,
      n[a + l],
      i[a + l],
      t.position - (n[a] - n[a + l]),
      f
    ), o += hr.repeat(" ", e.indent) + Nu((t.line + l + 1).toString(), h) + " | " + u.str + `
`;
  return o.replace(/\n$/, "");
}
var r7 = e7, n7 = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], i7 = [
  "scalar",
  "sequence",
  "mapping"
];
function s7(t) {
  var e = {};
  return t !== null && Object.keys(t).forEach(function(r) {
    t[r].forEach(function(n) {
      e[String(n)] = r;
    });
  }), e;
}
function a7(t, e) {
  if (e = e || {}, Object.keys(e).forEach(function(r) {
    if (n7.indexOf(r) === -1)
      throw new Vn('Unknown option "' + r + '" is met in definition of "' + t + '" YAML type.');
  }), this.options = e, this.tag = t, this.kind = e.kind || null, this.resolve = e.resolve || function() {
    return !0;
  }, this.construct = e.construct || function(r) {
    return r;
  }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || !1, this.styleAliases = s7(e.styleAliases || null), i7.indexOf(this.kind) === -1)
    throw new Vn('Unknown kind "' + this.kind + '" is specified for "' + t + '" YAML type.');
}
var lr = a7;
function ad(t, e) {
  var r = [];
  return t[e].forEach(function(n) {
    var i = r.length;
    r.forEach(function(s, a) {
      s.tag === n.tag && s.kind === n.kind && s.multi === n.multi && (i = a);
    }), r[i] = n;
  }), r;
}
function o7() {
  var t = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, e, r;
  function n(i) {
    i.multi ? (t.multi[i.kind].push(i), t.multi.fallback.push(i)) : t[i.kind][i.tag] = t.fallback[i.tag] = i;
  }
  for (e = 0, r = arguments.length; e < r; e += 1)
    arguments[e].forEach(n);
  return t;
}
function Th(t) {
  return this.extend(t);
}
Th.prototype.extend = function(e) {
  var r = [], n = [];
  if (e instanceof lr)
    n.push(e);
  else if (Array.isArray(e))
    n = n.concat(e);
  else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit)))
    e.implicit && (r = r.concat(e.implicit)), e.explicit && (n = n.concat(e.explicit));
  else
    throw new Vn("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  r.forEach(function(s) {
    if (!(s instanceof lr))
      throw new Vn("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new Vn("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new Vn("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), n.forEach(function(s) {
    if (!(s instanceof lr))
      throw new Vn("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(Th.prototype);
  return i.implicit = (this.implicit || []).concat(r), i.explicit = (this.explicit || []).concat(n), i.compiledImplicit = ad(i, "implicit"), i.compiledExplicit = ad(i, "explicit"), i.compiledTypeMap = o7(i.compiledImplicit, i.compiledExplicit), i;
};
var l7 = Th, c7 = new lr("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(t) {
    return t !== null ? t : "";
  }
}), u7 = new lr("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(t) {
    return t !== null ? t : [];
  }
}), h7 = new lr("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(t) {
    return t !== null ? t : {};
  }
}), kg = new l7({
  explicit: [
    c7,
    u7,
    h7
  ]
});
function f7(t) {
  if (t === null)
    return !0;
  var e = t.length;
  return e === 1 && t === "~" || e === 4 && (t === "null" || t === "Null" || t === "NULL");
}
function d7() {
  return null;
}
function p7(t) {
  return t === null;
}
var g7 = new lr("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: f7,
  construct: d7,
  predicate: p7,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function y7(t) {
  if (t === null)
    return !1;
  var e = t.length;
  return e === 4 && (t === "true" || t === "True" || t === "TRUE") || e === 5 && (t === "false" || t === "False" || t === "FALSE");
}
function m7(t) {
  return t === "true" || t === "True" || t === "TRUE";
}
function b7(t) {
  return Object.prototype.toString.call(t) === "[object Boolean]";
}
var _7 = new lr("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: y7,
  construct: m7,
  predicate: b7,
  represent: {
    lowercase: function(t) {
      return t ? "true" : "false";
    },
    uppercase: function(t) {
      return t ? "TRUE" : "FALSE";
    },
    camelcase: function(t) {
      return t ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function x7(t) {
  return 48 <= t && t <= 57 || 65 <= t && t <= 70 || 97 <= t && t <= 102;
}
function v7(t) {
  return 48 <= t && t <= 55;
}
function k7(t) {
  return 48 <= t && t <= 57;
}
function w7(t) {
  if (t === null)
    return !1;
  var e = t.length, r = 0, n = !1, i;
  if (!e)
    return !1;
  if (i = t[r], (i === "-" || i === "+") && (i = t[++r]), i === "0") {
    if (r + 1 === e)
      return !0;
    if (i = t[++r], i === "b") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (i !== "0" && i !== "1")
            return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "x") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (!x7(t.charCodeAt(r)))
            return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "o") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (!v7(t.charCodeAt(r)))
            return !1;
          n = !0;
        }
      return n && i !== "_";
    }
  }
  if (i === "_")
    return !1;
  for (; r < e; r++)
    if (i = t[r], i !== "_") {
      if (!k7(t.charCodeAt(r)))
        return !1;
      n = !0;
    }
  return !(!n || i === "_");
}
function T7(t) {
  var e = t, r = 1, n;
  if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), n = e[0], (n === "-" || n === "+") && (n === "-" && (r = -1), e = e.slice(1), n = e[0]), e === "0")
    return 0;
  if (n === "0") {
    if (e[1] === "b")
      return r * parseInt(e.slice(2), 2);
    if (e[1] === "x")
      return r * parseInt(e.slice(2), 16);
    if (e[1] === "o")
      return r * parseInt(e.slice(2), 8);
  }
  return r * parseInt(e, 10);
}
function E7(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && t % 1 === 0 && !hr.isNegativeZero(t);
}
var C7 = new lr("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: w7,
  construct: T7,
  predicate: E7,
  represent: {
    binary: function(t) {
      return t >= 0 ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1);
    },
    octal: function(t) {
      return t >= 0 ? "0o" + t.toString(8) : "-0o" + t.toString(8).slice(1);
    },
    decimal: function(t) {
      return t.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(t) {
      return t >= 0 ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), S7 = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function A7(t) {
  return !(t === null || !S7.test(t) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  t[t.length - 1] === "_");
}
function L7(t) {
  var e, r;
  return e = t.replace(/_/g, "").toLowerCase(), r = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : r * parseFloat(e, 10);
}
var B7 = /^[-+]?[0-9]+e/;
function D7(t, e) {
  var r;
  if (isNaN(t))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (hr.isNegativeZero(t))
    return "-0.0";
  return r = t.toString(10), B7.test(r) ? r.replace("e", ".e") : r;
}
function I7(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && (t % 1 !== 0 || hr.isNegativeZero(t));
}
var M7 = new lr("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: A7,
  construct: L7,
  predicate: I7,
  represent: D7,
  defaultStyle: "lowercase"
}), N7 = kg.extend({
  implicit: [
    g7,
    _7,
    C7,
    M7
  ]
}), R7 = N7, wg = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Tg = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function F7(t) {
  return t === null ? !1 : wg.exec(t) !== null || Tg.exec(t) !== null;
}
function O7(t) {
  var e, r, n, i, s, a, o, l = 0, u = null, h, f, d;
  if (e = wg.exec(t), e === null && (e = Tg.exec(t)), e === null)
    throw new Error("Date resolve error");
  if (r = +e[1], n = +e[2] - 1, i = +e[3], !e[4])
    return new Date(Date.UTC(r, n, i));
  if (s = +e[4], a = +e[5], o = +e[6], e[7]) {
    for (l = e[7].slice(0, 3); l.length < 3; )
      l += "0";
    l = +l;
  }
  return e[9] && (h = +e[10], f = +(e[11] || 0), u = (h * 60 + f) * 6e4, e[9] === "-" && (u = -u)), d = new Date(Date.UTC(r, n, i, s, a, o, l)), u && d.setTime(d.getTime() - u), d;
}
function P7(t) {
  return t.toISOString();
}
var V7 = new lr("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: F7,
  construct: O7,
  instanceOf: Date,
  represent: P7
});
function Y7(t) {
  return t === "<<" || t === null;
}
var z7 = new lr("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: Y7
}), X1 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function U7(t) {
  if (t === null)
    return !1;
  var e, r, n = 0, i = t.length, s = X1;
  for (r = 0; r < i; r++)
    if (e = s.indexOf(t.charAt(r)), !(e > 64)) {
      if (e < 0)
        return !1;
      n += 6;
    }
  return n % 8 === 0;
}
function W7(t) {
  var e, r, n = t.replace(/[\r\n=]/g, ""), i = n.length, s = X1, a = 0, o = [];
  for (e = 0; e < i; e++)
    e % 4 === 0 && e && (o.push(a >> 16 & 255), o.push(a >> 8 & 255), o.push(a & 255)), a = a << 6 | s.indexOf(n.charAt(e));
  return r = i % 4 * 6, r === 0 ? (o.push(a >> 16 & 255), o.push(a >> 8 & 255), o.push(a & 255)) : r === 18 ? (o.push(a >> 10 & 255), o.push(a >> 2 & 255)) : r === 12 && o.push(a >> 4 & 255), new Uint8Array(o);
}
function H7(t) {
  var e = "", r = 0, n, i, s = t.length, a = X1;
  for (n = 0; n < s; n++)
    n % 3 === 0 && n && (e += a[r >> 18 & 63], e += a[r >> 12 & 63], e += a[r >> 6 & 63], e += a[r & 63]), r = (r << 8) + t[n];
  return i = s % 3, i === 0 ? (e += a[r >> 18 & 63], e += a[r >> 12 & 63], e += a[r >> 6 & 63], e += a[r & 63]) : i === 2 ? (e += a[r >> 10 & 63], e += a[r >> 4 & 63], e += a[r << 2 & 63], e += a[64]) : i === 1 && (e += a[r >> 2 & 63], e += a[r << 4 & 63], e += a[64], e += a[64]), e;
}
function G7(t) {
  return Object.prototype.toString.call(t) === "[object Uint8Array]";
}
var q7 = new lr("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: U7,
  construct: W7,
  predicate: G7,
  represent: H7
}), $7 = Object.prototype.hasOwnProperty, j7 = Object.prototype.toString;
function X7(t) {
  if (t === null)
    return !0;
  var e = [], r, n, i, s, a, o = t;
  for (r = 0, n = o.length; r < n; r += 1) {
    if (i = o[r], a = !1, j7.call(i) !== "[object Object]")
      return !1;
    for (s in i)
      if ($7.call(i, s))
        if (!a)
          a = !0;
        else
          return !1;
    if (!a)
      return !1;
    if (e.indexOf(s) === -1)
      e.push(s);
    else
      return !1;
  }
  return !0;
}
function K7(t) {
  return t !== null ? t : [];
}
var Z7 = new lr("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: X7,
  construct: K7
}), Q7 = Object.prototype.toString;
function J7(t) {
  if (t === null)
    return !0;
  var e, r, n, i, s, a = t;
  for (s = new Array(a.length), e = 0, r = a.length; e < r; e += 1) {
    if (n = a[e], Q7.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1))
      return !1;
    s[e] = [i[0], n[i[0]]];
  }
  return !0;
}
function tw(t) {
  if (t === null)
    return [];
  var e, r, n, i, s, a = t;
  for (s = new Array(a.length), e = 0, r = a.length; e < r; e += 1)
    n = a[e], i = Object.keys(n), s[e] = [i[0], n[i[0]]];
  return s;
}
var ew = new lr("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: J7,
  construct: tw
}), rw = Object.prototype.hasOwnProperty;
function nw(t) {
  if (t === null)
    return !0;
  var e, r = t;
  for (e in r)
    if (rw.call(r, e) && r[e] !== null)
      return !1;
  return !0;
}
function iw(t) {
  return t !== null ? t : {};
}
var sw = new lr("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: nw,
  construct: iw
}), aw = R7.extend({
  implicit: [
    V7,
    z7
  ],
  explicit: [
    q7,
    Z7,
    ew,
    sw
  ]
}), gi = Object.prototype.hasOwnProperty, Ol = 1, Eg = 2, Cg = 3, Pl = 4, Ru = 1, ow = 2, od = 3, lw = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, cw = /[\x85\u2028\u2029]/, uw = /[,\[\]\{\}]/, Sg = /^(?:!|!!|![a-z\-]+!)$/i, Ag = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function ld(t) {
  return Object.prototype.toString.call(t);
}
function xn(t) {
  return t === 10 || t === 13;
}
function Mi(t) {
  return t === 9 || t === 32;
}
function wr(t) {
  return t === 9 || t === 32 || t === 10 || t === 13;
}
function fs(t) {
  return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
}
function hw(t) {
  var e;
  return 48 <= t && t <= 57 ? t - 48 : (e = t | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
function fw(t) {
  return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
}
function dw(t) {
  return 48 <= t && t <= 57 ? t - 48 : -1;
}
function cd(t) {
  return t === 48 ? "\0" : t === 97 ? "\x07" : t === 98 ? "\b" : t === 116 || t === 9 ? "	" : t === 110 ? `
` : t === 118 ? "\v" : t === 102 ? "\f" : t === 114 ? "\r" : t === 101 ? "\x1B" : t === 32 ? " " : t === 34 ? '"' : t === 47 ? "/" : t === 92 ? "\\" : t === 78 ? "" : t === 95 ? "" : t === 76 ? "\u2028" : t === 80 ? "\u2029" : "";
}
function pw(t) {
  return t <= 65535 ? String.fromCharCode(t) : String.fromCharCode(
    (t - 65536 >> 10) + 55296,
    (t - 65536 & 1023) + 56320
  );
}
var Lg = new Array(256), Bg = new Array(256);
for (var os = 0; os < 256; os++)
  Lg[os] = cd(os) ? 1 : 0, Bg[os] = cd(os);
function gw(t, e) {
  this.input = t, this.filename = e.filename || null, this.schema = e.schema || aw, this.onWarning = e.onWarning || null, this.legacy = e.legacy || !1, this.json = e.json || !1, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function Dg(t, e) {
  var r = {
    name: t.filename,
    buffer: t.input.slice(0, -1),
    // omit trailing \0
    position: t.position,
    line: t.line,
    column: t.position - t.lineStart
  };
  return r.snippet = r7(r), new Vn(e, r);
}
function Vt(t, e) {
  throw Dg(t, e);
}
function Vl(t, e) {
  t.onWarning && t.onWarning.call(null, Dg(t, e));
}
var ud = {
  YAML: function(e, r, n) {
    var i, s, a;
    e.version !== null && Vt(e, "duplication of %YAML directive"), n.length !== 1 && Vt(e, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(n[0]), i === null && Vt(e, "ill-formed argument of the YAML directive"), s = parseInt(i[1], 10), a = parseInt(i[2], 10), s !== 1 && Vt(e, "unacceptable YAML version of the document"), e.version = n[0], e.checkLineBreaks = a < 2, a !== 1 && a !== 2 && Vl(e, "unsupported YAML version of the document");
  },
  TAG: function(e, r, n) {
    var i, s;
    n.length !== 2 && Vt(e, "TAG directive accepts exactly two arguments"), i = n[0], s = n[1], Sg.test(i) || Vt(e, "ill-formed tag handle (first argument) of the TAG directive"), gi.call(e.tagMap, i) && Vt(e, 'there is a previously declared suffix for "' + i + '" tag handle'), Ag.test(s) || Vt(e, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      Vt(e, "tag prefix is malformed: " + s);
    }
    e.tagMap[i] = s;
  }
};
function hi(t, e, r, n) {
  var i, s, a, o;
  if (e < r) {
    if (o = t.input.slice(e, r), n)
      for (i = 0, s = o.length; i < s; i += 1)
        a = o.charCodeAt(i), a === 9 || 32 <= a && a <= 1114111 || Vt(t, "expected valid JSON character");
    else
      lw.test(o) && Vt(t, "the stream contains non-printable characters");
    t.result += o;
  }
}
function hd(t, e, r, n) {
  var i, s, a, o;
  for (hr.isObject(r) || Vt(t, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), a = 0, o = i.length; a < o; a += 1)
    s = i[a], gi.call(e, s) || (e[s] = r[s], n[s] = !0);
}
function ds(t, e, r, n, i, s, a, o, l) {
  var u, h;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), u = 0, h = i.length; u < h; u += 1)
      Array.isArray(i[u]) && Vt(t, "nested arrays are not supported inside keys"), typeof i == "object" && ld(i[u]) === "[object Object]" && (i[u] = "[object Object]");
  if (typeof i == "object" && ld(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), n === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (u = 0, h = s.length; u < h; u += 1)
        hd(t, e, s[u], r);
    else
      hd(t, e, s, r);
  else
    !t.json && !gi.call(r, i) && gi.call(e, i) && (t.line = a || t.line, t.lineStart = o || t.lineStart, t.position = l || t.position, Vt(t, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(e, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : e[i] = s, delete r[i];
  return e;
}
function K1(t) {
  var e;
  e = t.input.charCodeAt(t.position), e === 10 ? t.position++ : e === 13 ? (t.position++, t.input.charCodeAt(t.position) === 10 && t.position++) : Vt(t, "a line break is expected"), t.line += 1, t.lineStart = t.position, t.firstTabInLine = -1;
}
function Fe(t, e, r) {
  for (var n = 0, i = t.input.charCodeAt(t.position); i !== 0; ) {
    for (; Mi(i); )
      i === 9 && t.firstTabInLine === -1 && (t.firstTabInLine = t.position), i = t.input.charCodeAt(++t.position);
    if (e && i === 35)
      do
        i = t.input.charCodeAt(++t.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (xn(i))
      for (K1(t), i = t.input.charCodeAt(t.position), n++, t.lineIndent = 0; i === 32; )
        t.lineIndent++, i = t.input.charCodeAt(++t.position);
    else
      break;
  }
  return r !== -1 && n !== 0 && t.lineIndent < r && Vl(t, "deficient indentation"), n;
}
function Bc(t) {
  var e = t.position, r;
  return r = t.input.charCodeAt(e), !!((r === 45 || r === 46) && r === t.input.charCodeAt(e + 1) && r === t.input.charCodeAt(e + 2) && (e += 3, r = t.input.charCodeAt(e), r === 0 || wr(r)));
}
function Z1(t, e) {
  e === 1 ? t.result += " " : e > 1 && (t.result += hr.repeat(`
`, e - 1));
}
function yw(t, e, r) {
  var n, i, s, a, o, l, u, h, f = t.kind, d = t.result, p;
  if (p = t.input.charCodeAt(t.position), wr(p) || fs(p) || p === 35 || p === 38 || p === 42 || p === 33 || p === 124 || p === 62 || p === 39 || p === 34 || p === 37 || p === 64 || p === 96 || (p === 63 || p === 45) && (i = t.input.charCodeAt(t.position + 1), wr(i) || r && fs(i)))
    return !1;
  for (t.kind = "scalar", t.result = "", s = a = t.position, o = !1; p !== 0; ) {
    if (p === 58) {
      if (i = t.input.charCodeAt(t.position + 1), wr(i) || r && fs(i))
        break;
    } else if (p === 35) {
      if (n = t.input.charCodeAt(t.position - 1), wr(n))
        break;
    } else {
      if (t.position === t.lineStart && Bc(t) || r && fs(p))
        break;
      if (xn(p))
        if (l = t.line, u = t.lineStart, h = t.lineIndent, Fe(t, !1, -1), t.lineIndent >= e) {
          o = !0, p = t.input.charCodeAt(t.position);
          continue;
        } else {
          t.position = a, t.line = l, t.lineStart = u, t.lineIndent = h;
          break;
        }
    }
    o && (hi(t, s, a, !1), Z1(t, t.line - l), s = a = t.position, o = !1), Mi(p) || (a = t.position + 1), p = t.input.charCodeAt(++t.position);
  }
  return hi(t, s, a, !1), t.result ? !0 : (t.kind = f, t.result = d, !1);
}
function mw(t, e) {
  var r, n, i;
  if (r = t.input.charCodeAt(t.position), r !== 39)
    return !1;
  for (t.kind = "scalar", t.result = "", t.position++, n = i = t.position; (r = t.input.charCodeAt(t.position)) !== 0; )
    if (r === 39)
      if (hi(t, n, t.position, !0), r = t.input.charCodeAt(++t.position), r === 39)
        n = t.position, t.position++, i = t.position;
      else
        return !0;
    else
      xn(r) ? (hi(t, n, i, !0), Z1(t, Fe(t, !1, e)), n = i = t.position) : t.position === t.lineStart && Bc(t) ? Vt(t, "unexpected end of the document within a single quoted scalar") : (t.position++, i = t.position);
  Vt(t, "unexpected end of the stream within a single quoted scalar");
}
function bw(t, e) {
  var r, n, i, s, a, o;
  if (o = t.input.charCodeAt(t.position), o !== 34)
    return !1;
  for (t.kind = "scalar", t.result = "", t.position++, r = n = t.position; (o = t.input.charCodeAt(t.position)) !== 0; ) {
    if (o === 34)
      return hi(t, r, t.position, !0), t.position++, !0;
    if (o === 92) {
      if (hi(t, r, t.position, !0), o = t.input.charCodeAt(++t.position), xn(o))
        Fe(t, !1, e);
      else if (o < 256 && Lg[o])
        t.result += Bg[o], t.position++;
      else if ((a = fw(o)) > 0) {
        for (i = a, s = 0; i > 0; i--)
          o = t.input.charCodeAt(++t.position), (a = hw(o)) >= 0 ? s = (s << 4) + a : Vt(t, "expected hexadecimal character");
        t.result += pw(s), t.position++;
      } else
        Vt(t, "unknown escape sequence");
      r = n = t.position;
    } else
      xn(o) ? (hi(t, r, n, !0), Z1(t, Fe(t, !1, e)), r = n = t.position) : t.position === t.lineStart && Bc(t) ? Vt(t, "unexpected end of the document within a double quoted scalar") : (t.position++, n = t.position);
  }
  Vt(t, "unexpected end of the stream within a double quoted scalar");
}
function _w(t, e) {
  var r = !0, n, i, s, a = t.tag, o, l = t.anchor, u, h, f, d, p, m = /* @__PURE__ */ Object.create(null), _, v, k, x;
  if (x = t.input.charCodeAt(t.position), x === 91)
    h = 93, p = !1, o = [];
  else if (x === 123)
    h = 125, p = !0, o = {};
  else
    return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = o), x = t.input.charCodeAt(++t.position); x !== 0; ) {
    if (Fe(t, !0, e), x = t.input.charCodeAt(t.position), x === h)
      return t.position++, t.tag = a, t.anchor = l, t.kind = p ? "mapping" : "sequence", t.result = o, !0;
    r ? x === 44 && Vt(t, "expected the node content, but found ','") : Vt(t, "missed comma between flow collection entries"), v = _ = k = null, f = d = !1, x === 63 && (u = t.input.charCodeAt(t.position + 1), wr(u) && (f = d = !0, t.position++, Fe(t, !0, e))), n = t.line, i = t.lineStart, s = t.position, Ms(t, e, Ol, !1, !0), v = t.tag, _ = t.result, Fe(t, !0, e), x = t.input.charCodeAt(t.position), (d || t.line === n) && x === 58 && (f = !0, x = t.input.charCodeAt(++t.position), Fe(t, !0, e), Ms(t, e, Ol, !1, !0), k = t.result), p ? ds(t, o, m, v, _, k, n, i, s) : f ? o.push(ds(t, null, m, v, _, k, n, i, s)) : o.push(_), Fe(t, !0, e), x = t.input.charCodeAt(t.position), x === 44 ? (r = !0, x = t.input.charCodeAt(++t.position)) : r = !1;
  }
  Vt(t, "unexpected end of the stream within a flow collection");
}
function xw(t, e) {
  var r, n, i = Ru, s = !1, a = !1, o = e, l = 0, u = !1, h, f;
  if (f = t.input.charCodeAt(t.position), f === 124)
    n = !1;
  else if (f === 62)
    n = !0;
  else
    return !1;
  for (t.kind = "scalar", t.result = ""; f !== 0; )
    if (f = t.input.charCodeAt(++t.position), f === 43 || f === 45)
      Ru === i ? i = f === 43 ? od : ow : Vt(t, "repeat of a chomping mode identifier");
    else if ((h = dw(f)) >= 0)
      h === 0 ? Vt(t, "bad explicit indentation width of a block scalar; it cannot be less than one") : a ? Vt(t, "repeat of an indentation width identifier") : (o = e + h - 1, a = !0);
    else
      break;
  if (Mi(f)) {
    do
      f = t.input.charCodeAt(++t.position);
    while (Mi(f));
    if (f === 35)
      do
        f = t.input.charCodeAt(++t.position);
      while (!xn(f) && f !== 0);
  }
  for (; f !== 0; ) {
    for (K1(t), t.lineIndent = 0, f = t.input.charCodeAt(t.position); (!a || t.lineIndent < o) && f === 32; )
      t.lineIndent++, f = t.input.charCodeAt(++t.position);
    if (!a && t.lineIndent > o && (o = t.lineIndent), xn(f)) {
      l++;
      continue;
    }
    if (t.lineIndent < o) {
      i === od ? t.result += hr.repeat(`
`, s ? 1 + l : l) : i === Ru && s && (t.result += `
`);
      break;
    }
    for (n ? Mi(f) ? (u = !0, t.result += hr.repeat(`
`, s ? 1 + l : l)) : u ? (u = !1, t.result += hr.repeat(`
`, l + 1)) : l === 0 ? s && (t.result += " ") : t.result += hr.repeat(`
`, l) : t.result += hr.repeat(`
`, s ? 1 + l : l), s = !0, a = !0, l = 0, r = t.position; !xn(f) && f !== 0; )
      f = t.input.charCodeAt(++t.position);
    hi(t, r, t.position, !1);
  }
  return !0;
}
function fd(t, e) {
  var r, n = t.tag, i = t.anchor, s = [], a, o = !1, l;
  if (t.firstTabInLine !== -1)
    return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = s), l = t.input.charCodeAt(t.position); l !== 0 && (t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, Vt(t, "tab characters must not be used in indentation")), !(l !== 45 || (a = t.input.charCodeAt(t.position + 1), !wr(a)))); ) {
    if (o = !0, t.position++, Fe(t, !0, -1) && t.lineIndent <= e) {
      s.push(null), l = t.input.charCodeAt(t.position);
      continue;
    }
    if (r = t.line, Ms(t, e, Cg, !1, !0), s.push(t.result), Fe(t, !0, -1), l = t.input.charCodeAt(t.position), (t.line === r || t.lineIndent > e) && l !== 0)
      Vt(t, "bad indentation of a sequence entry");
    else if (t.lineIndent < e)
      break;
  }
  return o ? (t.tag = n, t.anchor = i, t.kind = "sequence", t.result = s, !0) : !1;
}
function vw(t, e, r) {
  var n, i, s, a, o, l, u = t.tag, h = t.anchor, f = {}, d = /* @__PURE__ */ Object.create(null), p = null, m = null, _ = null, v = !1, k = !1, x;
  if (t.firstTabInLine !== -1)
    return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = f), x = t.input.charCodeAt(t.position); x !== 0; ) {
    if (!v && t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, Vt(t, "tab characters must not be used in indentation")), n = t.input.charCodeAt(t.position + 1), s = t.line, (x === 63 || x === 58) && wr(n))
      x === 63 ? (v && (ds(t, f, d, p, m, null, a, o, l), p = m = _ = null), k = !0, v = !0, i = !0) : v ? (v = !1, i = !0) : Vt(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t.position += 1, x = n;
    else {
      if (a = t.line, o = t.lineStart, l = t.position, !Ms(t, r, Eg, !1, !0))
        break;
      if (t.line === s) {
        for (x = t.input.charCodeAt(t.position); Mi(x); )
          x = t.input.charCodeAt(++t.position);
        if (x === 58)
          x = t.input.charCodeAt(++t.position), wr(x) || Vt(t, "a whitespace character is expected after the key-value separator within a block mapping"), v && (ds(t, f, d, p, m, null, a, o, l), p = m = _ = null), k = !0, v = !1, i = !1, p = t.tag, m = t.result;
        else if (k)
          Vt(t, "can not read an implicit mapping pair; a colon is missed");
        else
          return t.tag = u, t.anchor = h, !0;
      } else if (k)
        Vt(t, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return t.tag = u, t.anchor = h, !0;
    }
    if ((t.line === s || t.lineIndent > e) && (v && (a = t.line, o = t.lineStart, l = t.position), Ms(t, e, Pl, !0, i) && (v ? m = t.result : _ = t.result), v || (ds(t, f, d, p, m, _, a, o, l), p = m = _ = null), Fe(t, !0, -1), x = t.input.charCodeAt(t.position)), (t.line === s || t.lineIndent > e) && x !== 0)
      Vt(t, "bad indentation of a mapping entry");
    else if (t.lineIndent < e)
      break;
  }
  return v && ds(t, f, d, p, m, null, a, o, l), k && (t.tag = u, t.anchor = h, t.kind = "mapping", t.result = f), k;
}
function kw(t) {
  var e, r = !1, n = !1, i, s, a;
  if (a = t.input.charCodeAt(t.position), a !== 33)
    return !1;
  if (t.tag !== null && Vt(t, "duplication of a tag property"), a = t.input.charCodeAt(++t.position), a === 60 ? (r = !0, a = t.input.charCodeAt(++t.position)) : a === 33 ? (n = !0, i = "!!", a = t.input.charCodeAt(++t.position)) : i = "!", e = t.position, r) {
    do
      a = t.input.charCodeAt(++t.position);
    while (a !== 0 && a !== 62);
    t.position < t.length ? (s = t.input.slice(e, t.position), a = t.input.charCodeAt(++t.position)) : Vt(t, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; a !== 0 && !wr(a); )
      a === 33 && (n ? Vt(t, "tag suffix cannot contain exclamation marks") : (i = t.input.slice(e - 1, t.position + 1), Sg.test(i) || Vt(t, "named tag handle cannot contain such characters"), n = !0, e = t.position + 1)), a = t.input.charCodeAt(++t.position);
    s = t.input.slice(e, t.position), uw.test(s) && Vt(t, "tag suffix cannot contain flow indicator characters");
  }
  s && !Ag.test(s) && Vt(t, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    Vt(t, "tag name is malformed: " + s);
  }
  return r ? t.tag = s : gi.call(t.tagMap, i) ? t.tag = t.tagMap[i] + s : i === "!" ? t.tag = "!" + s : i === "!!" ? t.tag = "tag:yaml.org,2002:" + s : Vt(t, 'undeclared tag handle "' + i + '"'), !0;
}
function ww(t) {
  var e, r;
  if (r = t.input.charCodeAt(t.position), r !== 38)
    return !1;
  for (t.anchor !== null && Vt(t, "duplication of an anchor property"), r = t.input.charCodeAt(++t.position), e = t.position; r !== 0 && !wr(r) && !fs(r); )
    r = t.input.charCodeAt(++t.position);
  return t.position === e && Vt(t, "name of an anchor node must contain at least one character"), t.anchor = t.input.slice(e, t.position), !0;
}
function Tw(t) {
  var e, r, n;
  if (n = t.input.charCodeAt(t.position), n !== 42)
    return !1;
  for (n = t.input.charCodeAt(++t.position), e = t.position; n !== 0 && !wr(n) && !fs(n); )
    n = t.input.charCodeAt(++t.position);
  return t.position === e && Vt(t, "name of an alias node must contain at least one character"), r = t.input.slice(e, t.position), gi.call(t.anchorMap, r) || Vt(t, 'unidentified alias "' + r + '"'), t.result = t.anchorMap[r], Fe(t, !0, -1), !0;
}
function Ms(t, e, r, n, i) {
  var s, a, o, l = 1, u = !1, h = !1, f, d, p, m, _, v;
  if (t.listener !== null && t.listener("open", t), t.tag = null, t.anchor = null, t.kind = null, t.result = null, s = a = o = Pl === r || Cg === r, n && Fe(t, !0, -1) && (u = !0, t.lineIndent > e ? l = 1 : t.lineIndent === e ? l = 0 : t.lineIndent < e && (l = -1)), l === 1)
    for (; kw(t) || ww(t); )
      Fe(t, !0, -1) ? (u = !0, o = s, t.lineIndent > e ? l = 1 : t.lineIndent === e ? l = 0 : t.lineIndent < e && (l = -1)) : o = !1;
  if (o && (o = u || i), (l === 1 || Pl === r) && (Ol === r || Eg === r ? _ = e : _ = e + 1, v = t.position - t.lineStart, l === 1 ? o && (fd(t, v) || vw(t, v, _)) || _w(t, _) ? h = !0 : (a && xw(t, _) || mw(t, _) || bw(t, _) ? h = !0 : Tw(t) ? (h = !0, (t.tag !== null || t.anchor !== null) && Vt(t, "alias node should not have any properties")) : yw(t, _, Ol === r) && (h = !0, t.tag === null && (t.tag = "?")), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : l === 0 && (h = o && fd(t, v))), t.tag === null)
    t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
  else if (t.tag === "?") {
    for (t.result !== null && t.kind !== "scalar" && Vt(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'), f = 0, d = t.implicitTypes.length; f < d; f += 1)
      if (m = t.implicitTypes[f], m.resolve(t.result)) {
        t.result = m.construct(t.result), t.tag = m.tag, t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
        break;
      }
  } else if (t.tag !== "!") {
    if (gi.call(t.typeMap[t.kind || "fallback"], t.tag))
      m = t.typeMap[t.kind || "fallback"][t.tag];
    else
      for (m = null, p = t.typeMap.multi[t.kind || "fallback"], f = 0, d = p.length; f < d; f += 1)
        if (t.tag.slice(0, p[f].tag.length) === p[f].tag) {
          m = p[f];
          break;
        }
    m || Vt(t, "unknown tag !<" + t.tag + ">"), t.result !== null && m.kind !== t.kind && Vt(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + m.kind + '", not "' + t.kind + '"'), m.resolve(t.result, t.tag) ? (t.result = m.construct(t.result, t.tag), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : Vt(t, "cannot resolve a node with !<" + t.tag + "> explicit tag");
  }
  return t.listener !== null && t.listener("close", t), t.tag !== null || t.anchor !== null || h;
}
function Ew(t) {
  var e = t.position, r, n, i, s = !1, a;
  for (t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = /* @__PURE__ */ Object.create(null), t.anchorMap = /* @__PURE__ */ Object.create(null); (a = t.input.charCodeAt(t.position)) !== 0 && (Fe(t, !0, -1), a = t.input.charCodeAt(t.position), !(t.lineIndent > 0 || a !== 37)); ) {
    for (s = !0, a = t.input.charCodeAt(++t.position), r = t.position; a !== 0 && !wr(a); )
      a = t.input.charCodeAt(++t.position);
    for (n = t.input.slice(r, t.position), i = [], n.length < 1 && Vt(t, "directive name must not be less than one character in length"); a !== 0; ) {
      for (; Mi(a); )
        a = t.input.charCodeAt(++t.position);
      if (a === 35) {
        do
          a = t.input.charCodeAt(++t.position);
        while (a !== 0 && !xn(a));
        break;
      }
      if (xn(a))
        break;
      for (r = t.position; a !== 0 && !wr(a); )
        a = t.input.charCodeAt(++t.position);
      i.push(t.input.slice(r, t.position));
    }
    a !== 0 && K1(t), gi.call(ud, n) ? ud[n](t, n, i) : Vl(t, 'unknown document directive "' + n + '"');
  }
  if (Fe(t, !0, -1), t.lineIndent === 0 && t.input.charCodeAt(t.position) === 45 && t.input.charCodeAt(t.position + 1) === 45 && t.input.charCodeAt(t.position + 2) === 45 ? (t.position += 3, Fe(t, !0, -1)) : s && Vt(t, "directives end mark is expected"), Ms(t, t.lineIndent - 1, Pl, !1, !0), Fe(t, !0, -1), t.checkLineBreaks && cw.test(t.input.slice(e, t.position)) && Vl(t, "non-ASCII line breaks are interpreted as content"), t.documents.push(t.result), t.position === t.lineStart && Bc(t)) {
    t.input.charCodeAt(t.position) === 46 && (t.position += 3, Fe(t, !0, -1));
    return;
  }
  if (t.position < t.length - 1)
    Vt(t, "end of the stream or a document separator is expected");
  else
    return;
}
function Ig(t, e) {
  t = String(t), e = e || {}, t.length !== 0 && (t.charCodeAt(t.length - 1) !== 10 && t.charCodeAt(t.length - 1) !== 13 && (t += `
`), t.charCodeAt(0) === 65279 && (t = t.slice(1)));
  var r = new gw(t, e), n = t.indexOf("\0");
  for (n !== -1 && (r.position = n, Vt(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    Ew(r);
  return r.documents;
}
function Cw(t, e, r) {
  e !== null && typeof e == "object" && typeof r > "u" && (r = e, e = null);
  var n = Ig(t, r);
  if (typeof e != "function")
    return n;
  for (var i = 0, s = n.length; i < s; i += 1)
    e(n[i]);
}
function Sw(t, e) {
  var r = Ig(t, e);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new Vn("expected a single document in the stream, but found more");
  }
}
var Aw = Cw, Lw = Sw, Bw = {
  loadAll: Aw,
  load: Lw
}, Dw = kg, Iw = Bw.load;
const Mg = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s;
function Mw(t, e) {
  var n;
  const r = t.match(Mg);
  if (r) {
    const i = Iw(r[1], {
      // To keep things simple, only allow strings, arrays, and plain objects.
      // https://www.yaml.org/spec/1.2/spec.html#id2802346
      schema: Dw
    });
    return i != null && i.title && ((n = e.setDiagramTitle) == null || n.call(e, i.title)), t.slice(r[0].length);
  } else
    return t;
}
const Nw = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, Rw = /\s*%%.*\n/gm, Yl = {}, Q1 = function(t, e) {
  t = t.replace(Mg, "").replace(Nw, "").replace(Rw, `
`);
  for (const [r, { detector: n }] of Object.entries(Yl))
    if (n(t, e))
      return r;
  throw new Error(`No diagram type detected for text: ${t}`);
}, Ng = (...t) => {
  for (const { id: e, detector: r, loader: n } of t)
    Rg(e, r, n);
}, Rg = (t, e, r) => {
  Yl[t] ? B.error(`Detector with key ${t} already exists`) : Yl[t] = { detector: e, loader: r }, B.debug(`Detector with key ${t} added${r ? " with loader" : ""}`);
}, Fw = (t) => Yl[t].loader, Eh = function(t, e, r) {
  const { depth: n, clobber: i } = Object.assign({ depth: 2, clobber: !1 }, r);
  return Array.isArray(e) && !Array.isArray(t) ? (e.forEach((s) => Eh(t, s, r)), t) : Array.isArray(e) && Array.isArray(t) ? (e.forEach((s) => {
    t.includes(s) || t.push(s);
  }), t) : t === void 0 || n <= 0 ? t != null && typeof t == "object" && typeof e == "object" ? Object.assign(t, e) : e : (e !== void 0 && typeof t == "object" && typeof e == "object" && Object.keys(e).forEach((s) => {
    typeof e[s] == "object" && (t[s] === void 0 || typeof t[s] == "object") ? (t[s] === void 0 && (t[s] = Array.isArray(e[s]) ? [] : {}), t[s] = Eh(t[s], e[s], { depth: n - 1, clobber: i })) : (i || typeof t[s] != "object" && typeof e[s] != "object") && (t[s] = e[s]);
  }), t);
}, Xe = Eh;
var Ow = typeof global == "object" && global && global.Object === Object && global;
const Fg = Ow;
var Pw = typeof self == "object" && self && self.Object === Object && self, Vw = Fg || Pw || Function("return this")();
const ln = Vw;
var Yw = ln.Symbol;
const Wr = Yw;
var Og = Object.prototype, zw = Og.hasOwnProperty, Uw = Og.toString, ca = Wr ? Wr.toStringTag : void 0;
function Ww(t) {
  var e = zw.call(t, ca), r = t[ca];
  try {
    t[ca] = void 0;
    var n = !0;
  } catch {
  }
  var i = Uw.call(t);
  return n && (e ? t[ca] = r : delete t[ca]), i;
}
var Hw = Object.prototype, Gw = Hw.toString;
function qw(t) {
  return Gw.call(t);
}
var $w = "[object Null]", jw = "[object Undefined]", dd = Wr ? Wr.toStringTag : void 0;
function Qi(t) {
  return t == null ? t === void 0 ? jw : $w : dd && dd in Object(t) ? Ww(t) : qw(t);
}
function Lr(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var Xw = "[object AsyncFunction]", Kw = "[object Function]", Zw = "[object GeneratorFunction]", Qw = "[object Proxy]";
function Ns(t) {
  if (!Lr(t))
    return !1;
  var e = Qi(t);
  return e == Kw || e == Zw || e == Xw || e == Qw;
}
var Jw = ln["__core-js_shared__"];
const Fu = Jw;
var pd = function() {
  var t = /[^.]+$/.exec(Fu && Fu.keys && Fu.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function tT(t) {
  return !!pd && pd in t;
}
var eT = Function.prototype, rT = eT.toString;
function Ji(t) {
  if (t != null) {
    try {
      return rT.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var nT = /[\\^$.*+?()[\]{}|]/g, iT = /^\[object .+?Constructor\]$/, sT = Function.prototype, aT = Object.prototype, oT = sT.toString, lT = aT.hasOwnProperty, cT = RegExp(
  "^" + oT.call(lT).replace(nT, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function uT(t) {
  if (!Lr(t) || tT(t))
    return !1;
  var e = Ns(t) ? cT : iT;
  return e.test(Ji(t));
}
function hT(t, e) {
  return t == null ? void 0 : t[e];
}
function ts(t, e) {
  var r = hT(t, e);
  return uT(r) ? r : void 0;
}
var fT = ts(Object, "create");
const za = fT;
function dT() {
  this.__data__ = za ? za(null) : {}, this.size = 0;
}
function pT(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var gT = "__lodash_hash_undefined__", yT = Object.prototype, mT = yT.hasOwnProperty;
function bT(t) {
  var e = this.__data__;
  if (za) {
    var r = e[t];
    return r === gT ? void 0 : r;
  }
  return mT.call(e, t) ? e[t] : void 0;
}
var _T = Object.prototype, xT = _T.hasOwnProperty;
function vT(t) {
  var e = this.__data__;
  return za ? e[t] !== void 0 : xT.call(e, t);
}
var kT = "__lodash_hash_undefined__";
function wT(t, e) {
  var r = this.__data__;
  return this.size += this.has(t) ? 0 : 1, r[t] = za && e === void 0 ? kT : e, this;
}
function Vi(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
Vi.prototype.clear = dT;
Vi.prototype.delete = pT;
Vi.prototype.get = bT;
Vi.prototype.has = vT;
Vi.prototype.set = wT;
function TT() {
  this.__data__ = [], this.size = 0;
}
function Xs(t, e) {
  return t === e || t !== t && e !== e;
}
function Dc(t, e) {
  for (var r = t.length; r--; )
    if (Xs(t[r][0], e))
      return r;
  return -1;
}
var ET = Array.prototype, CT = ET.splice;
function ST(t) {
  var e = this.__data__, r = Dc(e, t);
  if (r < 0)
    return !1;
  var n = e.length - 1;
  return r == n ? e.pop() : CT.call(e, r, 1), --this.size, !0;
}
function AT(t) {
  var e = this.__data__, r = Dc(e, t);
  return r < 0 ? void 0 : e[r][1];
}
function LT(t) {
  return Dc(this.__data__, t) > -1;
}
function BT(t, e) {
  var r = this.__data__, n = Dc(r, t);
  return n < 0 ? (++this.size, r.push([t, e])) : r[n][1] = e, this;
}
function ti(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
ti.prototype.clear = TT;
ti.prototype.delete = ST;
ti.prototype.get = AT;
ti.prototype.has = LT;
ti.prototype.set = BT;
var DT = ts(ln, "Map");
const Ua = DT;
function IT() {
  this.size = 0, this.__data__ = {
    hash: new Vi(),
    map: new (Ua || ti)(),
    string: new Vi()
  };
}
function MT(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function Ic(t, e) {
  var r = t.__data__;
  return MT(e) ? r[typeof e == "string" ? "string" : "hash"] : r.map;
}
function NT(t) {
  var e = Ic(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
function RT(t) {
  return Ic(this, t).get(t);
}
function FT(t) {
  return Ic(this, t).has(t);
}
function OT(t, e) {
  var r = Ic(this, t), n = r.size;
  return r.set(t, e), this.size += r.size == n ? 0 : 1, this;
}
function ei(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.clear(); ++e < r; ) {
    var n = t[e];
    this.set(n[0], n[1]);
  }
}
ei.prototype.clear = IT;
ei.prototype.delete = NT;
ei.prototype.get = RT;
ei.prototype.has = FT;
ei.prototype.set = OT;
var PT = "Expected a function";
function Ks(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(PT);
  var r = function() {
    var n = arguments, i = e ? e.apply(this, n) : n[0], s = r.cache;
    if (s.has(i))
      return s.get(i);
    var a = t.apply(this, n);
    return r.cache = s.set(i, a) || s, a;
  };
  return r.cache = new (Ks.Cache || ei)(), r;
}
Ks.Cache = ei;
const VT = {
  curveBasis: Is,
  curveBasisClosed: gk,
  curveBasisOpen: yk,
  curveBumpX: dk,
  curveBumpY: pk,
  curveBundle: mk,
  curveCardinalClosed: _k,
  curveCardinalOpen: xk,
  curveCardinal: bk,
  curveCatmullRomClosed: kk,
  curveCatmullRomOpen: wk,
  curveCatmullRom: vk,
  curveLinear: Ar,
  curveLinearClosed: Tk,
  curveMonotoneX: Ek,
  curveMonotoneY: Ck,
  curveNatural: Sk,
  curveStep: Ak,
  curveStepAfter: Bk,
  curveStepBefore: Lk
}, Ou = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, YT = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, zT = function(t, e) {
  const r = Pg(t, /(?:init\b)|(?:initialize\b)/);
  let n = {};
  if (Array.isArray(r)) {
    const i = r.map((s) => s.args);
    Yi(i), n = Xe(n, [...i]);
  } else
    n = r.args;
  if (n) {
    let i = Q1(t, e);
    ["config"].forEach((s) => {
      n[s] !== void 0 && (i === "flowchart-v2" && (i = "flowchart"), n[i] = n[s], delete n[s]);
    });
  }
  return n;
}, Pg = function(t, e = null) {
  try {
    const r = new RegExp(
      `[%]{2}(?![{]${YT.source})(?=[}][%]{2}).*
`,
      "ig"
    );
    t = t.trim().replace(r, "").replace(/'/gm, '"'), B.debug(
      `Detecting diagram directive${e !== null ? " type:" + e : ""} based on the text:${t}`
    );
    let n;
    const i = [];
    for (; (n = Ou.exec(t)) !== null; )
      if (n.index === Ou.lastIndex && Ou.lastIndex++, n && !e || e && n[1] && n[1].match(e) || e && n[2] && n[2].match(e)) {
        const s = n[1] ? n[1] : n[2], a = n[3] ? n[3].trim() : n[4] ? JSON.parse(n[4].trim()) : null;
        i.push({ type: s, args: a });
      }
    return i.length === 0 && i.push({ type: t, args: null }), i.length === 1 ? i[0] : i;
  } catch (r) {
    return B.error(
      `ERROR: ${r.message} - Unable to parse directive
      ${e !== null ? " type:" + e : ""} based on the text:${t}`
    ), { type: null, args: null };
  }
}, UT = function(t, e) {
  for (const [r, n] of e.entries())
    if (n.match(t))
      return r;
  return -1;
};
function Qr(t, e) {
  if (!t)
    return e;
  const r = `curve${t.charAt(0).toUpperCase() + t.slice(1)}`;
  return VT[r] || e;
}
function WT(t, e) {
  const r = t.trim();
  if (r)
    return e.securityLevel !== "loose" ? Jn(r) : r;
}
const HT = (t, ...e) => {
  const r = t.split("."), n = r.length - 1, i = r[n];
  let s = window;
  for (let a = 0; a < n; a++)
    if (s = s[r[a]], !s)
      return;
  s[i](...e);
};
function zl(t, e) {
  return t && e ? Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) : 0;
}
function GT(t) {
  let e, r = 0;
  t.forEach((s) => {
    r += zl(s, e), e = s;
  });
  let n = r / 2, i;
  return e = void 0, t.forEach((s) => {
    if (e && !i) {
      const a = zl(s, e);
      if (a < n)
        n -= a;
      else {
        const o = n / a;
        o <= 0 && (i = e), o >= 1 && (i = { x: s.x, y: s.y }), o > 0 && o < 1 && (i = {
          x: (1 - o) * e.x + o * s.x,
          y: (1 - o) * e.y + o * s.y
        });
      }
    }
    e = s;
  }), i;
}
function qT(t) {
  return t.length === 1 ? t[0] : GT(t);
}
const $T = (t, e, r) => {
  let n;
  B.info(`our points ${JSON.stringify(e)}`), e[0] !== r && (e = e.reverse());
  let s = 25, a;
  n = void 0, e.forEach((h) => {
    if (n && !a) {
      const f = zl(h, n);
      if (f < s)
        s -= f;
      else {
        const d = s / f;
        d <= 0 && (a = n), d >= 1 && (a = { x: h.x, y: h.y }), d > 0 && d < 1 && (a = {
          x: (1 - d) * n.x + d * h.x,
          y: (1 - d) * n.y + d * h.y
        });
      }
    }
    n = h;
  });
  const o = t ? 10 : 5, l = Math.atan2(e[0].y - a.y, e[0].x - a.x), u = { x: 0, y: 0 };
  return u.x = Math.sin(l) * o + (e[0].x + a.x) / 2, u.y = -Math.cos(l) * o + (e[0].y + a.y) / 2, u;
};
function jT(t, e, r) {
  let n = JSON.parse(JSON.stringify(r)), i;
  B.info("our points", n), e !== "start_left" && e !== "start_right" && (n = n.reverse()), n.forEach((f) => {
    i = f;
  });
  let a = 25 + t, o;
  i = void 0, n.forEach((f) => {
    if (i && !o) {
      const d = zl(f, i);
      if (d < a)
        a -= d;
      else {
        const p = a / d;
        p <= 0 && (o = i), p >= 1 && (o = { x: f.x, y: f.y }), p > 0 && p < 1 && (o = {
          x: (1 - p) * i.x + p * f.x,
          y: (1 - p) * i.y + p * f.y
        });
      }
    }
    i = f;
  });
  const l = 10 + t * 0.5, u = Math.atan2(n[0].y - o.y, n[0].x - o.x), h = { x: 0, y: 0 };
  return h.x = Math.sin(u) * l + (n[0].x + o.x) / 2, h.y = -Math.cos(u) * l + (n[0].y + o.y) / 2, e === "start_left" && (h.x = Math.sin(u + Math.PI) * l + (n[0].x + o.x) / 2, h.y = -Math.cos(u + Math.PI) * l + (n[0].y + o.y) / 2), e === "end_right" && (h.x = Math.sin(u - Math.PI) * l + (n[0].x + o.x) / 2 - 5, h.y = -Math.cos(u - Math.PI) * l + (n[0].y + o.y) / 2 - 5), e === "end_left" && (h.x = Math.sin(u) * l + (n[0].x + o.x) / 2 - 5, h.y = -Math.cos(u) * l + (n[0].y + o.y) / 2 - 5), h;
}
function yi(t) {
  let e = "", r = "";
  for (const n of t)
    n !== void 0 && (n.startsWith("color:") || n.startsWith("text-align:") ? r = r + n + ";" : e = e + n + ";");
  return { style: e, labelStyle: r };
}
let gd = 0;
const Vg = () => (gd++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + gd);
function XT(t) {
  let e = "";
  const r = "0123456789abcdef", n = r.length;
  for (let i = 0; i < t; i++)
    e += r.charAt(Math.floor(Math.random() * n));
  return e;
}
const Yg = (t) => XT(t.length), KT = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: "start",
    style: "#666",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: void 0
  };
}, ZT = function(t, e) {
  const r = e.text.replace(Xt.lineBreakRegex, " "), [, n] = ho(e.fontSize), i = t.append("text");
  i.attr("x", e.x), i.attr("y", e.y), i.style("text-anchor", e.anchor), i.style("font-family", e.fontFamily), i.style("font-size", n), i.style("font-weight", e.fontWeight), i.attr("fill", e.fill), e.class !== void 0 && i.attr("class", e.class);
  const s = i.append("tspan");
  return s.attr("x", e.x + e.textMargin * 2), s.attr("fill", e.fill), s.text(r), i;
}, zg = Ks(
  (t, e, r) => {
    if (!t || (r = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
      r
    ), Xt.lineBreakRegex.test(t)))
      return t;
    const n = t.split(" "), i = [];
    let s = "";
    return n.forEach((a, o) => {
      const l = vn(`${a} `, r), u = vn(s, r);
      if (l > e) {
        const { hyphenatedStrings: d, remainingWord: p } = QT(a, e, "-", r);
        i.push(s, ...d), s = p;
      } else
        u + l >= e ? (i.push(s), s = a) : s = [s, a].filter(Boolean).join(" ");
      o + 1 === n.length && i.push(s);
    }), i.filter((a) => a !== "").join(r.joinWith);
  },
  (t, e, r) => `${t}${e}${r.fontSize}${r.fontWeight}${r.fontFamily}${r.joinWith}`
), QT = Ks(
  (t, e, r = "-", n) => {
    n = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
      n
    );
    const i = [...t], s = [];
    let a = "";
    return i.forEach((o, l) => {
      const u = `${a}${o}`;
      if (vn(u, n) >= e) {
        const f = l + 1, d = i.length === f, p = `${u}${r}`;
        s.push(d ? u : p), a = "";
      } else
        a = u;
    }), { hyphenatedStrings: s, remainingWord: a };
  },
  (t, e, r = "-", n) => `${t}${e}${r}${n.fontSize}${n.fontWeight}${n.fontFamily}`
);
function Ch(t, e) {
  return e = Object.assign(
    { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 15 },
    e
  ), J1(t, e).height;
}
function vn(t, e) {
  return e = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: "Arial" }, e), J1(t, e).width;
}
const J1 = Ks(
  (t, e) => {
    e = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: "Arial" }, e);
    const { fontSize: r, fontFamily: n, fontWeight: i } = e;
    if (!t)
      return { width: 0, height: 0 };
    const [, s] = ho(r), a = ["sans-serif", n], o = t.split(Xt.lineBreakRegex), l = [], u = _t("body");
    if (!u.remove)
      return { width: 0, height: 0, lineHeight: 0 };
    const h = u.append("svg");
    for (const d of a) {
      let p = 0;
      const m = { width: 0, height: 0, lineHeight: 0 };
      for (const _ of o) {
        const v = KT();
        v.text = _;
        const k = ZT(h, v).style("font-size", s).style("font-weight", i).style("font-family", d), x = (k._groups || k)[0][0].getBBox();
        m.width = Math.round(Math.max(m.width, x.width)), p = Math.round(x.height), m.height += p, m.lineHeight = Math.round(Math.max(m.lineHeight, p));
      }
      l.push(m);
    }
    h.remove();
    const f = isNaN(l[1].height) || isNaN(l[1].width) || isNaN(l[1].lineHeight) || l[0].height > l[1].height && l[0].width > l[1].width && l[0].lineHeight > l[1].lineHeight ? 0 : 1;
    return l[f];
  },
  (t, e) => `${t}${e.fontSize}${e.fontWeight}${e.fontFamily}`
), JT = class {
  constructor(e, r) {
    this.deterministic = e, this.seed = r, this.count = r ? r.length : 0;
  }
  next() {
    return this.deterministic ? this.count++ : Date.now();
  }
};
let Po;
const tE = function(t) {
  return Po = Po || document.createElement("div"), t = escape(t).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";"), Po.innerHTML = t, unescape(Po.textContent);
}, Yi = (t) => {
  if (B.debug("directiveSanitizer called with", t), typeof t == "object" && (t.length ? t.forEach((e) => Yi(e)) : Object.keys(t).forEach((e) => {
    B.debug("Checking key", e), e.startsWith("__") && (B.debug("sanitize deleting __ option", e), delete t[e]), e.includes("proto") && (B.debug("sanitize deleting proto option", e), delete t[e]), e.includes("constr") && (B.debug("sanitize deleting constr option", e), delete t[e]), e.includes("themeCSS") && (B.debug("sanitizing themeCss option"), t[e] = rl(t[e])), e.includes("fontFamily") && (B.debug("sanitizing fontFamily option"), t[e] = rl(t[e])), e.includes("altFontFamily") && (B.debug("sanitizing altFontFamily option"), t[e] = rl(t[e])), U8.includes(e) ? typeof t[e] == "object" && (B.debug("sanitize deleting object", e), Yi(t[e])) : (B.debug("sanitize deleting option", e), delete t[e]);
  })), t.themeVariables) {
    const e = Object.keys(t.themeVariables);
    for (const r of e) {
      const n = t.themeVariables[r];
      n && n.match && !n.match(/^[\d "#%(),.;A-Za-z]+$/) && (t.themeVariables[r] = "");
    }
  }
  B.debug("After sanitization", t);
}, rl = (t) => {
  let e = 0, r = 0;
  for (const n of t) {
    if (e < r)
      return "{ /* ERROR: Unbalanced CSS */ }";
    n === "{" ? e++ : n === "}" && r++;
  }
  return e !== r ? "{ /* ERROR: Unbalanced CSS */ }" : t;
};
function t0(t) {
  return "str" in t;
}
function eE(t) {
  return t instanceof Error ? t.message : String(t);
}
const rE = (t, e, r, n) => {
  if (!n)
    return;
  const i = t.node().getBBox();
  t.append("text").text(n).attr("x", i.x + i.width / 2).attr("y", -r).attr("class", e);
}, ho = (t) => {
  if (typeof t == "number")
    return [t, t + "px"];
  const e = parseInt(t, 10);
  return Number.isNaN(e) ? [void 0, void 0] : t === String(e) ? [e, t + "px"] : [e, t];
}, jt = {
  assignWithDepth: Xe,
  wrapLabel: zg,
  calculateTextHeight: Ch,
  calculateTextWidth: vn,
  calculateTextDimensions: J1,
  detectInit: zT,
  detectDirective: Pg,
  isSubstringInArray: UT,
  interpolateToCurve: Qr,
  calcLabelPosition: qT,
  calcCardinalityPosition: $T,
  calcTerminalLabelPosition: jT,
  formatUrl: WT,
  getStylesFromArray: yi,
  generateId: Vg,
  random: Yg,
  runFunc: HT,
  entityDecode: tE,
  initIdGenerator: JT,
  directiveSanitizer: Yi,
  sanitizeCss: rl,
  insertTitle: rE,
  parseFontSize: ho
};
var Ug = "comm", Wg = "rule", Hg = "decl", nE = "@import", iE = "@keyframes", sE = Math.abs, e0 = String.fromCharCode;
function Gg(t) {
  return t.trim();
}
function Sh(t, e, r) {
  return t.replace(e, r);
}
function aE(t, e) {
  return t.indexOf(e);
}
function Mc(t, e) {
  return t.charCodeAt(e) | 0;
}
function Wa(t, e, r) {
  return t.slice(e, r);
}
function si(t) {
  return t.length;
}
function qg(t) {
  return t.length;
}
function Vo(t, e) {
  return e.push(t), t;
}
var Nc = 1, Rs = 1, $g = 0, Hr = 0, Ne = 0, Zs = "";
function r0(t, e, r, n, i, s, a) {
  return { value: t, root: e, parent: r, type: n, props: i, children: s, line: Nc, column: Rs, length: a, return: "" };
}
function oE() {
  return Ne;
}
function lE() {
  return Ne = Hr > 0 ? Mc(Zs, --Hr) : 0, Rs--, Ne === 10 && (Rs = 1, Nc--), Ne;
}
function Jr() {
  return Ne = Hr < $g ? Mc(Zs, Hr++) : 0, Rs++, Ne === 10 && (Rs = 1, Nc++), Ne;
}
function Ni() {
  return Mc(Zs, Hr);
}
function nl() {
  return Hr;
}
function Rc(t, e) {
  return Wa(Zs, t, e);
}
function Ah(t) {
  switch (t) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function cE(t) {
  return Nc = Rs = 1, $g = si(Zs = t), Hr = 0, [];
}
function uE(t) {
  return Zs = "", t;
}
function Pu(t) {
  return Gg(Rc(Hr - 1, Lh(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function hE(t) {
  for (; (Ne = Ni()) && Ne < 33; )
    Jr();
  return Ah(t) > 2 || Ah(Ne) > 3 ? "" : " ";
}
function fE(t, e) {
  for (; --e && Jr() && !(Ne < 48 || Ne > 102 || Ne > 57 && Ne < 65 || Ne > 70 && Ne < 97); )
    ;
  return Rc(t, nl() + (e < 6 && Ni() == 32 && Jr() == 32));
}
function Lh(t) {
  for (; Jr(); )
    switch (Ne) {
      case t:
        return Hr;
      case 34:
      case 39:
        t !== 34 && t !== 39 && Lh(Ne);
        break;
      case 40:
        t === 41 && Lh(t);
        break;
      case 92:
        Jr();
        break;
    }
  return Hr;
}
function dE(t, e) {
  for (; Jr() && t + Ne !== 47 + 10; )
    if (t + Ne === 42 + 42 && Ni() === 47)
      break;
  return "/*" + Rc(e, Hr - 1) + "*" + e0(t === 47 ? t : Jr());
}
function pE(t) {
  for (; !Ah(Ni()); )
    Jr();
  return Rc(t, Hr);
}
function gE(t) {
  return uE(il("", null, null, null, [""], t = cE(t), 0, [0], t));
}
function il(t, e, r, n, i, s, a, o, l) {
  for (var u = 0, h = 0, f = a, d = 0, p = 0, m = 0, _ = 1, v = 1, k = 1, x = 0, D = "", F = i, P = s, V = n, R = D; v; )
    switch (m = x, x = Jr()) {
      case 40:
        if (m != 108 && Mc(R, f - 1) == 58) {
          aE(R += Sh(Pu(x), "&", "&\f"), "&\f") != -1 && (k = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        R += Pu(x);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        R += hE(m);
        break;
      case 92:
        R += fE(nl() - 1, 7);
        continue;
      case 47:
        switch (Ni()) {
          case 42:
          case 47:
            Vo(yE(dE(Jr(), nl()), e, r), l);
            break;
          default:
            R += "/";
        }
        break;
      case 123 * _:
        o[u++] = si(R) * k;
      case 125 * _:
      case 59:
      case 0:
        switch (x) {
          case 0:
          case 125:
            v = 0;
          case 59 + h:
            p > 0 && si(R) - f && Vo(p > 32 ? md(R + ";", n, r, f - 1) : md(Sh(R, " ", "") + ";", n, r, f - 2), l);
            break;
          case 59:
            R += ";";
          default:
            if (Vo(V = yd(R, e, r, u, h, i, o, D, F = [], P = [], f), s), x === 123)
              if (h === 0)
                il(R, e, V, V, F, s, f, o, P);
              else
                switch (d) {
                  case 100:
                  case 109:
                  case 115:
                    il(t, V, V, n && Vo(yd(t, V, V, 0, 0, i, o, D, i, F = [], f), P), i, P, f, o, n ? F : P);
                    break;
                  default:
                    il(R, V, V, V, [""], P, 0, o, P);
                }
        }
        u = h = p = 0, _ = k = 1, D = R = "", f = a;
        break;
      case 58:
        f = 1 + si(R), p = m;
      default:
        if (_ < 1) {
          if (x == 123)
            --_;
          else if (x == 125 && _++ == 0 && lE() == 125)
            continue;
        }
        switch (R += e0(x), x * _) {
          case 38:
            k = h > 0 ? 1 : (R += "\f", -1);
            break;
          case 44:
            o[u++] = (si(R) - 1) * k, k = 1;
            break;
          case 64:
            Ni() === 45 && (R += Pu(Jr())), d = Ni(), h = f = si(D = R += pE(nl())), x++;
            break;
          case 45:
            m === 45 && si(R) == 2 && (_ = 0);
        }
    }
  return s;
}
function yd(t, e, r, n, i, s, a, o, l, u, h) {
  for (var f = i - 1, d = i === 0 ? s : [""], p = qg(d), m = 0, _ = 0, v = 0; m < n; ++m)
    for (var k = 0, x = Wa(t, f + 1, f = sE(_ = a[m])), D = t; k < p; ++k)
      (D = Gg(_ > 0 ? d[k] + " " + x : Sh(x, /&\f/g, d[k]))) && (l[v++] = D);
  return r0(t, e, r, i === 0 ? Wg : o, l, u, h);
}
function yE(t, e, r) {
  return r0(t, e, r, Ug, e0(oE()), Wa(t, 2, -2), 0);
}
function md(t, e, r, n) {
  return r0(t, e, r, Hg, Wa(t, 0, n), Wa(t, n + 1, -1), n);
}
function Bh(t, e) {
  for (var r = "", n = qg(t), i = 0; i < n; i++)
    r += e(t[i], i, t, e) || "";
  return r;
}
function mE(t, e, r, n) {
  switch (t.type) {
    case nE:
    case Hg:
      return t.return = t.return || t.value;
    case Ug:
      return "";
    case iE:
      return t.return = t.value + "{" + Bh(t.children, n) + "}";
    case Wg:
      t.value = t.props.join(",");
  }
  return si(r = Bh(t.children, n)) ? t.return = t.value + "{" + r + "}" : "";
}
const Ul = "9.4.3", Fs = Object.freeze(W8);
let br = Xe({}, Fs), jg, Os = [], Ca = Xe({}, Fs);
const Fc = (t, e) => {
  let r = Xe({}, t), n = {};
  for (const i of e)
    Zg(i), n = Xe(n, i);
  if (r = Xe(r, n), n.theme && n.theme in jn) {
    const i = Xe({}, jg), s = Xe(
      i.themeVariables || {},
      n.themeVariables
    );
    r.theme && r.theme in jn && (r.themeVariables = jn[r.theme].getThemeVariables(s));
  }
  return Ca = r, Jg(Ca), Ca;
}, bE = (t) => (br = Xe({}, Fs), br = Xe(br, t), t.theme && jn[t.theme] && (br.themeVariables = jn[t.theme].getThemeVariables(t.themeVariables)), Fc(br, Os), br), _E = (t) => {
  jg = Xe({}, t);
}, xE = (t) => (br = Xe(br, t), Fc(br, Os), br), Xg = () => Xe({}, br), Kg = (t) => (Jg(t), Xe(Ca, t), q()), q = () => Xe({}, Ca), Zg = (t) => {
  ["secure", ...br.secure ?? []].forEach((e) => {
    t[e] !== void 0 && (B.debug(`Denied attempt to modify a secure key ${e}`, t[e]), delete t[e]);
  }), Object.keys(t).forEach((e) => {
    e.indexOf("__") === 0 && delete t[e];
  }), Object.keys(t).forEach((e) => {
    typeof t[e] == "string" && (t[e].includes("<") || t[e].includes(">") || t[e].includes("url(data:")) && delete t[e], typeof t[e] == "object" && Zg(t[e]);
  });
}, n0 = (t) => {
  t.fontFamily && (t.themeVariables ? t.themeVariables.fontFamily || (t.themeVariables = { fontFamily: t.fontFamily }) : t.themeVariables = { fontFamily: t.fontFamily }), Os.push(t), Fc(br, Os);
}, Ha = (t = br) => {
  Os = [], Fc(t, Os);
};
var Qg = /* @__PURE__ */ ((t) => (t.LAZY_LOAD_DEPRECATED = "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead.", t))(Qg || {});
const bd = {}, vE = (t) => {
  bd[t] || (B.warn(Qg[t]), bd[t] = !0);
}, Jg = (t) => {
  t && (t.lazyLoadedDiagrams || t.loadExternalDiagramsAtStartup) && vE("LAZY_LOAD_DEPRECATED");
}, kE = function(t, e) {
  for (let r of e)
    t.attr(r[0], r[1]);
}, wE = function(t, e, r) {
  let n = /* @__PURE__ */ new Map();
  return r ? (n.set("width", "100%"), n.set("style", `max-width: ${e}px;`)) : (n.set("height", t), n.set("width", e)), n;
}, cn = function(t, e, r, n) {
  const i = wE(e, r, n);
  kE(t, i);
}, Oc = function(t, e, r, n) {
  const i = e.node().getBBox(), s = i.width, a = i.height;
  B.info(`SVG bounds: ${s}x${a}`, i);
  let o = 0, l = 0;
  B.info(`Graph bounds: ${o}x${l}`, t), o = s + r * 2, l = a + r * 2, B.info(`Calculated bounds: ${o}x${l}`), cn(e, l, o, n);
  const u = `${i.x - r} ${i.y - r} ${i.width + 2 * r} ${i.height + 2 * r}`;
  e.attr("viewBox", u);
}, TE = (t) => `g.classGroup text {
  fill: ${t.nodeBorder};
  fill: ${t.classText};
  stroke: none;
  font-family: ${t.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${t.classText};
}
.edgeLabel .label rect {
  fill: ${t.mainBkg};
}
.label text {
  fill: ${t.classText};
}
.edgeLabel .label span {
  background: ${t.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${t.nodeBorder};
  stroke: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${t.mainBkg};
  stroke: ${t.nodeBorder};
}

g.classGroup line {
  stroke: ${t.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${t.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${t.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${t.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

.dotted-line{
  stroke-dasharray: 1 2;
}

#compositionStart, .composition {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${t.lineColor} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: ${t.mainBkg} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: ${t.mainBkg} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: ${t.mainBkg} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: ${t.mainBkg} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${t.mainBkg} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${t.mainBkg} !important;
  stroke: ${t.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
}

.classTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${t.textColor};
}
`, Sa = TE, EE = (t) => `
  .entityBox {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
  }

  .attributeBoxOdd {
    fill: ${t.attributeBackgroundColorOdd};
    stroke: ${t.nodeBorder};
  }

  .attributeBoxEven {
    fill:  ${t.attributeBackgroundColorEven};
    stroke: ${t.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${t.tertiaryColor};
    opacity: 0.7;
    background-color: ${t.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

    .relationshipLine {
      stroke: ${t.lineColor};
    }

  .entityTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor};
  }    
`, ty = EE, CE = () => "", Dh = CE, SE = (t) => `.label {
    font-family: ${t.fontFamily};
    color: ${t.nodeTextColor || t.textColor};
  }
  .cluster-label text {
    fill: ${t.titleColor};
  }
  .cluster-label span {
    color: ${t.titleColor};
  }

  .label text,span {
    fill: ${t.nodeTextColor || t.textColor};
    color: ${t.nodeTextColor || t.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${t.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${t.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${t.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${t.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${t.edgeLabelBackground};
      fill: ${t.edgeLabelBackground};
    }
    text-align: center;
  }

  .cluster rect {
    fill: ${t.clusterBkg};
    stroke: ${t.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${t.titleColor};
  }

  .cluster span {
    color: ${t.titleColor};
  }
  /* .cluster div {
    color: ${t.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${t.fontFamily};
    font-size: 12px;
    background: ${t.tertiaryColor};
    border: 1px solid ${t.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor};
  }
`, Wl = SE, AE = (t) => `
  .mermaid-main-font {
    font-family: "trebuchet ms", verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  .exclude-range {
    fill: ${t.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${t.sectionBkgColor};
  }

  .section2 {
    fill: ${t.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${t.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${t.titleColor};
  }

  .sectionTitle1 {
    fill: ${t.titleColor};
  }

  .sectionTitle2 {
    fill: ${t.titleColor};
  }

  .sectionTitle3 {
    fill: ${t.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    // font-size: ${t.ganttFontSize};
    // text-height: 14px;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);

  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${t.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
    text {
      font-family: ${t.fontFamily};
      fill: ${t.textColor};
    }
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${t.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }

  // .taskText:not([font-size]) {
  //   font-size: ${t.ganttFontSize};
  // }

  .taskTextOutsideRight {
    fill: ${t.taskTextDarkColor};
    text-anchor: start;
    // font-size: ${t.ganttFontSize};
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);

  }

  .taskTextOutsideLeft {
    fill: ${t.taskTextDarkColor};
    text-anchor: end;
    // font-size: ${t.ganttFontSize};
  }

  /* Special case clickable */
  .task.clickable {
    cursor: pointer;
  }
  .taskText.clickable {
    cursor: pointer;
    fill: ${t.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${t.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${t.taskTextClickableColor} !important;
    font-weight: bold;
  }

  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${t.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${t.taskBkgColor};
    stroke: ${t.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${t.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${t.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${t.activeTaskBkgColor};
    stroke: ${t.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${t.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${t.doneTaskBorderColor};
    fill: ${t.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${t.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${t.critBorderColor};
    fill: ${t.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${t.critBorderColor};
    fill: ${t.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${t.critBorderColor};
    fill: ${t.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${t.taskTextDarkColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${t.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor}    ;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
`, ey = AE, LE = () => "", ry = LE, BE = (t) => `
  .pieCircle{
    stroke: ${t.pieStrokeColor};
    stroke-width : ${t.pieStrokeWidth};
    opacity : ${t.pieOpacity};
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${t.pieTitleTextSize};
    fill: ${t.pieTitleTextColor};
    font-family: ${t.fontFamily};
  }
  .slice {
    font-family: ${t.fontFamily};
    fill: ${t.pieSectionTextColor};
    font-size:${t.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${t.pieLegendTextColor};
    font-family: ${t.fontFamily};
    font-size: ${t.pieLegendTextSize};
  }
`, ny = BE, DE = (t) => `

  marker {
    fill: ${t.relationColor};
    stroke: ${t.relationColor};
  }

  marker.cross {
    stroke: ${t.lineColor};
  }

  svg {
    font-family: ${t.fontFamily};
    font-size: ${t.fontSize};
  }

  .reqBox {
    fill: ${t.requirementBackground};
    fill-opacity: 100%;
    stroke: ${t.requirementBorderColor};
    stroke-width: ${t.requirementBorderSize};
  }
  
  .reqTitle, .reqLabel{
    fill:  ${t.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${t.relationLabelBackground};
    fill-opacity: 100%;
  }

  .req-title-line {
    stroke: ${t.requirementBorderColor};
    stroke-width: ${t.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${t.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${t.relationLabelColor};
  }

`, iy = DE, IE = (t) => `.actor {
    stroke: ${t.actorBorder};
    fill: ${t.actorBkg};
  }

  text.actor > tspan {
    fill: ${t.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${t.actorLineColor};
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${t.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${t.signalColor};
  }

  #arrowhead path {
    fill: ${t.signalColor};
    stroke: ${t.signalColor};
  }

  .sequenceNumber {
    fill: ${t.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${t.signalColor};
  }

  #crosshead path {
    fill: ${t.signalColor};
    stroke: ${t.signalColor};
  }

  .messageText {
    fill: ${t.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${t.labelBoxBorderColor};
    fill: ${t.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${t.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${t.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${t.labelBoxBorderColor};
    fill: ${t.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${t.noteBorderColor};
    fill: ${t.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${t.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${t.activationBkgColor};
    stroke: ${t.activationBorderColor};
  }

  .activation1 {
    fill: ${t.activationBkgColor};
    stroke: ${t.activationBorderColor};
  }

  .activation2 {
    fill: ${t.activationBkgColor};
    stroke: ${t.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${t.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${t.actorBorder};
    fill: ${t.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${t.actorBorder};
    fill: ${t.actorBkg};
    stroke-width: 2px;
  }
`, sy = IE, ME = (t) => `
defs #statediagram-barbEnd {
    fill: ${t.transitionColor};
    stroke: ${t.transitionColor};
  }
g.stateGroup text {
  fill: ${t.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${t.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${t.stateLabelColor};
}

g.stateGroup rect {
  fill: ${t.mainBkg};
  stroke: ${t.nodeBorder};
}

g.stateGroup line {
  stroke: ${t.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${t.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${t.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${t.noteBorderColor};
  fill: ${t.noteBkgColor};

  text {
    fill: ${t.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${t.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${t.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel .label text {
  fill: ${t.transitionLabelColor || t.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${t.transitionLabelColor || t.tertiaryTextColor};
}

.stateLabel text {
  fill: ${t.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${t.specialStateColor};
  stroke: ${t.specialStateColor};
}

.node .fork-join {
  fill: ${t.specialStateColor};
  stroke: ${t.specialStateColor};
}

.node circle.state-end {
  fill: ${t.innerEndBackground};
  stroke: ${t.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${t.compositeBackground || t.background};
  // stroke: ${t.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${t.stateBkg || t.mainBkg};
  stroke: ${t.stateBorder || t.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${t.mainBkg};
  stroke: ${t.stateBorder || t.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${t.lineColor};
}

.statediagram-cluster rect {
  fill: ${t.compositeTitleBackground};
  stroke: ${t.stateBorder || t.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${t.stateLabelColor};
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${t.stateBorder || t.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${t.compositeBackground || t.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${t.altBackground ? t.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${t.altBackground ? t.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${t.noteBkgColor};
  stroke: ${t.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${t.noteBkgColor};
  stroke: ${t.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${t.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${t.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${t.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${t.lineColor};
  stroke: ${t.lineColor};
  stroke-width: 1;
}

.statediagramTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${t.textColor};
}
`, Hl = ME, NE = (t) => `.label {
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
    color: ${t.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${t.textColor}
  }

  .legend {
    fill: ${t.textColor};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${t.textColor}
  }

  .face {
    ${t.faceColor ? `fill: ${t.faceColor}` : "fill: #FFF8DC"};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${t.mainBkg};
    stroke: ${t.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${t.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${t.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${t.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${t.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${t.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
    font-size: 12px;
    background: ${t.tertiaryColor};
    border: 1px solid ${t.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${t.fillType0 ? `fill: ${t.fillType0}` : ""};
  }
  .task-type-1, .section-type-1  {
    ${t.fillType0 ? `fill: ${t.fillType1}` : ""};
  }
  .task-type-2, .section-type-2  {
    ${t.fillType0 ? `fill: ${t.fillType2}` : ""};
  }
  .task-type-3, .section-type-3  {
    ${t.fillType0 ? `fill: ${t.fillType3}` : ""};
  }
  .task-type-4, .section-type-4  {
    ${t.fillType0 ? `fill: ${t.fillType4}` : ""};
  }
  .task-type-5, .section-type-5  {
    ${t.fillType0 ? `fill: ${t.fillType5}` : ""};
  }
  .task-type-6, .section-type-6  {
    ${t.fillType0 ? `fill: ${t.fillType6}` : ""};
  }
  .task-type-7, .section-type-7  {
    ${t.fillType0 ? `fill: ${t.fillType7}` : ""};
  }

  .actor-0 {
    ${t.actor0 ? `fill: ${t.actor0}` : ""};
  }
  .actor-1 {
    ${t.actor1 ? `fill: ${t.actor1}` : ""};
  }
  .actor-2 {
    ${t.actor2 ? `fill: ${t.actor2}` : ""};
  }
  .actor-3 {
    ${t.actor3 ? `fill: ${t.actor3}` : ""};
  }
  .actor-4 {
    ${t.actor4 ? `fill: ${t.actor4}` : ""};
  }
  .actor-5 {
    ${t.actor5 ? `fill: ${t.actor5}` : ""};
  }
`, ay = NE, RE = (t) => `.person {
    stroke: ${t.personBorder};
    fill: ${t.personBkg};
  }
`, oy = RE, sl = {
  flowchart: Wl,
  "flowchart-v2": Wl,
  sequence: sy,
  gantt: ey,
  classDiagram: Sa,
  "classDiagram-v2": Sa,
  class: Sa,
  stateDiagram: Hl,
  state: Hl,
  // gitGraph,
  info: ry,
  pie: ny,
  er: ty,
  error: Dh,
  journey: ay,
  requirement: iy,
  c4: oy
}, FE = (t, e, r) => {
  let n = "";
  return t in sl && sl[t] ? n = sl[t](r) : B.warn(`No theme found for ${t}`), ` & {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
    fill: ${r.textColor}
  }

  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${r.errorBkgColor};
  }
  & .error-text {
    fill: ${r.errorTextColor};
    stroke: ${r.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 2px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }

  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${r.lineColor};
    stroke: ${r.lineColor};
  }
  & .marker.cross {
    stroke: ${r.lineColor};
  }

  & svg {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
  }

  ${n}

  ${e}
`;
}, OE = (t, e) => {
  sl[t] = e;
}, PE = FE;
let i0 = "", Pc = "", s0 = "";
const a0 = (t) => Ur(t, q()), Br = function() {
  i0 = "", s0 = "", Pc = "";
}, Tr = function(t) {
  i0 = a0(t).replace(/^\s+/g, "");
}, Dr = function() {
  return i0 || Pc;
}, Ir = function(t) {
  s0 = a0(t).replace(/\n\s+/g, `
`);
}, Mr = function() {
  return s0;
}, un = function(t) {
  Pc = a0(t);
}, hn = function() {
  return Pc;
}, VE = {
  setAccTitle: Tr,
  getAccTitle: Dr,
  setDiagramTitle: un,
  getDiagramTitle: hn,
  getAccDescription: Mr,
  setAccDescription: Ir,
  clear: Br
}, YE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clear: Br,
  default: VE,
  getAccDescription: Mr,
  getAccTitle: Dr,
  getDiagramTitle: hn,
  setAccDescription: Ir,
  setAccTitle: Tr,
  setDiagramTitle: un
}, Symbol.toStringTag, { value: "Module" }));
let Ei = {};
const ly = function(t, e, r, n) {
  B.debug("parseDirective is being called", e, r, n);
  try {
    if (e !== void 0)
      switch (e = e.trim(), r) {
        case "open_directive":
          Ei = {};
          break;
        case "type_directive":
          if (!Ei)
            throw new Error("currentDirective is undefined");
          Ei.type = e.toLowerCase();
          break;
        case "arg_directive":
          if (!Ei)
            throw new Error("currentDirective is undefined");
          Ei.args = JSON.parse(e);
          break;
        case "close_directive":
          zE(t, Ei, n), Ei = void 0;
          break;
      }
  } catch (i) {
    B.error(
      `Error while rendering sequenceDiagram directive: ${e} jison context: ${r}`
    ), B.error(i.message);
  }
}, zE = function(t, e, r) {
  switch (B.info(`Directive type=${e.type} with args:`, e.args), e.type) {
    case "init":
    case "initialize": {
      ["config"].forEach((n) => {
        e.args[n] !== void 0 && (r === "flowchart-v2" && (r = "flowchart"), e.args[r] = e.args[n], delete e.args[n]);
      }), B.info("sanitize in handleDirective", e.args), Yi(e.args), B.info("sanitize in handleDirective (done)", e.args), n0(e.args);
      break;
    }
    case "wrap":
    case "nowrap":
      t && t.setWrap && t.setWrap(e.type === "wrap");
      break;
    case "themeCss":
      B.warn("themeCss encountered");
      break;
    default:
      B.warn(
        `Unhandled directive: source: '%%{${e.type}: ${JSON.stringify(
          e.args ? e.args : {}
        )}}%%`,
        e
      );
      break;
  }
}, UE = B, WE = C1, fo = q, HE = (t) => Ur(t, fo()), cy = Oc, GE = () => YE, qE = (t, e, r, n) => ly(t, e, r, n), Gl = {}, ze = (t, e, r) => {
  if (Gl[t])
    throw new Error(`Diagram ${t} already registered.`);
  Gl[t] = e, r && Rg(t, r), OE(t, e.styles), e.injectUtils && e.injectUtils(
    UE,
    WE,
    fo,
    HE,
    cy,
    GE(),
    qE
  );
}, uy = (t) => {
  if (t in Gl)
    return Gl[t];
  throw new Error(`Diagram ${t} not found.`);
};
var Ih = function() {
  var t = function(O, C, S, T) {
    for (S = S || {}, T = O.length; T--; S[O[T]] = C)
      ;
    return S;
  }, e = [1, 4], r = [1, 7], n = [1, 5], i = [1, 9], s = [1, 6], a = [2, 6], o = [1, 16], l = [6, 8, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40, 50, 55], u = [8, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40], h = [8, 13, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40], f = [1, 26], d = [6, 8, 14, 50, 55], p = [8, 14, 55], m = [1, 53], _ = [1, 52], v = [8, 14, 30, 33, 35, 38, 55], k = [1, 67], x = [1, 68], D = [1, 69], F = [8, 14, 33, 35, 42, 55], P = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, eol: 4, directive: 5, GG: 6, document: 7, EOF: 8, ":": 9, DIR: 10, options: 11, body: 12, OPT: 13, NL: 14, line: 15, statement: 16, commitStatement: 17, mergeStatement: 18, cherryPickStatement: 19, acc_title: 20, acc_title_value: 21, acc_descr: 22, acc_descr_value: 23, acc_descr_multiline_value: 24, section: 25, branchStatement: 26, CHECKOUT: 27, ref: 28, BRANCH: 29, ORDER: 30, NUM: 31, CHERRY_PICK: 32, COMMIT_ID: 33, STR: 34, COMMIT_TAG: 35, EMPTYSTR: 36, MERGE: 37, COMMIT_TYPE: 38, commitType: 39, COMMIT: 40, commit_arg: 41, COMMIT_MSG: 42, NORMAL: 43, REVERSE: 44, HIGHLIGHT: 45, openDirective: 46, typeDirective: 47, closeDirective: 48, argDirective: 49, open_directive: 50, type_directive: 51, arg_directive: 52, close_directive: 53, ID: 54, ";": 55, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "GG", 8: "EOF", 9: ":", 10: "DIR", 13: "OPT", 14: "NL", 20: "acc_title", 21: "acc_title_value", 22: "acc_descr", 23: "acc_descr_value", 24: "acc_descr_multiline_value", 25: "section", 27: "CHECKOUT", 29: "BRANCH", 30: "ORDER", 31: "NUM", 32: "CHERRY_PICK", 33: "COMMIT_ID", 34: "STR", 35: "COMMIT_TAG", 36: "EMPTYSTR", 37: "MERGE", 38: "COMMIT_TYPE", 40: "COMMIT", 42: "COMMIT_MSG", 43: "NORMAL", 44: "REVERSE", 45: "HIGHLIGHT", 50: "open_directive", 51: "type_directive", 52: "arg_directive", 53: "close_directive", 54: "ID", 55: ";" },
    productions_: [0, [3, 2], [3, 2], [3, 3], [3, 4], [3, 5], [7, 0], [7, 2], [11, 2], [11, 1], [12, 0], [12, 2], [15, 2], [15, 1], [16, 1], [16, 1], [16, 1], [16, 2], [16, 2], [16, 1], [16, 1], [16, 1], [16, 2], [26, 2], [26, 4], [19, 3], [19, 5], [19, 5], [19, 5], [19, 5], [18, 2], [18, 4], [18, 4], [18, 4], [18, 6], [18, 6], [18, 6], [18, 6], [18, 6], [18, 6], [18, 8], [18, 8], [18, 8], [18, 8], [18, 8], [18, 8], [17, 2], [17, 3], [17, 3], [17, 5], [17, 5], [17, 3], [17, 5], [17, 5], [17, 5], [17, 5], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 3], [17, 5], [17, 5], [17, 5], [17, 5], [17, 5], [17, 5], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [41, 0], [41, 1], [39, 1], [39, 1], [39, 1], [5, 3], [5, 5], [46, 1], [47, 1], [49, 1], [48, 1], [28, 1], [28, 1], [4, 1], [4, 1], [4, 1]],
    performAction: function(C, S, T, b, w, g, M) {
      var y = g.length - 1;
      switch (w) {
        case 3:
          return g[y];
        case 4:
          return g[y - 1];
        case 5:
          return b.setDirection(g[y - 3]), g[y - 1];
        case 7:
          b.setOptions(g[y - 1]), this.$ = g[y];
          break;
        case 8:
          g[y - 1] += g[y], this.$ = g[y - 1];
          break;
        case 10:
          this.$ = [];
          break;
        case 11:
          g[y - 1].push(g[y]), this.$ = g[y - 1];
          break;
        case 12:
          this.$ = g[y - 1];
          break;
        case 17:
          this.$ = g[y].trim(), b.setAccTitle(this.$);
          break;
        case 18:
        case 19:
          this.$ = g[y].trim(), b.setAccDescription(this.$);
          break;
        case 20:
          b.addSection(g[y].substr(8)), this.$ = g[y].substr(8);
          break;
        case 22:
          b.checkout(g[y]);
          break;
        case 23:
          b.branch(g[y]);
          break;
        case 24:
          b.branch(g[y - 2], g[y]);
          break;
        case 25:
          b.cherryPick(g[y], "", void 0);
          break;
        case 26:
          b.cherryPick(g[y - 2], "", g[y]);
          break;
        case 27:
        case 29:
          b.cherryPick(g[y - 2], "", "");
          break;
        case 28:
          b.cherryPick(g[y], "", g[y - 2]);
          break;
        case 30:
          b.merge(g[y], "", "", "");
          break;
        case 31:
          b.merge(g[y - 2], g[y], "", "");
          break;
        case 32:
          b.merge(g[y - 2], "", g[y], "");
          break;
        case 33:
          b.merge(g[y - 2], "", "", g[y]);
          break;
        case 34:
          b.merge(g[y - 4], g[y], "", g[y - 2]);
          break;
        case 35:
          b.merge(g[y - 4], "", g[y], g[y - 2]);
          break;
        case 36:
          b.merge(g[y - 4], "", g[y - 2], g[y]);
          break;
        case 37:
          b.merge(g[y - 4], g[y - 2], g[y], "");
          break;
        case 38:
          b.merge(g[y - 4], g[y - 2], "", g[y]);
          break;
        case 39:
          b.merge(g[y - 4], g[y], g[y - 2], "");
          break;
        case 40:
          b.merge(g[y - 6], g[y - 4], g[y - 2], g[y]);
          break;
        case 41:
          b.merge(g[y - 6], g[y], g[y - 4], g[y - 2]);
          break;
        case 42:
          b.merge(g[y - 6], g[y - 4], g[y], g[y - 2]);
          break;
        case 43:
          b.merge(g[y - 6], g[y - 2], g[y - 4], g[y]);
          break;
        case 44:
          b.merge(g[y - 6], g[y], g[y - 2], g[y - 4]);
          break;
        case 45:
          b.merge(g[y - 6], g[y - 2], g[y], g[y - 4]);
          break;
        case 46:
          b.commit(g[y]);
          break;
        case 47:
          b.commit("", "", b.commitType.NORMAL, g[y]);
          break;
        case 48:
          b.commit("", "", g[y], "");
          break;
        case 49:
          b.commit("", "", g[y], g[y - 2]);
          break;
        case 50:
          b.commit("", "", g[y - 2], g[y]);
          break;
        case 51:
          b.commit("", g[y], b.commitType.NORMAL, "");
          break;
        case 52:
          b.commit("", g[y - 2], b.commitType.NORMAL, g[y]);
          break;
        case 53:
          b.commit("", g[y], b.commitType.NORMAL, g[y - 2]);
          break;
        case 54:
          b.commit("", g[y - 2], g[y], "");
          break;
        case 55:
          b.commit("", g[y], g[y - 2], "");
          break;
        case 56:
          b.commit("", g[y - 4], g[y - 2], g[y]);
          break;
        case 57:
          b.commit("", g[y - 4], g[y], g[y - 2]);
          break;
        case 58:
          b.commit("", g[y - 2], g[y - 4], g[y]);
          break;
        case 59:
          b.commit("", g[y], g[y - 4], g[y - 2]);
          break;
        case 60:
          b.commit("", g[y], g[y - 2], g[y - 4]);
          break;
        case 61:
          b.commit("", g[y - 2], g[y], g[y - 4]);
          break;
        case 62:
          b.commit(g[y], "", b.commitType.NORMAL, "");
          break;
        case 63:
          b.commit(g[y], "", b.commitType.NORMAL, g[y - 2]);
          break;
        case 64:
          b.commit(g[y - 2], "", b.commitType.NORMAL, g[y]);
          break;
        case 65:
          b.commit(g[y - 2], "", g[y], "");
          break;
        case 66:
          b.commit(g[y], "", g[y - 2], "");
          break;
        case 67:
          b.commit(g[y], g[y - 2], b.commitType.NORMAL, "");
          break;
        case 68:
          b.commit(g[y - 2], g[y], b.commitType.NORMAL, "");
          break;
        case 69:
          b.commit(g[y - 4], "", g[y - 2], g[y]);
          break;
        case 70:
          b.commit(g[y - 4], "", g[y], g[y - 2]);
          break;
        case 71:
          b.commit(g[y - 2], "", g[y - 4], g[y]);
          break;
        case 72:
          b.commit(g[y], "", g[y - 4], g[y - 2]);
          break;
        case 73:
          b.commit(g[y], "", g[y - 2], g[y - 4]);
          break;
        case 74:
          b.commit(g[y - 2], "", g[y], g[y - 4]);
          break;
        case 75:
          b.commit(g[y - 4], g[y], g[y - 2], "");
          break;
        case 76:
          b.commit(g[y - 4], g[y - 2], g[y], "");
          break;
        case 77:
          b.commit(g[y - 2], g[y], g[y - 4], "");
          break;
        case 78:
          b.commit(g[y], g[y - 2], g[y - 4], "");
          break;
        case 79:
          b.commit(g[y], g[y - 4], g[y - 2], "");
          break;
        case 80:
          b.commit(g[y - 2], g[y - 4], g[y], "");
          break;
        case 81:
          b.commit(g[y - 4], g[y], b.commitType.NORMAL, g[y - 2]);
          break;
        case 82:
          b.commit(g[y - 4], g[y - 2], b.commitType.NORMAL, g[y]);
          break;
        case 83:
          b.commit(g[y - 2], g[y], b.commitType.NORMAL, g[y - 4]);
          break;
        case 84:
          b.commit(g[y], g[y - 2], b.commitType.NORMAL, g[y - 4]);
          break;
        case 85:
          b.commit(g[y], g[y - 4], b.commitType.NORMAL, g[y - 2]);
          break;
        case 86:
          b.commit(g[y - 2], g[y - 4], b.commitType.NORMAL, g[y]);
          break;
        case 87:
          b.commit(g[y - 6], g[y - 4], g[y - 2], g[y]);
          break;
        case 88:
          b.commit(g[y - 6], g[y - 4], g[y], g[y - 2]);
          break;
        case 89:
          b.commit(g[y - 6], g[y - 2], g[y - 4], g[y]);
          break;
        case 90:
          b.commit(g[y - 6], g[y], g[y - 4], g[y - 2]);
          break;
        case 91:
          b.commit(g[y - 6], g[y - 2], g[y], g[y - 4]);
          break;
        case 92:
          b.commit(g[y - 6], g[y], g[y - 2], g[y - 4]);
          break;
        case 93:
          b.commit(g[y - 4], g[y - 6], g[y - 2], g[y]);
          break;
        case 94:
          b.commit(g[y - 4], g[y - 6], g[y], g[y - 2]);
          break;
        case 95:
          b.commit(g[y - 2], g[y - 6], g[y - 4], g[y]);
          break;
        case 96:
          b.commit(g[y], g[y - 6], g[y - 4], g[y - 2]);
          break;
        case 97:
          b.commit(g[y - 2], g[y - 6], g[y], g[y - 4]);
          break;
        case 98:
          b.commit(g[y], g[y - 6], g[y - 2], g[y - 4]);
          break;
        case 99:
          b.commit(g[y], g[y - 4], g[y - 2], g[y - 6]);
          break;
        case 100:
          b.commit(g[y - 2], g[y - 4], g[y], g[y - 6]);
          break;
        case 101:
          b.commit(g[y], g[y - 2], g[y - 4], g[y - 6]);
          break;
        case 102:
          b.commit(g[y - 2], g[y], g[y - 4], g[y - 6]);
          break;
        case 103:
          b.commit(g[y - 4], g[y - 2], g[y], g[y - 6]);
          break;
        case 104:
          b.commit(g[y - 4], g[y], g[y - 2], g[y - 6]);
          break;
        case 105:
          b.commit(g[y - 2], g[y - 4], g[y - 6], g[y]);
          break;
        case 106:
          b.commit(g[y], g[y - 4], g[y - 6], g[y - 2]);
          break;
        case 107:
          b.commit(g[y - 2], g[y], g[y - 6], g[y - 4]);
          break;
        case 108:
          b.commit(g[y], g[y - 2], g[y - 6], g[y - 4]);
          break;
        case 109:
          b.commit(g[y - 4], g[y - 2], g[y - 6], g[y]);
          break;
        case 110:
          b.commit(g[y - 4], g[y], g[y - 6], g[y - 2]);
          break;
        case 111:
          this.$ = "";
          break;
        case 112:
          this.$ = g[y];
          break;
        case 113:
          this.$ = b.commitType.NORMAL;
          break;
        case 114:
          this.$ = b.commitType.REVERSE;
          break;
        case 115:
          this.$ = b.commitType.HIGHLIGHT;
          break;
        case 118:
          b.parseDirective("%%{", "open_directive");
          break;
        case 119:
          b.parseDirective(g[y], "type_directive");
          break;
        case 120:
          g[y] = g[y].trim().replace(/'/g, '"'), b.parseDirective(g[y], "arg_directive");
          break;
        case 121:
          b.parseDirective("}%%", "close_directive", "gitGraph");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: e, 8: r, 14: n, 46: 8, 50: i, 55: s }, { 1: [3] }, { 3: 10, 4: 2, 5: 3, 6: e, 8: r, 14: n, 46: 8, 50: i, 55: s }, { 3: 11, 4: 2, 5: 3, 6: e, 8: r, 14: n, 46: 8, 50: i, 55: s }, { 7: 12, 8: a, 9: [1, 13], 10: [1, 14], 11: 15, 14: o }, t(l, [2, 124]), t(l, [2, 125]), t(l, [2, 126]), { 47: 17, 51: [1, 18] }, { 51: [2, 118] }, { 1: [2, 1] }, { 1: [2, 2] }, { 8: [1, 19] }, { 7: 20, 8: a, 11: 15, 14: o }, { 9: [1, 21] }, t(u, [2, 10], { 12: 22, 13: [1, 23] }), t(h, [2, 9]), { 9: [1, 25], 48: 24, 53: f }, t([9, 53], [2, 119]), { 1: [2, 3] }, { 8: [1, 27] }, { 7: 28, 8: a, 11: 15, 14: o }, { 8: [2, 7], 14: [1, 31], 15: 29, 16: 30, 17: 32, 18: 33, 19: 34, 20: [1, 35], 22: [1, 36], 24: [1, 37], 25: [1, 38], 26: 39, 27: [1, 40], 29: [1, 44], 32: [1, 43], 37: [1, 42], 40: [1, 41] }, t(h, [2, 8]), t(d, [2, 116]), { 49: 45, 52: [1, 46] }, t(d, [2, 121]), { 1: [2, 4] }, { 8: [1, 47] }, t(u, [2, 11]), { 4: 48, 8: r, 14: n, 55: s }, t(u, [2, 13]), t(p, [2, 14]), t(p, [2, 15]), t(p, [2, 16]), { 21: [1, 49] }, { 23: [1, 50] }, t(p, [2, 19]), t(p, [2, 20]), t(p, [2, 21]), { 28: 51, 34: m, 54: _ }, t(p, [2, 111], { 41: 54, 33: [1, 57], 34: [1, 59], 35: [1, 55], 38: [1, 56], 42: [1, 58] }), { 28: 60, 34: m, 54: _ }, { 33: [1, 61], 35: [1, 62] }, { 28: 63, 34: m, 54: _ }, { 48: 64, 53: f }, { 53: [2, 120] }, { 1: [2, 5] }, t(u, [2, 12]), t(p, [2, 17]), t(p, [2, 18]), t(p, [2, 22]), t(v, [2, 122]), t(v, [2, 123]), t(p, [2, 46]), { 34: [1, 65] }, { 39: 66, 43: k, 44: x, 45: D }, { 34: [1, 70] }, { 34: [1, 71] }, t(p, [2, 112]), t(p, [2, 30], { 33: [1, 72], 35: [1, 74], 38: [1, 73] }), { 34: [1, 75] }, { 34: [1, 76], 36: [1, 77] }, t(p, [2, 23], { 30: [1, 78] }), t(d, [2, 117]), t(p, [2, 47], { 33: [1, 80], 38: [1, 79], 42: [1, 81] }), t(p, [2, 48], { 33: [1, 83], 35: [1, 82], 42: [1, 84] }), t(F, [2, 113]), t(F, [2, 114]), t(F, [2, 115]), t(p, [2, 51], { 35: [1, 85], 38: [1, 86], 42: [1, 87] }), t(p, [2, 62], { 33: [1, 90], 35: [1, 88], 38: [1, 89] }), { 34: [1, 91] }, { 39: 92, 43: k, 44: x, 45: D }, { 34: [1, 93] }, t(p, [2, 25], { 35: [1, 94] }), { 33: [1, 95] }, { 33: [1, 96] }, { 31: [1, 97] }, { 39: 98, 43: k, 44: x, 45: D }, { 34: [1, 99] }, { 34: [1, 100] }, { 34: [1, 101] }, { 34: [1, 102] }, { 34: [1, 103] }, { 34: [1, 104] }, { 39: 105, 43: k, 44: x, 45: D }, { 34: [1, 106] }, { 34: [1, 107] }, { 39: 108, 43: k, 44: x, 45: D }, { 34: [1, 109] }, t(p, [2, 31], { 35: [1, 111], 38: [1, 110] }), t(p, [2, 32], { 33: [1, 113], 35: [1, 112] }), t(p, [2, 33], { 33: [1, 114], 38: [1, 115] }), { 34: [1, 116], 36: [1, 117] }, { 34: [1, 118] }, { 34: [1, 119] }, t(p, [2, 24]), t(p, [2, 49], { 33: [1, 120], 42: [1, 121] }), t(p, [2, 53], { 38: [1, 122], 42: [1, 123] }), t(p, [2, 63], { 33: [1, 125], 38: [1, 124] }), t(p, [2, 50], { 33: [1, 126], 42: [1, 127] }), t(p, [2, 55], { 35: [1, 128], 42: [1, 129] }), t(p, [2, 66], { 33: [1, 131], 35: [1, 130] }), t(p, [2, 52], { 38: [1, 132], 42: [1, 133] }), t(p, [2, 54], { 35: [1, 134], 42: [1, 135] }), t(p, [2, 67], { 35: [1, 137], 38: [1, 136] }), t(p, [2, 64], { 33: [1, 139], 38: [1, 138] }), t(p, [2, 65], { 33: [1, 141], 35: [1, 140] }), t(p, [2, 68], { 35: [1, 143], 38: [1, 142] }), { 39: 144, 43: k, 44: x, 45: D }, { 34: [1, 145] }, { 34: [1, 146] }, { 34: [1, 147] }, { 34: [1, 148] }, { 39: 149, 43: k, 44: x, 45: D }, t(p, [2, 26]), t(p, [2, 27]), t(p, [2, 28]), t(p, [2, 29]), { 34: [1, 150] }, { 34: [1, 151] }, { 39: 152, 43: k, 44: x, 45: D }, { 34: [1, 153] }, { 39: 154, 43: k, 44: x, 45: D }, { 34: [1, 155] }, { 34: [1, 156] }, { 34: [1, 157] }, { 34: [1, 158] }, { 34: [1, 159] }, { 34: [1, 160] }, { 34: [1, 161] }, { 39: 162, 43: k, 44: x, 45: D }, { 34: [1, 163] }, { 34: [1, 164] }, { 34: [1, 165] }, { 39: 166, 43: k, 44: x, 45: D }, { 34: [1, 167] }, { 39: 168, 43: k, 44: x, 45: D }, { 34: [1, 169] }, { 34: [1, 170] }, { 34: [1, 171] }, { 39: 172, 43: k, 44: x, 45: D }, { 34: [1, 173] }, t(p, [2, 37], { 35: [1, 174] }), t(p, [2, 38], { 38: [1, 175] }), t(p, [2, 36], { 33: [1, 176] }), t(p, [2, 39], { 35: [1, 177] }), t(p, [2, 34], { 38: [1, 178] }), t(p, [2, 35], { 33: [1, 179] }), t(p, [2, 60], { 42: [1, 180] }), t(p, [2, 73], { 33: [1, 181] }), t(p, [2, 61], { 42: [1, 182] }), t(p, [2, 84], { 38: [1, 183] }), t(p, [2, 74], { 33: [1, 184] }), t(p, [2, 83], { 38: [1, 185] }), t(p, [2, 59], { 42: [1, 186] }), t(p, [2, 72], { 33: [1, 187] }), t(p, [2, 58], { 42: [1, 188] }), t(p, [2, 78], { 35: [1, 189] }), t(p, [2, 71], { 33: [1, 190] }), t(p, [2, 77], { 35: [1, 191] }), t(p, [2, 57], { 42: [1, 192] }), t(p, [2, 85], { 38: [1, 193] }), t(p, [2, 56], { 42: [1, 194] }), t(p, [2, 79], { 35: [1, 195] }), t(p, [2, 80], { 35: [1, 196] }), t(p, [2, 86], { 38: [1, 197] }), t(p, [2, 70], { 33: [1, 198] }), t(p, [2, 81], { 38: [1, 199] }), t(p, [2, 69], { 33: [1, 200] }), t(p, [2, 75], { 35: [1, 201] }), t(p, [2, 76], { 35: [1, 202] }), t(p, [2, 82], { 38: [1, 203] }), { 34: [1, 204] }, { 39: 205, 43: k, 44: x, 45: D }, { 34: [1, 206] }, { 34: [1, 207] }, { 39: 208, 43: k, 44: x, 45: D }, { 34: [1, 209] }, { 34: [1, 210] }, { 34: [1, 211] }, { 34: [1, 212] }, { 39: 213, 43: k, 44: x, 45: D }, { 34: [1, 214] }, { 39: 215, 43: k, 44: x, 45: D }, { 34: [1, 216] }, { 34: [1, 217] }, { 34: [1, 218] }, { 34: [1, 219] }, { 34: [1, 220] }, { 34: [1, 221] }, { 34: [1, 222] }, { 39: 223, 43: k, 44: x, 45: D }, { 34: [1, 224] }, { 34: [1, 225] }, { 34: [1, 226] }, { 39: 227, 43: k, 44: x, 45: D }, { 34: [1, 228] }, { 39: 229, 43: k, 44: x, 45: D }, { 34: [1, 230] }, { 34: [1, 231] }, { 34: [1, 232] }, { 39: 233, 43: k, 44: x, 45: D }, t(p, [2, 40]), t(p, [2, 42]), t(p, [2, 41]), t(p, [2, 43]), t(p, [2, 45]), t(p, [2, 44]), t(p, [2, 101]), t(p, [2, 102]), t(p, [2, 99]), t(p, [2, 100]), t(p, [2, 104]), t(p, [2, 103]), t(p, [2, 108]), t(p, [2, 107]), t(p, [2, 106]), t(p, [2, 105]), t(p, [2, 110]), t(p, [2, 109]), t(p, [2, 98]), t(p, [2, 97]), t(p, [2, 96]), t(p, [2, 95]), t(p, [2, 93]), t(p, [2, 94]), t(p, [2, 92]), t(p, [2, 91]), t(p, [2, 90]), t(p, [2, 89]), t(p, [2, 87]), t(p, [2, 88])],
    defaultActions: { 9: [2, 118], 10: [2, 1], 11: [2, 2], 19: [2, 3], 27: [2, 4], 46: [2, 120], 47: [2, 5] },
    parseError: function(C, S) {
      if (S.recoverable)
        this.trace(C);
      else {
        var T = new Error(C);
        throw T.hash = S, T;
      }
    },
    parse: function(C) {
      var S = this, T = [0], b = [], w = [null], g = [], M = this.table, y = "", N = 0, it = 0, Y = 2, Z = 1, J = g.slice.call(arguments, 1), X = Object.create(this.lexer), tt = { yy: {} };
      for (var st in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, st) && (tt.yy[st] = this.yy[st]);
      X.setInput(C, tt.yy), tt.yy.lexer = X, tt.yy.parser = this, typeof X.yylloc > "u" && (X.yylloc = {});
      var lt = X.yylloc;
      g.push(lt);
      var U = X.options && X.options.ranges;
      typeof tt.yy.parseError == "function" ? this.parseError = tt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Tt() {
        var Dt;
        return Dt = b.pop() || X.lex() || Z, typeof Dt != "number" && (Dt instanceof Array && (b = Dt, Dt = b.pop()), Dt = S.symbols_[Dt] || Dt), Dt;
      }
      for (var $, j, W, z, A = {}, I, G, L, at; ; ) {
        if (j = T[T.length - 1], this.defaultActions[j] ? W = this.defaultActions[j] : (($ === null || typeof $ > "u") && ($ = Tt()), W = M[j] && M[j][$]), typeof W > "u" || !W.length || !W[0]) {
          var E = "";
          at = [];
          for (I in M[j])
            this.terminals_[I] && I > Y && at.push("'" + this.terminals_[I] + "'");
          X.showPosition ? E = "Parse error on line " + (N + 1) + `:
` + X.showPosition() + `
Expecting ` + at.join(", ") + ", got '" + (this.terminals_[$] || $) + "'" : E = "Parse error on line " + (N + 1) + ": Unexpected " + ($ == Z ? "end of input" : "'" + (this.terminals_[$] || $) + "'"), this.parseError(E, {
            text: X.match,
            token: this.terminals_[$] || $,
            line: X.yylineno,
            loc: lt,
            expected: at
          });
        }
        if (W[0] instanceof Array && W.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + j + ", token: " + $);
        switch (W[0]) {
          case 1:
            T.push($), w.push(X.yytext), g.push(X.yylloc), T.push(W[1]), $ = null, it = X.yyleng, y = X.yytext, N = X.yylineno, lt = X.yylloc;
            break;
          case 2:
            if (G = this.productions_[W[1]][1], A.$ = w[w.length - G], A._$ = {
              first_line: g[g.length - (G || 1)].first_line,
              last_line: g[g.length - 1].last_line,
              first_column: g[g.length - (G || 1)].first_column,
              last_column: g[g.length - 1].last_column
            }, U && (A._$.range = [
              g[g.length - (G || 1)].range[0],
              g[g.length - 1].range[1]
            ]), z = this.performAction.apply(A, [
              y,
              it,
              N,
              tt.yy,
              W[1],
              w,
              g
            ].concat(J)), typeof z < "u")
              return z;
            G && (T = T.slice(0, -1 * G * 2), w = w.slice(0, -1 * G), g = g.slice(0, -1 * G)), T.push(this.productions_[W[1]][0]), w.push(A.$), g.push(A._$), L = M[T[T.length - 2]][T[T.length - 1]], T.push(L);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, V = function() {
    var O = {
      EOF: 1,
      parseError: function(S, T) {
        if (this.yy.parser)
          this.yy.parser.parseError(S, T);
        else
          throw new Error(S);
      },
      // resets the lexer, sets new input
      setInput: function(C, S) {
        return this.yy = S || this.yy || {}, this._input = C, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var C = this._input[0];
        this.yytext += C, this.yyleng++, this.offset++, this.match += C, this.matched += C;
        var S = C.match(/(?:\r\n?|\n).*/g);
        return S ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), C;
      },
      // unshifts one char (or a string) into the input
      unput: function(C) {
        var S = C.length, T = C.split(/(?:\r\n?|\n)/g);
        this._input = C + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - S), this.offset -= S;
        var b = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), T.length - 1 && (this.yylineno -= T.length - 1);
        var w = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: T ? (T.length === b.length ? this.yylloc.first_column : 0) + b[b.length - T.length].length - T[0].length : this.yylloc.first_column - S
        }, this.options.ranges && (this.yylloc.range = [w[0], w[0] + this.yyleng - S]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(C) {
        this.unput(this.match.slice(C));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var C = this.matched.substr(0, this.matched.length - this.match.length);
        return (C.length > 20 ? "..." : "") + C.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var C = this.match;
        return C.length < 20 && (C += this._input.substr(0, 20 - C.length)), (C.substr(0, 20) + (C.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var C = this.pastInput(), S = new Array(C.length + 1).join("-");
        return C + this.upcomingInput() + `
` + S + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(C, S) {
        var T, b, w;
        if (this.options.backtrack_lexer && (w = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (w.yylloc.range = this.yylloc.range.slice(0))), b = C[0].match(/(?:\r\n?|\n).*/g), b && (this.yylineno += b.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: b ? b[b.length - 1].length - b[b.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + C[0].length
        }, this.yytext += C[0], this.match += C[0], this.matches = C, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(C[0].length), this.matched += C[0], T = this.performAction.call(this, this.yy, this, S, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), T)
          return T;
        if (this._backtrack) {
          for (var g in w)
            this[g] = w[g];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var C, S, T, b;
        this._more || (this.yytext = "", this.match = "");
        for (var w = this._currentRules(), g = 0; g < w.length; g++)
          if (T = this._input.match(this.rules[w[g]]), T && (!S || T[0].length > S[0].length)) {
            if (S = T, b = g, this.options.backtrack_lexer) {
              if (C = this.test_match(T, w[g]), C !== !1)
                return C;
              if (this._backtrack) {
                S = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return S ? (C = this.test_match(S, w[b]), C !== !1 ? C : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var S = this.next();
        return S || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(S) {
        this.conditionStack.push(S);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var S = this.conditionStack.length - 1;
        return S > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(S) {
        return S = this.conditionStack.length - 1 - Math.abs(S || 0), S >= 0 ? this.conditionStack[S] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(S) {
        this.begin(S);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(S, T, b, w) {
        switch (b) {
          case 0:
            return this.begin("open_directive"), 50;
          case 1:
            return this.begin("type_directive"), 51;
          case 2:
            return this.popState(), this.begin("arg_directive"), 9;
          case 3:
            return this.popState(), this.popState(), 53;
          case 4:
            return 52;
          case 5:
            return this.begin("acc_title"), 20;
          case 6:
            return this.popState(), "acc_title_value";
          case 7:
            return this.begin("acc_descr"), 22;
          case 8:
            return this.popState(), "acc_descr_value";
          case 9:
            this.begin("acc_descr_multiline");
            break;
          case 10:
            this.popState();
            break;
          case 11:
            return "acc_descr_multiline_value";
          case 12:
            return 14;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return 6;
          case 16:
            return 40;
          case 17:
            return 33;
          case 18:
            return 38;
          case 19:
            return 42;
          case 20:
            return 43;
          case 21:
            return 44;
          case 22:
            return 45;
          case 23:
            return 35;
          case 24:
            return 29;
          case 25:
            return 30;
          case 26:
            return 37;
          case 27:
            return 32;
          case 28:
            return 27;
          case 29:
            return 10;
          case 30:
            return 10;
          case 31:
            return 9;
          case 32:
            return "CARET";
          case 33:
            this.begin("options");
            break;
          case 34:
            this.popState();
            break;
          case 35:
            return 13;
          case 36:
            return 36;
          case 37:
            this.begin("string");
            break;
          case 38:
            this.popState();
            break;
          case 39:
            return 34;
          case 40:
            return 31;
          case 41:
            return 54;
          case 42:
            return 8;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:(\r?\n)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:gitGraph\b)/i, /^(?:commit(?=\s|$))/i, /^(?:id:)/i, /^(?:type:)/i, /^(?:msg:)/i, /^(?:NORMAL\b)/i, /^(?:REVERSE\b)/i, /^(?:HIGHLIGHT\b)/i, /^(?:tag:)/i, /^(?:branch(?=\s|$))/i, /^(?:order:)/i, /^(?:merge(?=\s|$))/i, /^(?:cherry-pick(?=\s|$))/i, /^(?:checkout(?=\s|$))/i, /^(?:LR\b)/i, /^(?:BT\b)/i, /^(?::)/i, /^(?:\^)/i, /^(?:options\r?\n)/i, /^(?:[ \r\n\t]+end\b)/i, /^(?:[\s\S]+(?=[ \r\n\t]+end))/i, /^(?:["]["])/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[0-9]+(?=\s|$))/i, /^(?:\w([-\./\w]*[-\w])?)/i, /^(?:$)/i, /^(?:\s+)/i],
      conditions: { acc_descr_multiline: { rules: [10, 11], inclusive: !1 }, acc_descr: { rules: [8], inclusive: !1 }, acc_title: { rules: [6], inclusive: !1 }, close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, open_directive: { rules: [1], inclusive: !1 }, options: { rules: [34, 35], inclusive: !1 }, string: { rules: [38, 39], inclusive: !1 }, INITIAL: { rules: [0, 5, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 36, 37, 40, 41, 42, 43], inclusive: !0 } }
    };
    return O;
  }();
  P.lexer = V;
  function R() {
    this.yy = {};
  }
  return R.prototype = P, P.Parser = R, new R();
}();
Ih.parser = Ih;
const $E = Ih, jE = (t) => t.match(/^\s*gitGraph/) !== null;
let ql = q().gitGraph.mainBranchName, XE = q().gitGraph.mainBranchOrder, He = {}, dr = null, Ga = {};
Ga[ql] = { name: ql, order: XE };
let Re = {};
Re[ql] = dr;
let je = ql, hy = "LR", zi = 0;
function o0() {
  return Yg({ length: 7 });
}
const KE = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
};
function ZE(t, e) {
  const r = /* @__PURE__ */ Object.create(null);
  return t.reduce((n, i) => {
    const s = e(i);
    return r[s] || (r[s] = !0, n.push(i)), n;
  }, []);
}
const QE = function(t) {
  hy = t;
};
let fy = {};
const JE = function(t) {
  B.debug("options str", t), t = t && t.trim(), t = t || "{}";
  try {
    fy = JSON.parse(t);
  } catch (e) {
    B.error("error while parsing gitGraph options", e.message);
  }
}, tC = function() {
  return fy;
}, eC = function(t, e, r, n) {
  B.debug("Entering commit:", t, e, r, n), e = Xt.sanitizeText(e, q()), t = Xt.sanitizeText(t, q()), n = Xt.sanitizeText(n, q());
  const i = {
    id: e || zi + "-" + o0(),
    message: t,
    seq: zi++,
    type: r || qa.NORMAL,
    tag: n || "",
    parents: dr == null ? [] : [dr.id],
    branch: je
  };
  dr = i, He[i.id] = i, Re[je] = i.id, B.debug("in pushCommit " + i.id);
}, rC = function(t, e) {
  if (t = Xt.sanitizeText(t, q()), Re[t] === void 0)
    Re[t] = dr != null ? dr.id : null, Ga[t] = { name: t, order: e ? parseInt(e, 10) : null }, dy(t), B.debug("in createBranch");
  else {
    let r = new Error(
      'Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ' + t + '")'
    );
    throw r.hash = {
      text: "branch " + t,
      token: "branch " + t,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"checkout ' + t + '"']
    }, r;
  }
}, nC = function(t, e, r, n) {
  t = Xt.sanitizeText(t, q()), e = Xt.sanitizeText(e, q());
  const i = He[Re[je]], s = He[Re[t]];
  if (je === t) {
    let o = new Error('Incorrect usage of "merge". Cannot merge a branch to itself');
    throw o.hash = {
      text: "merge " + t,
      token: "merge " + t,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch abc"]
    }, o;
  } else if (i === void 0 || !i) {
    let o = new Error(
      'Incorrect usage of "merge". Current branch (' + je + ")has no commits"
    );
    throw o.hash = {
      text: "merge " + t,
      token: "merge " + t,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["commit"]
    }, o;
  } else if (Re[t] === void 0) {
    let o = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + t + ") does not exist"
    );
    throw o.hash = {
      text: "merge " + t,
      token: "merge " + t,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch " + t]
    }, o;
  } else if (s === void 0 || !s) {
    let o = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + t + ") has no commits"
    );
    throw o.hash = {
      text: "merge " + t,
      token: "merge " + t,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"commit"']
    }, o;
  } else if (i === s) {
    let o = new Error('Incorrect usage of "merge". Both branches have same head');
    throw o.hash = {
      text: "merge " + t,
      token: "merge " + t,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch abc"]
    }, o;
  } else if (e && He[e] !== void 0) {
    let o = new Error(
      'Incorrect usage of "merge". Commit with id:' + e + " already exists, use different custom Id"
    );
    throw o.hash = {
      text: "merge " + t + e + r + n,
      token: "merge " + t + e + r + n,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: [
        "merge " + t + " " + e + "_UNIQUE " + r + " " + n
      ]
    }, o;
  }
  const a = {
    id: e || zi + "-" + o0(),
    message: "merged branch " + t + " into " + je,
    seq: zi++,
    parents: [dr == null ? null : dr.id, Re[t]],
    branch: je,
    type: qa.MERGE,
    customType: r,
    customId: !!e,
    tag: n || ""
  };
  dr = a, He[a.id] = a, Re[je] = a.id, B.debug(Re), B.debug("in mergeBranch");
}, iC = function(t, e, r) {
  if (B.debug("Entering cherryPick:", t, e, r), t = Xt.sanitizeText(t, q()), e = Xt.sanitizeText(e, q()), r = Xt.sanitizeText(r, q()), !t || He[t] === void 0) {
    let s = new Error(
      'Incorrect usage of "cherryPick". Source commit id should exist and provided'
    );
    throw s.hash = {
      text: "cherryPick " + t + " " + e,
      token: "cherryPick " + t + " " + e,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["cherry-pick abc"]
    }, s;
  }
  let n = He[t], i = n.branch;
  if (n.type === qa.MERGE) {
    let s = new Error(
      'Incorrect usage of "cherryPick". Source commit should not be a merge commit'
    );
    throw s.hash = {
      text: "cherryPick " + t + " " + e,
      token: "cherryPick " + t + " " + e,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["cherry-pick abc"]
    }, s;
  }
  if (!e || He[e] === void 0) {
    if (i === je) {
      let o = new Error(
        'Incorrect usage of "cherryPick". Source commit is already on current branch'
      );
      throw o.hash = {
        text: "cherryPick " + t + " " + e,
        token: "cherryPick " + t + " " + e,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["cherry-pick abc"]
      }, o;
    }
    const s = He[Re[je]];
    if (s === void 0 || !s) {
      let o = new Error(
        'Incorrect usage of "cherry-pick". Current branch (' + je + ")has no commits"
      );
      throw o.hash = {
        text: "cherryPick " + t + " " + e,
        token: "cherryPick " + t + " " + e,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["cherry-pick abc"]
      }, o;
    }
    const a = {
      id: zi + "-" + o0(),
      message: "cherry-picked " + n + " into " + je,
      seq: zi++,
      parents: [dr == null ? null : dr.id, n.id],
      branch: je,
      type: qa.CHERRY_PICK,
      tag: r ?? "cherry-pick:" + n.id
    };
    dr = a, He[a.id] = a, Re[je] = a.id, B.debug(Re), B.debug("in cherryPick");
  }
}, dy = function(t) {
  if (t = Xt.sanitizeText(t, q()), Re[t] === void 0) {
    let e = new Error(
      'Trying to checkout branch which is not yet created. (Help try using "branch ' + t + '")'
    );
    throw e.hash = {
      text: "checkout " + t,
      token: "checkout " + t,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"branch ' + t + '"']
    }, e;
  } else {
    je = t;
    const e = Re[je];
    dr = He[e];
  }
};
function _d(t, e, r) {
  const n = t.indexOf(e);
  n === -1 ? t.push(r) : t.splice(n, 1, r);
}
function py(t) {
  const e = t.reduce((i, s) => i.seq > s.seq ? i : s, t[0]);
  let r = "";
  t.forEach(function(i) {
    i === e ? r += "	*" : r += "	|";
  });
  const n = [r, e.id, e.seq];
  for (let i in Re)
    Re[i] === e.id && n.push(i);
  if (B.debug(n.join(" ")), e.parents && e.parents.length == 2) {
    const i = He[e.parents[0]];
    _d(t, e, i), t.push(He[e.parents[1]]);
  } else {
    if (e.parents.length == 0)
      return;
    {
      const i = He[e.parents];
      _d(t, e, i);
    }
  }
  t = ZE(t, (i) => i.id), py(t);
}
const sC = function() {
  B.debug(He);
  const t = gy()[0];
  py([t]);
}, aC = function() {
  He = {}, dr = null;
  let t = q().gitGraph.mainBranchName, e = q().gitGraph.mainBranchOrder;
  Re = {}, Re[t] = null, Ga = {}, Ga[t] = { name: t, order: e }, je = t, zi = 0, Br();
}, oC = function() {
  return Object.values(Ga).map((e, r) => e.order !== null ? e : {
    ...e,
    order: parseFloat(`0.${r}`, 10)
  }).sort((e, r) => e.order - r.order).map(({ name: e }) => ({ name: e }));
}, lC = function() {
  return Re;
}, cC = function() {
  return He;
}, gy = function() {
  const t = Object.keys(He).map(function(e) {
    return He[e];
  });
  return t.forEach(function(e) {
    B.debug(e.id);
  }), t.sort((e, r) => e.seq - r.seq), t;
}, uC = function() {
  return je;
}, hC = function() {
  return hy;
}, fC = function() {
  return dr;
}, qa = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
}, dC = {
  parseDirective: KE,
  getConfig: () => q().gitGraph,
  setDirection: QE,
  setOptions: JE,
  getOptions: tC,
  commit: eC,
  branch: rC,
  merge: nC,
  cherryPick: iC,
  checkout: dy,
  //reset,
  prettyPrint: sC,
  clear: aC,
  getBranchesAsObjArray: oC,
  getBranches: lC,
  getCommits: cC,
  getCommitsArray: gy,
  getCurrentBranch: uC,
  getDirection: hC,
  getHead: fC,
  setAccTitle: Tr,
  getAccTitle: Dr,
  getAccDescription: Mr,
  setAccDescription: Ir,
  setDiagramTitle: un,
  getDiagramTitle: hn,
  commitType: qa
};
let _a = {};
const Er = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
}, Li = 8;
let _r = {}, $l = {}, jl = [], Xl = 0;
const pC = () => {
  _r = {}, $l = {}, _a = {}, Xl = 0, jl = [];
}, gC = (t) => {
  const e = document.createElementNS("http://www.w3.org/2000/svg", "text");
  let r = [];
  typeof t == "string" ? r = t.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(t) ? r = t : r = [];
  for (const n of r) {
    const i = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    i.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), i.setAttribute("dy", "1em"), i.setAttribute("x", "0"), i.setAttribute("class", "row"), i.textContent = n.trim(), e.appendChild(i);
  }
  return e;
}, xd = (t, e, r) => {
  const n = fo().gitGraph, i = t.append("g").attr("class", "commit-bullets"), s = t.append("g").attr("class", "commit-labels");
  let a = 0;
  Object.keys(e).sort((u, h) => e[u].seq - e[h].seq).forEach((u) => {
    const h = e[u], f = _r[h.branch].pos, d = a + 10;
    if (r) {
      let p, m = h.customType !== void 0 && h.customType !== "" ? h.customType : h.type;
      switch (m) {
        case Er.NORMAL:
          p = "commit-normal";
          break;
        case Er.REVERSE:
          p = "commit-reverse";
          break;
        case Er.HIGHLIGHT:
          p = "commit-highlight";
          break;
        case Er.MERGE:
          p = "commit-merge";
          break;
        case Er.CHERRY_PICK:
          p = "commit-cherry-pick";
          break;
        default:
          p = "commit-normal";
      }
      if (m === Er.HIGHLIGHT) {
        const _ = i.append("rect");
        _.attr("x", d - 10), _.attr("y", f - 10), _.attr("height", 20), _.attr("width", 20), _.attr(
          "class",
          `commit ${h.id} commit-highlight${_r[h.branch].index % Li} ${p}-outer`
        ), i.append("rect").attr("x", d - 6).attr("y", f - 6).attr("height", 12).attr("width", 12).attr(
          "class",
          `commit ${h.id} commit${_r[h.branch].index % Li} ${p}-inner`
        );
      } else if (m === Er.CHERRY_PICK)
        i.append("circle").attr("cx", d).attr("cy", f).attr("r", 10).attr("class", `commit ${h.id} ${p}`), i.append("circle").attr("cx", d - 3).attr("cy", f + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${h.id} ${p}`), i.append("circle").attr("cx", d + 3).attr("cy", f + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${h.id} ${p}`), i.append("line").attr("x1", d + 3).attr("y1", f + 1).attr("x2", d).attr("y2", f - 5).attr("stroke", "#fff").attr("class", `commit ${h.id} ${p}`), i.append("line").attr("x1", d - 3).attr("y1", f + 1).attr("x2", d).attr("y2", f - 5).attr("stroke", "#fff").attr("class", `commit ${h.id} ${p}`);
      else {
        const _ = i.append("circle");
        if (_.attr("cx", d), _.attr("cy", f), _.attr("r", h.type === Er.MERGE ? 9 : 10), _.attr(
          "class",
          `commit ${h.id} commit${_r[h.branch].index % Li}`
        ), m === Er.MERGE) {
          const v = i.append("circle");
          v.attr("cx", d), v.attr("cy", f), v.attr("r", 6), v.attr(
            "class",
            `commit ${p} ${h.id} commit${_r[h.branch].index % Li}`
          );
        }
        m === Er.REVERSE && i.append("path").attr("d", `M ${d - 5},${f - 5}L${d + 5},${f + 5}M${d - 5},${f + 5}L${d + 5},${f - 5}`).attr(
          "class",
          `commit ${p} ${h.id} commit${_r[h.branch].index % Li}`
        );
      }
    }
    if ($l[h.id] = { x: a + 10, y: f }, r) {
      if (h.type !== Er.CHERRY_PICK && (h.customId && h.type === Er.MERGE || h.type !== Er.MERGE) && n.showCommitLabel) {
        const _ = s.append("g"), v = _.insert("rect").attr("class", "commit-label-bkg"), k = _.append("text").attr("x", a).attr("y", f + 25).attr("class", "commit-label").text(h.id);
        let x = k.node().getBBox();
        if (v.attr("x", a + 10 - x.width / 2 - 2).attr("y", f + 13.5).attr("width", x.width + 2 * 2).attr("height", x.height + 2 * 2), k.attr("x", a + 10 - x.width / 2), n.rotateCommitLabel) {
          let D = -7.5 - (x.width + 10) / 25 * 9.5, F = 10 + x.width / 25 * 8.5;
          _.attr(
            "transform",
            "translate(" + D + ", " + F + ") rotate(" + -45 + ", " + a + ", " + f + ")"
          );
        }
      }
      if (h.tag) {
        const _ = s.insert("polygon"), v = s.append("circle"), k = s.append("text").attr("y", f - 16).attr("class", "tag-label").text(h.tag);
        let x = k.node().getBBox();
        k.attr("x", a + 10 - x.width / 2);
        const D = x.height / 2, F = f - 19.2;
        _.attr("class", "tag-label-bkg").attr(
          "points",
          `
          ${a - x.width / 2 - 4 / 2},${F + 2}
          ${a - x.width / 2 - 4 / 2},${F - 2}
          ${a + 10 - x.width / 2 - 4},${F - D - 2}
          ${a + 10 + x.width / 2 + 4},${F - D - 2}
          ${a + 10 + x.width / 2 + 4},${F + D + 2}
          ${a + 10 - x.width / 2 - 4},${F + D + 2}`
        ), v.attr("cx", a - x.width / 2 + 4 / 2).attr("cy", F).attr("r", 1.5).attr("class", "tag-hole");
      }
    }
    a += 50, a > Xl && (Xl = a);
  });
}, yC = (t, e, r) => Object.keys(r).filter((s) => r[s].branch === e.branch && r[s].seq > t.seq && r[s].seq < e.seq).length > 0, Mh = (t, e, r = 0) => {
  const n = t + Math.abs(t - e) / 2;
  if (r > 5)
    return n;
  if (jl.every((a) => Math.abs(a - n) >= 10))
    return jl.push(n), n;
  const s = Math.abs(t - e);
  return Mh(t, e - s / 5, r + 1);
}, mC = (t, e, r, n) => {
  const i = $l[e.id], s = $l[r.id], a = yC(e, r, n);
  let o = "", l = "", u = 0, h = 0, f = _r[r.branch].index, d;
  if (a) {
    o = "A 10 10, 0, 0, 0,", l = "A 10 10, 0, 0, 1,", u = 10, h = 10, f = _r[r.branch].index;
    const p = i.y < s.y ? Mh(i.y, s.y) : Mh(s.y, i.y);
    i.y < s.y ? d = `M ${i.x} ${i.y} L ${i.x} ${p - u} ${o} ${i.x + h} ${p} L ${s.x - u} ${p} ${l} ${s.x} ${p + h} L ${s.x} ${s.y}` : d = `M ${i.x} ${i.y} L ${i.x} ${p + u} ${l} ${i.x + h} ${p} L ${s.x - u} ${p} ${o} ${s.x} ${p - h} L ${s.x} ${s.y}`;
  } else
    i.y < s.y && (o = "A 20 20, 0, 0, 0,", u = 20, h = 20, f = _r[r.branch].index, d = `M ${i.x} ${i.y} L ${i.x} ${s.y - u} ${o} ${i.x + h} ${s.y} L ${s.x} ${s.y}`), i.y > s.y && (o = "A 20 20, 0, 0, 0,", u = 20, h = 20, f = _r[e.branch].index, d = `M ${i.x} ${i.y} L ${s.x - u} ${i.y} ${o} ${s.x} ${i.y - h} L ${s.x} ${s.y}`), i.y === s.y && (f = _r[e.branch].index, d = `M ${i.x} ${i.y} L ${i.x} ${s.y - u} ${o} ${i.x + h} ${s.y} L ${s.x} ${s.y}`);
  t.append("path").attr("d", d).attr("class", "arrow arrow" + f % Li);
}, bC = (t, e) => {
  const r = t.append("g").attr("class", "commit-arrows");
  Object.keys(e).forEach((n) => {
    const i = e[n];
    i.parents && i.parents.length > 0 && i.parents.forEach((s) => {
      mC(r, e[s], i, e);
    });
  });
}, _C = (t, e) => {
  const r = fo().gitGraph, n = t.append("g");
  e.forEach((i, s) => {
    const a = s % Li, o = _r[i.name].pos, l = n.append("line");
    l.attr("x1", 0), l.attr("y1", o), l.attr("x2", Xl), l.attr("y2", o), l.attr("class", "branch branch" + a), jl.push(o);
    let u = i.name;
    const h = gC(u), f = n.insert("rect"), p = n.insert("g").attr("class", "branchLabel").insert("g").attr("class", "label branch-label" + a);
    p.node().appendChild(h);
    let m = h.getBBox();
    f.attr("class", "branchLabelBkg label" + a).attr("rx", 4).attr("ry", 4).attr("x", -m.width - 4 - (r.rotateCommitLabel === !0 ? 30 : 0)).attr("y", -m.height / 2 + 8).attr("width", m.width + 18).attr("height", m.height + 4), p.attr(
      "transform",
      "translate(" + (-m.width - 14 - (r.rotateCommitLabel === !0 ? 30 : 0)) + ", " + (o - m.height / 2 - 1) + ")"
    ), f.attr("transform", "translate(" + -19 + ", " + (o - m.height / 2) + ")");
  });
}, xC = function(t, e, r, n) {
  pC();
  const i = fo(), s = i.gitGraph;
  B.debug("in gitgraph renderer", t + `
`, "id:", e, r), _a = n.db.getCommits();
  const a = n.db.getBranchesAsObjArray();
  let o = 0;
  a.forEach((u, h) => {
    _r[u.name] = { pos: o, index: h }, o += 50 + (s.rotateCommitLabel ? 40 : 0);
  });
  const l = _t(`[id="${e}"]`);
  xd(l, _a, !1), s.showBranches && _C(l, a), bC(l, _a), xd(l, _a, !0), jt.insertTitle(
    l,
    "gitTitleText",
    s.titleTopMargin,
    n.db.getDiagramTitle()
  ), cy(
    void 0,
    l,
    s.diagramPadding,
    s.useMaxWidth ?? i.useMaxWidth
  );
}, vC = {
  draw: xC
}, kC = (t) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0, 1, 2, 3, 4, 5, 6, 7].map(
  (e) => `
        .branch-label${e} { fill: ${t["gitBranchLabel" + e]}; }
        .commit${e} { stroke: ${t["git" + e]}; fill: ${t["git" + e]}; }
        .commit-highlight${e} { stroke: ${t["gitInv" + e]}; fill: ${t["gitInv" + e]}; }
        .label${e}  { fill: ${t["git" + e]}; }
        .arrow${e} { stroke: ${t["git" + e]}; }
        `
).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${t.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${t.commitLabelFontSize}; fill: ${t.commitLabelColor};}
  .commit-label-bkg { font-size: ${t.commitLabelFontSize}; fill: ${t.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${t.tagLabelFontSize}; fill: ${t.tagLabelColor};}
  .tag-label-bkg { fill: ${t.tagLabelBackground}; stroke: ${t.tagLabelBorder}; }
  .tag-hole { fill: ${t.textColor}; }

  .commit-merge {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
  }
  .commit-reverse {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${t.primaryColor};
    fill: ${t.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${t.textColor};
  }
  }
`, wC = kC;
var Kl = function() {
  var t = function(Bt, bt, mt, wt) {
    for (mt = mt || {}, wt = Bt.length; wt--; mt[Bt[wt]] = bt)
      ;
    return mt;
  }, e = [1, 6], r = [1, 7], n = [1, 8], i = [1, 9], s = [1, 16], a = [1, 11], o = [1, 12], l = [1, 13], u = [1, 14], h = [1, 15], f = [1, 27], d = [1, 33], p = [1, 34], m = [1, 35], _ = [1, 36], v = [1, 37], k = [1, 72], x = [1, 73], D = [1, 74], F = [1, 75], P = [1, 76], V = [1, 77], R = [1, 78], O = [1, 38], C = [1, 39], S = [1, 40], T = [1, 41], b = [1, 42], w = [1, 43], g = [1, 44], M = [1, 45], y = [1, 46], N = [1, 47], it = [1, 48], Y = [1, 49], Z = [1, 50], J = [1, 51], X = [1, 52], tt = [1, 53], st = [1, 54], lt = [1, 55], U = [1, 56], Tt = [1, 57], $ = [1, 59], j = [1, 60], W = [1, 61], z = [1, 62], A = [1, 63], I = [1, 64], G = [1, 65], L = [1, 66], at = [1, 67], E = [1, 68], Dt = [1, 69], et = [24, 52], Et = [24, 44, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], vt = [15, 24, 44, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], pt = [1, 94], ht = [1, 95], gt = [1, 96], ut = [1, 97], yt = [15, 24, 52], ue = [7, 8, 9, 10, 18, 22, 25, 26, 27, 28], re = [15, 24, 43, 52], Mt = [15, 24, 43, 52, 86, 87, 89, 90], Nt = [15, 43], Kt = [44, 46, 47, 48, 49, 50, 51, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], fe = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, direction: 5, directive: 6, direction_tb: 7, direction_bt: 8, direction_rl: 9, direction_lr: 10, graphConfig: 11, openDirective: 12, typeDirective: 13, closeDirective: 14, NEWLINE: 15, ":": 16, argDirective: 17, open_directive: 18, type_directive: 19, arg_directive: 20, close_directive: 21, C4_CONTEXT: 22, statements: 23, EOF: 24, C4_CONTAINER: 25, C4_COMPONENT: 26, C4_DYNAMIC: 27, C4_DEPLOYMENT: 28, otherStatements: 29, diagramStatements: 30, otherStatement: 31, title: 32, accDescription: 33, acc_title: 34, acc_title_value: 35, acc_descr: 36, acc_descr_value: 37, acc_descr_multiline_value: 38, boundaryStatement: 39, boundaryStartStatement: 40, boundaryStopStatement: 41, boundaryStart: 42, LBRACE: 43, ENTERPRISE_BOUNDARY: 44, attributes: 45, SYSTEM_BOUNDARY: 46, BOUNDARY: 47, CONTAINER_BOUNDARY: 48, NODE: 49, NODE_L: 50, NODE_R: 51, RBRACE: 52, diagramStatement: 53, PERSON: 54, PERSON_EXT: 55, SYSTEM: 56, SYSTEM_DB: 57, SYSTEM_QUEUE: 58, SYSTEM_EXT: 59, SYSTEM_EXT_DB: 60, SYSTEM_EXT_QUEUE: 61, CONTAINER: 62, CONTAINER_DB: 63, CONTAINER_QUEUE: 64, CONTAINER_EXT: 65, CONTAINER_EXT_DB: 66, CONTAINER_EXT_QUEUE: 67, COMPONENT: 68, COMPONENT_DB: 69, COMPONENT_QUEUE: 70, COMPONENT_EXT: 71, COMPONENT_EXT_DB: 72, COMPONENT_EXT_QUEUE: 73, REL: 74, BIREL: 75, REL_U: 76, REL_D: 77, REL_L: 78, REL_R: 79, REL_B: 80, REL_INDEX: 81, UPDATE_EL_STYLE: 82, UPDATE_REL_STYLE: 83, UPDATE_LAYOUT_CONFIG: 84, attribute: 85, STR: 86, STR_KEY: 87, STR_VALUE: 88, ATTRIBUTE: 89, ATTRIBUTE_EMPTY: 90, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 7: "direction_tb", 8: "direction_bt", 9: "direction_rl", 10: "direction_lr", 15: "NEWLINE", 16: ":", 18: "open_directive", 19: "type_directive", 20: "arg_directive", 21: "close_directive", 22: "C4_CONTEXT", 24: "EOF", 25: "C4_CONTAINER", 26: "C4_COMPONENT", 27: "C4_DYNAMIC", 28: "C4_DEPLOYMENT", 32: "title", 33: "accDescription", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 43: "LBRACE", 44: "ENTERPRISE_BOUNDARY", 46: "SYSTEM_BOUNDARY", 47: "BOUNDARY", 48: "CONTAINER_BOUNDARY", 49: "NODE", 50: "NODE_L", 51: "NODE_R", 52: "RBRACE", 54: "PERSON", 55: "PERSON_EXT", 56: "SYSTEM", 57: "SYSTEM_DB", 58: "SYSTEM_QUEUE", 59: "SYSTEM_EXT", 60: "SYSTEM_EXT_DB", 61: "SYSTEM_EXT_QUEUE", 62: "CONTAINER", 63: "CONTAINER_DB", 64: "CONTAINER_QUEUE", 65: "CONTAINER_EXT", 66: "CONTAINER_EXT_DB", 67: "CONTAINER_EXT_QUEUE", 68: "COMPONENT", 69: "COMPONENT_DB", 70: "COMPONENT_QUEUE", 71: "COMPONENT_EXT", 72: "COMPONENT_EXT_DB", 73: "COMPONENT_EXT_QUEUE", 74: "REL", 75: "BIREL", 76: "REL_U", 77: "REL_D", 78: "REL_L", 79: "REL_R", 80: "REL_B", 81: "REL_INDEX", 82: "UPDATE_EL_STYLE", 83: "UPDATE_REL_STYLE", 84: "UPDATE_LAYOUT_CONFIG", 86: "STR", 87: "STR_KEY", 88: "STR_VALUE", 89: "ATTRIBUTE", 90: "ATTRIBUTE_EMPTY" },
    productions_: [0, [3, 1], [3, 1], [3, 2], [5, 1], [5, 1], [5, 1], [5, 1], [4, 1], [6, 4], [6, 6], [12, 1], [13, 1], [17, 1], [14, 1], [11, 4], [11, 4], [11, 4], [11, 4], [11, 4], [23, 1], [23, 1], [23, 2], [29, 1], [29, 2], [29, 3], [31, 1], [31, 1], [31, 2], [31, 2], [31, 1], [39, 3], [40, 3], [40, 3], [40, 4], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [41, 1], [30, 1], [30, 2], [30, 3], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 1], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [45, 1], [45, 2], [85, 1], [85, 2], [85, 1], [85, 1]],
    performAction: function(bt, mt, wt, ft, It, nt, Wt) {
      var ct = nt.length - 1;
      switch (It) {
        case 4:
          ft.setDirection("TB");
          break;
        case 5:
          ft.setDirection("BT");
          break;
        case 6:
          ft.setDirection("RL");
          break;
        case 7:
          ft.setDirection("LR");
          break;
        case 11:
          ft.parseDirective("%%{", "open_directive");
          break;
        case 12:
          break;
        case 13:
          nt[ct] = nt[ct].trim().replace(/'/g, '"'), ft.parseDirective(nt[ct], "arg_directive");
          break;
        case 14:
          ft.parseDirective("}%%", "close_directive", "c4Context");
          break;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
          ft.setC4Type(nt[ct - 3]);
          break;
        case 26:
          ft.setTitle(nt[ct].substring(6)), this.$ = nt[ct].substring(6);
          break;
        case 27:
          ft.setAccDescription(nt[ct].substring(15)), this.$ = nt[ct].substring(15);
          break;
        case 28:
          this.$ = nt[ct].trim(), ft.setTitle(this.$);
          break;
        case 29:
        case 30:
          this.$ = nt[ct].trim(), ft.setAccDescription(this.$);
          break;
        case 35:
        case 36:
          nt[ct].splice(2, 0, "ENTERPRISE"), ft.addPersonOrSystemBoundary(...nt[ct]), this.$ = nt[ct];
          break;
        case 37:
          ft.addPersonOrSystemBoundary(...nt[ct]), this.$ = nt[ct];
          break;
        case 38:
          nt[ct].splice(2, 0, "CONTAINER"), ft.addContainerBoundary(...nt[ct]), this.$ = nt[ct];
          break;
        case 39:
          ft.addDeploymentNode("node", ...nt[ct]), this.$ = nt[ct];
          break;
        case 40:
          ft.addDeploymentNode("nodeL", ...nt[ct]), this.$ = nt[ct];
          break;
        case 41:
          ft.addDeploymentNode("nodeR", ...nt[ct]), this.$ = nt[ct];
          break;
        case 42:
          ft.popBoundaryParseStack();
          break;
        case 46:
          ft.addPersonOrSystem("person", ...nt[ct]), this.$ = nt[ct];
          break;
        case 47:
          ft.addPersonOrSystem("external_person", ...nt[ct]), this.$ = nt[ct];
          break;
        case 48:
          ft.addPersonOrSystem("system", ...nt[ct]), this.$ = nt[ct];
          break;
        case 49:
          ft.addPersonOrSystem("system_db", ...nt[ct]), this.$ = nt[ct];
          break;
        case 50:
          ft.addPersonOrSystem("system_queue", ...nt[ct]), this.$ = nt[ct];
          break;
        case 51:
          ft.addPersonOrSystem("external_system", ...nt[ct]), this.$ = nt[ct];
          break;
        case 52:
          ft.addPersonOrSystem("external_system_db", ...nt[ct]), this.$ = nt[ct];
          break;
        case 53:
          ft.addPersonOrSystem("external_system_queue", ...nt[ct]), this.$ = nt[ct];
          break;
        case 54:
          ft.addContainer("container", ...nt[ct]), this.$ = nt[ct];
          break;
        case 55:
          ft.addContainer("container_db", ...nt[ct]), this.$ = nt[ct];
          break;
        case 56:
          ft.addContainer("container_queue", ...nt[ct]), this.$ = nt[ct];
          break;
        case 57:
          ft.addContainer("external_container", ...nt[ct]), this.$ = nt[ct];
          break;
        case 58:
          ft.addContainer("external_container_db", ...nt[ct]), this.$ = nt[ct];
          break;
        case 59:
          ft.addContainer("external_container_queue", ...nt[ct]), this.$ = nt[ct];
          break;
        case 60:
          ft.addComponent("component", ...nt[ct]), this.$ = nt[ct];
          break;
        case 61:
          ft.addComponent("component_db", ...nt[ct]), this.$ = nt[ct];
          break;
        case 62:
          ft.addComponent("component_queue", ...nt[ct]), this.$ = nt[ct];
          break;
        case 63:
          ft.addComponent("external_component", ...nt[ct]), this.$ = nt[ct];
          break;
        case 64:
          ft.addComponent("external_component_db", ...nt[ct]), this.$ = nt[ct];
          break;
        case 65:
          ft.addComponent("external_component_queue", ...nt[ct]), this.$ = nt[ct];
          break;
        case 67:
          ft.addRel("rel", ...nt[ct]), this.$ = nt[ct];
          break;
        case 68:
          ft.addRel("birel", ...nt[ct]), this.$ = nt[ct];
          break;
        case 69:
          ft.addRel("rel_u", ...nt[ct]), this.$ = nt[ct];
          break;
        case 70:
          ft.addRel("rel_d", ...nt[ct]), this.$ = nt[ct];
          break;
        case 71:
          ft.addRel("rel_l", ...nt[ct]), this.$ = nt[ct];
          break;
        case 72:
          ft.addRel("rel_r", ...nt[ct]), this.$ = nt[ct];
          break;
        case 73:
          ft.addRel("rel_b", ...nt[ct]), this.$ = nt[ct];
          break;
        case 74:
          nt[ct].splice(0, 1), ft.addRel("rel", ...nt[ct]), this.$ = nt[ct];
          break;
        case 75:
          ft.updateElStyle("update_el_style", ...nt[ct]), this.$ = nt[ct];
          break;
        case 76:
          ft.updateRelStyle("update_rel_style", ...nt[ct]), this.$ = nt[ct];
          break;
        case 77:
          ft.updateLayoutConfig("update_layout_config", ...nt[ct]), this.$ = nt[ct];
          break;
        case 78:
          this.$ = [nt[ct]];
          break;
        case 79:
          nt[ct].unshift(nt[ct - 1]), this.$ = nt[ct];
          break;
        case 80:
        case 82:
          this.$ = nt[ct].trim();
          break;
        case 81:
          let qt = {};
          qt[nt[ct - 1].trim()] = nt[ct].trim(), this.$ = qt;
          break;
        case 83:
          this.$ = "";
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: 4, 7: e, 8: r, 9: n, 10: i, 11: 5, 12: 10, 18: s, 22: a, 25: o, 26: l, 27: u, 28: h }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 3: 17, 4: 2, 5: 3, 6: 4, 7: e, 8: r, 9: n, 10: i, 11: 5, 12: 10, 18: s, 22: a, 25: o, 26: l, 27: u, 28: h }, { 1: [2, 8] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 1: [2, 7] }, { 13: 18, 19: [1, 19] }, { 15: [1, 20] }, { 15: [1, 21] }, { 15: [1, 22] }, { 15: [1, 23] }, { 15: [1, 24] }, { 19: [2, 11] }, { 1: [2, 3] }, { 14: 25, 16: [1, 26], 21: f }, t([16, 21], [2, 12]), { 23: 28, 29: 29, 30: 30, 31: 31, 32: d, 33: p, 34: m, 36: _, 38: v, 39: 58, 40: 70, 42: 71, 44: k, 46: x, 47: D, 48: F, 49: P, 50: V, 51: R, 53: 32, 54: O, 55: C, 56: S, 57: T, 58: b, 59: w, 60: g, 61: M, 62: y, 63: N, 64: it, 65: Y, 66: Z, 67: J, 68: X, 69: tt, 70: st, 71: lt, 72: U, 73: Tt, 74: $, 75: j, 76: W, 77: z, 78: A, 79: I, 80: G, 81: L, 82: at, 83: E, 84: Dt }, { 23: 79, 29: 29, 30: 30, 31: 31, 32: d, 33: p, 34: m, 36: _, 38: v, 39: 58, 40: 70, 42: 71, 44: k, 46: x, 47: D, 48: F, 49: P, 50: V, 51: R, 53: 32, 54: O, 55: C, 56: S, 57: T, 58: b, 59: w, 60: g, 61: M, 62: y, 63: N, 64: it, 65: Y, 66: Z, 67: J, 68: X, 69: tt, 70: st, 71: lt, 72: U, 73: Tt, 74: $, 75: j, 76: W, 77: z, 78: A, 79: I, 80: G, 81: L, 82: at, 83: E, 84: Dt }, { 23: 80, 29: 29, 30: 30, 31: 31, 32: d, 33: p, 34: m, 36: _, 38: v, 39: 58, 40: 70, 42: 71, 44: k, 46: x, 47: D, 48: F, 49: P, 50: V, 51: R, 53: 32, 54: O, 55: C, 56: S, 57: T, 58: b, 59: w, 60: g, 61: M, 62: y, 63: N, 64: it, 65: Y, 66: Z, 67: J, 68: X, 69: tt, 70: st, 71: lt, 72: U, 73: Tt, 74: $, 75: j, 76: W, 77: z, 78: A, 79: I, 80: G, 81: L, 82: at, 83: E, 84: Dt }, { 23: 81, 29: 29, 30: 30, 31: 31, 32: d, 33: p, 34: m, 36: _, 38: v, 39: 58, 40: 70, 42: 71, 44: k, 46: x, 47: D, 48: F, 49: P, 50: V, 51: R, 53: 32, 54: O, 55: C, 56: S, 57: T, 58: b, 59: w, 60: g, 61: M, 62: y, 63: N, 64: it, 65: Y, 66: Z, 67: J, 68: X, 69: tt, 70: st, 71: lt, 72: U, 73: Tt, 74: $, 75: j, 76: W, 77: z, 78: A, 79: I, 80: G, 81: L, 82: at, 83: E, 84: Dt }, { 23: 82, 29: 29, 30: 30, 31: 31, 32: d, 33: p, 34: m, 36: _, 38: v, 39: 58, 40: 70, 42: 71, 44: k, 46: x, 47: D, 48: F, 49: P, 50: V, 51: R, 53: 32, 54: O, 55: C, 56: S, 57: T, 58: b, 59: w, 60: g, 61: M, 62: y, 63: N, 64: it, 65: Y, 66: Z, 67: J, 68: X, 69: tt, 70: st, 71: lt, 72: U, 73: Tt, 74: $, 75: j, 76: W, 77: z, 78: A, 79: I, 80: G, 81: L, 82: at, 83: E, 84: Dt }, { 15: [1, 83] }, { 17: 84, 20: [1, 85] }, { 15: [2, 14] }, { 24: [1, 86] }, t(et, [2, 20], { 53: 32, 39: 58, 40: 70, 42: 71, 30: 87, 44: k, 46: x, 47: D, 48: F, 49: P, 50: V, 51: R, 54: O, 55: C, 56: S, 57: T, 58: b, 59: w, 60: g, 61: M, 62: y, 63: N, 64: it, 65: Y, 66: Z, 67: J, 68: X, 69: tt, 70: st, 71: lt, 72: U, 73: Tt, 74: $, 75: j, 76: W, 77: z, 78: A, 79: I, 80: G, 81: L, 82: at, 83: E, 84: Dt }), t(et, [2, 21]), t(Et, [2, 23], { 15: [1, 88] }), t(et, [2, 43], { 15: [1, 89] }), t(vt, [2, 26]), t(vt, [2, 27]), { 35: [1, 90] }, { 37: [1, 91] }, t(vt, [2, 30]), { 45: 92, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 98, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 99, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 100, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 101, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 102, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 103, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 104, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 105, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 106, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 107, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 108, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 109, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 110, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 111, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 112, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 113, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 114, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 115, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 116, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, t(yt, [2, 66]), { 45: 117, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 118, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 119, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 120, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 121, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 122, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 123, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 124, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 125, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 126, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 127, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 30: 128, 39: 58, 40: 70, 42: 71, 44: k, 46: x, 47: D, 48: F, 49: P, 50: V, 51: R, 53: 32, 54: O, 55: C, 56: S, 57: T, 58: b, 59: w, 60: g, 61: M, 62: y, 63: N, 64: it, 65: Y, 66: Z, 67: J, 68: X, 69: tt, 70: st, 71: lt, 72: U, 73: Tt, 74: $, 75: j, 76: W, 77: z, 78: A, 79: I, 80: G, 81: L, 82: at, 83: E, 84: Dt }, { 15: [1, 130], 43: [1, 129] }, { 45: 131, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 132, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 133, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 134, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 135, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 136, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 45: 137, 85: 93, 86: pt, 87: ht, 89: gt, 90: ut }, { 24: [1, 138] }, { 24: [1, 139] }, { 24: [1, 140] }, { 24: [1, 141] }, t(ue, [2, 9]), { 14: 142, 21: f }, { 21: [2, 13] }, { 1: [2, 15] }, t(et, [2, 22]), t(Et, [2, 24], { 31: 31, 29: 143, 32: d, 33: p, 34: m, 36: _, 38: v }), t(et, [2, 44], { 29: 29, 30: 30, 31: 31, 53: 32, 39: 58, 40: 70, 42: 71, 23: 144, 32: d, 33: p, 34: m, 36: _, 38: v, 44: k, 46: x, 47: D, 48: F, 49: P, 50: V, 51: R, 54: O, 55: C, 56: S, 57: T, 58: b, 59: w, 60: g, 61: M, 62: y, 63: N, 64: it, 65: Y, 66: Z, 67: J, 68: X, 69: tt, 70: st, 71: lt, 72: U, 73: Tt, 74: $, 75: j, 76: W, 77: z, 78: A, 79: I, 80: G, 81: L, 82: at, 83: E, 84: Dt }), t(vt, [2, 28]), t(vt, [2, 29]), t(yt, [2, 46]), t(re, [2, 78], { 85: 93, 45: 145, 86: pt, 87: ht, 89: gt, 90: ut }), t(Mt, [2, 80]), { 88: [1, 146] }, t(Mt, [2, 82]), t(Mt, [2, 83]), t(yt, [2, 47]), t(yt, [2, 48]), t(yt, [2, 49]), t(yt, [2, 50]), t(yt, [2, 51]), t(yt, [2, 52]), t(yt, [2, 53]), t(yt, [2, 54]), t(yt, [2, 55]), t(yt, [2, 56]), t(yt, [2, 57]), t(yt, [2, 58]), t(yt, [2, 59]), t(yt, [2, 60]), t(yt, [2, 61]), t(yt, [2, 62]), t(yt, [2, 63]), t(yt, [2, 64]), t(yt, [2, 65]), t(yt, [2, 67]), t(yt, [2, 68]), t(yt, [2, 69]), t(yt, [2, 70]), t(yt, [2, 71]), t(yt, [2, 72]), t(yt, [2, 73]), t(yt, [2, 74]), t(yt, [2, 75]), t(yt, [2, 76]), t(yt, [2, 77]), { 41: 147, 52: [1, 148] }, { 15: [1, 149] }, { 43: [1, 150] }, t(Nt, [2, 35]), t(Nt, [2, 36]), t(Nt, [2, 37]), t(Nt, [2, 38]), t(Nt, [2, 39]), t(Nt, [2, 40]), t(Nt, [2, 41]), { 1: [2, 16] }, { 1: [2, 17] }, { 1: [2, 18] }, { 1: [2, 19] }, { 15: [1, 151] }, t(Et, [2, 25]), t(et, [2, 45]), t(re, [2, 79]), t(Mt, [2, 81]), t(yt, [2, 31]), t(yt, [2, 42]), t(Kt, [2, 32]), t(Kt, [2, 33], { 15: [1, 152] }), t(ue, [2, 10]), t(Kt, [2, 34])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 5: [2, 8], 6: [2, 4], 7: [2, 5], 8: [2, 6], 9: [2, 7], 16: [2, 11], 17: [2, 3], 27: [2, 14], 85: [2, 13], 86: [2, 15], 138: [2, 16], 139: [2, 17], 140: [2, 18], 141: [2, 19] },
    parseError: function(bt, mt) {
      if (mt.recoverable)
        this.trace(bt);
      else {
        var wt = new Error(bt);
        throw wt.hash = mt, wt;
      }
    },
    parse: function(bt) {
      var mt = this, wt = [0], ft = [], It = [null], nt = [], Wt = this.table, ct = "", qt = 0, Jt = 0, se = 2, ne = 1, ae = nt.slice.call(arguments, 1), Rt = Object.create(this.lexer), Ht = { yy: {} };
      for (var ie in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ie) && (Ht.yy[ie] = this.yy[ie]);
      Rt.setInput(bt, Ht.yy), Ht.yy.lexer = Rt, Ht.yy.parser = this, typeof Rt.yylloc > "u" && (Rt.yylloc = {});
      var Ut = Rt.yylloc;
      nt.push(Ut);
      var Sn = Rt.options && Rt.options.ranges;
      typeof Ht.yy.parseError == "function" ? this.parseError = Ht.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function xi() {
        var K;
        return K = ft.pop() || Rt.lex() || ne, typeof K != "number" && (K instanceof Array && (ft = K, K = ft.pop()), K = mt.symbols_[K] || K), K;
      }
      for (var me, $t, Ce, rr, Se = {}, Ye, be, Je, Ge; ; ) {
        if ($t = wt[wt.length - 1], this.defaultActions[$t] ? Ce = this.defaultActions[$t] : ((me === null || typeof me > "u") && (me = xi()), Ce = Wt[$t] && Wt[$t][me]), typeof Ce > "u" || !Ce.length || !Ce[0]) {
          var Lt = "";
          Ge = [];
          for (Ye in Wt[$t])
            this.terminals_[Ye] && Ye > se && Ge.push("'" + this.terminals_[Ye] + "'");
          Rt.showPosition ? Lt = "Parse error on line " + (qt + 1) + `:
` + Rt.showPosition() + `
Expecting ` + Ge.join(", ") + ", got '" + (this.terminals_[me] || me) + "'" : Lt = "Parse error on line " + (qt + 1) + ": Unexpected " + (me == ne ? "end of input" : "'" + (this.terminals_[me] || me) + "'"), this.parseError(Lt, {
            text: Rt.match,
            token: this.terminals_[me] || me,
            line: Rt.yylineno,
            loc: Ut,
            expected: Ge
          });
        }
        if (Ce[0] instanceof Array && Ce.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + $t + ", token: " + me);
        switch (Ce[0]) {
          case 1:
            wt.push(me), It.push(Rt.yytext), nt.push(Rt.yylloc), wt.push(Ce[1]), me = null, Jt = Rt.yyleng, ct = Rt.yytext, qt = Rt.yylineno, Ut = Rt.yylloc;
            break;
          case 2:
            if (be = this.productions_[Ce[1]][1], Se.$ = It[It.length - be], Se._$ = {
              first_line: nt[nt.length - (be || 1)].first_line,
              last_line: nt[nt.length - 1].last_line,
              first_column: nt[nt.length - (be || 1)].first_column,
              last_column: nt[nt.length - 1].last_column
            }, Sn && (Se._$.range = [
              nt[nt.length - (be || 1)].range[0],
              nt[nt.length - 1].range[1]
            ]), rr = this.performAction.apply(Se, [
              ct,
              Jt,
              qt,
              Ht.yy,
              Ce[1],
              It,
              nt
            ].concat(ae)), typeof rr < "u")
              return rr;
            be && (wt = wt.slice(0, -1 * be * 2), It = It.slice(0, -1 * be), nt = nt.slice(0, -1 * be)), wt.push(this.productions_[Ce[1]][0]), It.push(Se.$), nt.push(Se._$), Je = Wt[wt[wt.length - 2]][wt[wt.length - 1]], wt.push(Je);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, Gt = function() {
    var Bt = {
      EOF: 1,
      parseError: function(mt, wt) {
        if (this.yy.parser)
          this.yy.parser.parseError(mt, wt);
        else
          throw new Error(mt);
      },
      // resets the lexer, sets new input
      setInput: function(bt, mt) {
        return this.yy = mt || this.yy || {}, this._input = bt, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var bt = this._input[0];
        this.yytext += bt, this.yyleng++, this.offset++, this.match += bt, this.matched += bt;
        var mt = bt.match(/(?:\r\n?|\n).*/g);
        return mt ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), bt;
      },
      // unshifts one char (or a string) into the input
      unput: function(bt) {
        var mt = bt.length, wt = bt.split(/(?:\r\n?|\n)/g);
        this._input = bt + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - mt), this.offset -= mt;
        var ft = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), wt.length - 1 && (this.yylineno -= wt.length - 1);
        var It = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: wt ? (wt.length === ft.length ? this.yylloc.first_column : 0) + ft[ft.length - wt.length].length - wt[0].length : this.yylloc.first_column - mt
        }, this.options.ranges && (this.yylloc.range = [It[0], It[0] + this.yyleng - mt]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(bt) {
        this.unput(this.match.slice(bt));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var bt = this.matched.substr(0, this.matched.length - this.match.length);
        return (bt.length > 20 ? "..." : "") + bt.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var bt = this.match;
        return bt.length < 20 && (bt += this._input.substr(0, 20 - bt.length)), (bt.substr(0, 20) + (bt.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var bt = this.pastInput(), mt = new Array(bt.length + 1).join("-");
        return bt + this.upcomingInput() + `
` + mt + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(bt, mt) {
        var wt, ft, It;
        if (this.options.backtrack_lexer && (It = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (It.yylloc.range = this.yylloc.range.slice(0))), ft = bt[0].match(/(?:\r\n?|\n).*/g), ft && (this.yylineno += ft.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: ft ? ft[ft.length - 1].length - ft[ft.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + bt[0].length
        }, this.yytext += bt[0], this.match += bt[0], this.matches = bt, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(bt[0].length), this.matched += bt[0], wt = this.performAction.call(this, this.yy, this, mt, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), wt)
          return wt;
        if (this._backtrack) {
          for (var nt in It)
            this[nt] = It[nt];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var bt, mt, wt, ft;
        this._more || (this.yytext = "", this.match = "");
        for (var It = this._currentRules(), nt = 0; nt < It.length; nt++)
          if (wt = this._input.match(this.rules[It[nt]]), wt && (!mt || wt[0].length > mt[0].length)) {
            if (mt = wt, ft = nt, this.options.backtrack_lexer) {
              if (bt = this.test_match(wt, It[nt]), bt !== !1)
                return bt;
              if (this._backtrack) {
                mt = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return mt ? (bt = this.test_match(mt, It[ft]), bt !== !1 ? bt : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var mt = this.next();
        return mt || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(mt) {
        this.conditionStack.push(mt);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var mt = this.conditionStack.length - 1;
        return mt > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(mt) {
        return mt = this.conditionStack.length - 1 - Math.abs(mt || 0), mt >= 0 ? this.conditionStack[mt] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(mt) {
        this.begin(mt);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function(mt, wt, ft, It) {
        switch (ft) {
          case 0:
            return this.begin("open_directive"), 18;
          case 1:
            return 7;
          case 2:
            return 8;
          case 3:
            return 9;
          case 4:
            return 10;
          case 5:
            return this.begin("type_directive"), 19;
          case 6:
            return this.popState(), this.begin("arg_directive"), 16;
          case 7:
            return this.popState(), this.popState(), 21;
          case 8:
            return 20;
          case 9:
            return 32;
          case 10:
            return 33;
          case 11:
            return this.begin("acc_title"), 34;
          case 12:
            return this.popState(), "acc_title_value";
          case 13:
            return this.begin("acc_descr"), 36;
          case 14:
            return this.popState(), "acc_descr_value";
          case 15:
            this.begin("acc_descr_multiline");
            break;
          case 16:
            this.popState();
            break;
          case 17:
            return "acc_descr_multiline_value";
          case 18:
            break;
          case 19:
            c;
            break;
          case 20:
            return 15;
          case 21:
            break;
          case 22:
            return 22;
          case 23:
            return 25;
          case 24:
            return 26;
          case 25:
            return 27;
          case 26:
            return 28;
          case 27:
            return this.begin("person_ext"), 55;
          case 28:
            return this.begin("person"), 54;
          case 29:
            return this.begin("system_ext_queue"), 61;
          case 30:
            return this.begin("system_ext_db"), 60;
          case 31:
            return this.begin("system_ext"), 59;
          case 32:
            return this.begin("system_queue"), 58;
          case 33:
            return this.begin("system_db"), 57;
          case 34:
            return this.begin("system"), 56;
          case 35:
            return this.begin("boundary"), 47;
          case 36:
            return this.begin("enterprise_boundary"), 44;
          case 37:
            return this.begin("system_boundary"), 46;
          case 38:
            return this.begin("container_ext_queue"), 67;
          case 39:
            return this.begin("container_ext_db"), 66;
          case 40:
            return this.begin("container_ext"), 65;
          case 41:
            return this.begin("container_queue"), 64;
          case 42:
            return this.begin("container_db"), 63;
          case 43:
            return this.begin("container"), 62;
          case 44:
            return this.begin("container_boundary"), 48;
          case 45:
            return this.begin("component_ext_queue"), 73;
          case 46:
            return this.begin("component_ext_db"), 72;
          case 47:
            return this.begin("component_ext"), 71;
          case 48:
            return this.begin("component_queue"), 70;
          case 49:
            return this.begin("component_db"), 69;
          case 50:
            return this.begin("component"), 68;
          case 51:
            return this.begin("node"), 49;
          case 52:
            return this.begin("node"), 49;
          case 53:
            return this.begin("node_l"), 50;
          case 54:
            return this.begin("node_r"), 51;
          case 55:
            return this.begin("rel"), 74;
          case 56:
            return this.begin("birel"), 75;
          case 57:
            return this.begin("rel_u"), 76;
          case 58:
            return this.begin("rel_u"), 76;
          case 59:
            return this.begin("rel_d"), 77;
          case 60:
            return this.begin("rel_d"), 77;
          case 61:
            return this.begin("rel_l"), 78;
          case 62:
            return this.begin("rel_l"), 78;
          case 63:
            return this.begin("rel_r"), 79;
          case 64:
            return this.begin("rel_r"), 79;
          case 65:
            return this.begin("rel_b"), 80;
          case 66:
            return this.begin("rel_index"), 81;
          case 67:
            return this.begin("update_el_style"), 82;
          case 68:
            return this.begin("update_rel_style"), 83;
          case 69:
            return this.begin("update_layout_config"), 84;
          case 70:
            return "EOF_IN_STRUCT";
          case 71:
            return this.begin("attribute"), "ATTRIBUTE_EMPTY";
          case 72:
            this.begin("attribute");
            break;
          case 73:
            this.popState(), this.popState();
            break;
          case 74:
            return 90;
          case 75:
            break;
          case 76:
            return 90;
          case 77:
            this.begin("string");
            break;
          case 78:
            this.popState();
            break;
          case 79:
            return "STR";
          case 80:
            this.begin("string_kv");
            break;
          case 81:
            return this.begin("string_kv_key"), "STR_KEY";
          case 82:
            this.popState(), this.begin("string_kv_value");
            break;
          case 83:
            return "STR_VALUE";
          case 84:
            this.popState(), this.popState();
            break;
          case 85:
            return "STR";
          case 86:
            return "LBRACE";
          case 87:
            return "RBRACE";
          case 88:
            return "SPACE";
          case 89:
            return "EOL";
          case 90:
            return 24;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:title\s[^#\n;]+)/, /^(?:accDescription\s[^#\n;]+)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:C4Context\b)/, /^(?:C4Container\b)/, /^(?:C4Component\b)/, /^(?:C4Dynamic\b)/, /^(?:C4Deployment\b)/, /^(?:Person_Ext\b)/, /^(?:Person\b)/, /^(?:SystemQueue_Ext\b)/, /^(?:SystemDb_Ext\b)/, /^(?:System_Ext\b)/, /^(?:SystemQueue\b)/, /^(?:SystemDb\b)/, /^(?:System\b)/, /^(?:Boundary\b)/, /^(?:Enterprise_Boundary\b)/, /^(?:System_Boundary\b)/, /^(?:ContainerQueue_Ext\b)/, /^(?:ContainerDb_Ext\b)/, /^(?:Container_Ext\b)/, /^(?:ContainerQueue\b)/, /^(?:ContainerDb\b)/, /^(?:Container\b)/, /^(?:Container_Boundary\b)/, /^(?:ComponentQueue_Ext\b)/, /^(?:ComponentDb_Ext\b)/, /^(?:Component_Ext\b)/, /^(?:ComponentQueue\b)/, /^(?:ComponentDb\b)/, /^(?:Component\b)/, /^(?:Deployment_Node\b)/, /^(?:Node\b)/, /^(?:Node_L\b)/, /^(?:Node_R\b)/, /^(?:Rel\b)/, /^(?:BiRel\b)/, /^(?:Rel_Up\b)/, /^(?:Rel_U\b)/, /^(?:Rel_Down\b)/, /^(?:Rel_D\b)/, /^(?:Rel_Left\b)/, /^(?:Rel_L\b)/, /^(?:Rel_Right\b)/, /^(?:Rel_R\b)/, /^(?:Rel_Back\b)/, /^(?:RelIndex\b)/, /^(?:UpdateElementStyle\b)/, /^(?:UpdateRelStyle\b)/, /^(?:UpdateLayoutConfig\b)/, /^(?:$)/, /^(?:[(][ ]*[,])/, /^(?:[(])/, /^(?:[)])/, /^(?:,,)/, /^(?:,)/, /^(?:[ ]*["]["])/, /^(?:[ ]*["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[ ]*[\$])/, /^(?:[^=]*)/, /^(?:[=][ ]*["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:[^,]+)/, /^(?:\{)/, /^(?:\})/, /^(?:[\s]+)/, /^(?:[\n\r]+)/, /^(?:$)/],
      conditions: { acc_descr_multiline: { rules: [16, 17], inclusive: !1 }, acc_descr: { rules: [14], inclusive: !1 }, acc_title: { rules: [12], inclusive: !1 }, close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [7, 8], inclusive: !1 }, type_directive: { rules: [6, 7], inclusive: !1 }, open_directive: { rules: [5], inclusive: !1 }, string_kv_value: { rules: [83, 84], inclusive: !1 }, string_kv_key: { rules: [82], inclusive: !1 }, string_kv: { rules: [81], inclusive: !1 }, string: { rules: [78, 79], inclusive: !1 }, attribute: { rules: [73, 74, 75, 76, 77, 80, 85], inclusive: !1 }, update_layout_config: { rules: [70, 71, 72, 73], inclusive: !1 }, update_rel_style: { rules: [70, 71, 72, 73], inclusive: !1 }, update_el_style: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_b: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_r: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_l: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_d: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_u: { rules: [70, 71, 72, 73], inclusive: !1 }, rel_bi: { rules: [], inclusive: !1 }, rel: { rules: [70, 71, 72, 73], inclusive: !1 }, node_r: { rules: [70, 71, 72, 73], inclusive: !1 }, node_l: { rules: [70, 71, 72, 73], inclusive: !1 }, node: { rules: [70, 71, 72, 73], inclusive: !1 }, index: { rules: [], inclusive: !1 }, rel_index: { rules: [70, 71, 72, 73], inclusive: !1 }, component_ext_queue: { rules: [], inclusive: !1 }, component_ext_db: { rules: [70, 71, 72, 73], inclusive: !1 }, component_ext: { rules: [70, 71, 72, 73], inclusive: !1 }, component_queue: { rules: [70, 71, 72, 73], inclusive: !1 }, component_db: { rules: [70, 71, 72, 73], inclusive: !1 }, component: { rules: [70, 71, 72, 73], inclusive: !1 }, container_boundary: { rules: [70, 71, 72, 73], inclusive: !1 }, container_ext_queue: { rules: [], inclusive: !1 }, container_ext_db: { rules: [70, 71, 72, 73], inclusive: !1 }, container_ext: { rules: [70, 71, 72, 73], inclusive: !1 }, container_queue: { rules: [70, 71, 72, 73], inclusive: !1 }, container_db: { rules: [70, 71, 72, 73], inclusive: !1 }, container: { rules: [70, 71, 72, 73], inclusive: !1 }, birel: { rules: [70, 71, 72, 73], inclusive: !1 }, system_boundary: { rules: [70, 71, 72, 73], inclusive: !1 }, enterprise_boundary: { rules: [70, 71, 72, 73], inclusive: !1 }, boundary: { rules: [70, 71, 72, 73], inclusive: !1 }, system_ext_queue: { rules: [70, 71, 72, 73], inclusive: !1 }, system_ext_db: { rules: [70, 71, 72, 73], inclusive: !1 }, system_ext: { rules: [70, 71, 72, 73], inclusive: !1 }, system_queue: { rules: [70, 71, 72, 73], inclusive: !1 }, system_db: { rules: [70, 71, 72, 73], inclusive: !1 }, system: { rules: [70, 71, 72, 73], inclusive: !1 }, person_ext: { rules: [70, 71, 72, 73], inclusive: !1 }, person: { rules: [70, 71, 72, 73], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 9, 10, 11, 13, 15, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 86, 87, 88, 89, 90], inclusive: !0 } }
    };
    return Bt;
  }();
  fe.lexer = Gt;
  function Ot() {
    this.yy = {};
  }
  return Ot.prototype = fe, fe.Parser = Ot, new Ot();
}();
Kl.parser = Kl;
const TC = Kl, EC = (t) => t.match(/^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/) !== null;
let nn = [], fi = [""], pr = "global", tn = "", kn = [
  {
    alias: "global",
    label: { text: "global" },
    type: { text: "global" },
    tags: null,
    link: null,
    parentBoundary: ""
  }
], $a = [], l0 = "", c0 = !1, Zl = 4, Ql = 2;
var yy;
const CC = function() {
  return yy;
}, SC = function(t) {
  yy = Ur(t, q());
}, AC = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
}, LC = function(t, e, r, n, i, s, a, o, l) {
  if (t == null || e === void 0 || e === null || r === void 0 || r === null || n === void 0 || n === null)
    return;
  let u = {};
  const h = $a.find((f) => f.from === e && f.to === r);
  if (h ? u = h : $a.push(u), u.type = t, u.from = e, u.to = r, u.label = { text: n }, i == null)
    u.techn = { text: "" };
  else if (typeof i == "object") {
    let [f, d] = Object.entries(i)[0];
    u[f] = { text: d };
  } else
    u.techn = { text: i };
  if (s == null)
    u.descr = { text: "" };
  else if (typeof s == "object") {
    let [f, d] = Object.entries(s)[0];
    u[f] = { text: d };
  } else
    u.descr = { text: s };
  if (typeof a == "object") {
    let [f, d] = Object.entries(a)[0];
    u[f] = d;
  } else
    u.sprite = a;
  if (typeof o == "object") {
    let [f, d] = Object.entries(o)[0];
    u[f] = d;
  } else
    u.tags = o;
  if (typeof l == "object") {
    let [f, d] = Object.entries(l)[0];
    u[f] = d;
  } else
    u.link = l;
  u.wrap = mi();
}, BC = function(t, e, r, n, i, s, a) {
  if (e === null || r === null)
    return;
  let o = {};
  const l = nn.find((u) => u.alias === e);
  if (l && e === l.alias ? o = l : (o.alias = e, nn.push(o)), r == null ? o.label = { text: "" } : o.label = { text: r }, n == null)
    o.descr = { text: "" };
  else if (typeof n == "object") {
    let [u, h] = Object.entries(n)[0];
    o[u] = { text: h };
  } else
    o.descr = { text: n };
  if (typeof i == "object") {
    let [u, h] = Object.entries(i)[0];
    o[u] = h;
  } else
    o.sprite = i;
  if (typeof s == "object") {
    let [u, h] = Object.entries(s)[0];
    o[u] = h;
  } else
    o.tags = s;
  if (typeof a == "object") {
    let [u, h] = Object.entries(a)[0];
    o[u] = h;
  } else
    o.link = a;
  o.typeC4Shape = { text: t }, o.parentBoundary = pr, o.wrap = mi();
}, DC = function(t, e, r, n, i, s, a, o) {
  if (e === null || r === null)
    return;
  let l = {};
  const u = nn.find((h) => h.alias === e);
  if (u && e === u.alias ? l = u : (l.alias = e, nn.push(l)), r == null ? l.label = { text: "" } : l.label = { text: r }, n == null)
    l.techn = { text: "" };
  else if (typeof n == "object") {
    let [h, f] = Object.entries(n)[0];
    l[h] = { text: f };
  } else
    l.techn = { text: n };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [h, f] = Object.entries(i)[0];
    l[h] = { text: f };
  } else
    l.descr = { text: i };
  if (typeof s == "object") {
    let [h, f] = Object.entries(s)[0];
    l[h] = f;
  } else
    l.sprite = s;
  if (typeof a == "object") {
    let [h, f] = Object.entries(a)[0];
    l[h] = f;
  } else
    l.tags = a;
  if (typeof o == "object") {
    let [h, f] = Object.entries(o)[0];
    l[h] = f;
  } else
    l.link = o;
  l.wrap = mi(), l.typeC4Shape = { text: t }, l.parentBoundary = pr;
}, IC = function(t, e, r, n, i, s, a, o) {
  if (e === null || r === null)
    return;
  let l = {};
  const u = nn.find((h) => h.alias === e);
  if (u && e === u.alias ? l = u : (l.alias = e, nn.push(l)), r == null ? l.label = { text: "" } : l.label = { text: r }, n == null)
    l.techn = { text: "" };
  else if (typeof n == "object") {
    let [h, f] = Object.entries(n)[0];
    l[h] = { text: f };
  } else
    l.techn = { text: n };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [h, f] = Object.entries(i)[0];
    l[h] = { text: f };
  } else
    l.descr = { text: i };
  if (typeof s == "object") {
    let [h, f] = Object.entries(s)[0];
    l[h] = f;
  } else
    l.sprite = s;
  if (typeof a == "object") {
    let [h, f] = Object.entries(a)[0];
    l[h] = f;
  } else
    l.tags = a;
  if (typeof o == "object") {
    let [h, f] = Object.entries(o)[0];
    l[h] = f;
  } else
    l.link = o;
  l.wrap = mi(), l.typeC4Shape = { text: t }, l.parentBoundary = pr;
}, MC = function(t, e, r, n, i) {
  if (t === null || e === null)
    return;
  let s = {};
  const a = kn.find((o) => o.alias === t);
  if (a && t === a.alias ? s = a : (s.alias = t, kn.push(s)), e == null ? s.label = { text: "" } : s.label = { text: e }, r == null)
    s.type = { text: "system" };
  else if (typeof r == "object") {
    let [o, l] = Object.entries(r)[0];
    s[o] = { text: l };
  } else
    s.type = { text: r };
  if (typeof n == "object") {
    let [o, l] = Object.entries(n)[0];
    s[o] = l;
  } else
    s.tags = n;
  if (typeof i == "object") {
    let [o, l] = Object.entries(i)[0];
    s[o] = l;
  } else
    s.link = i;
  s.parentBoundary = pr, s.wrap = mi(), tn = pr, pr = t, fi.push(tn);
}, NC = function(t, e, r, n, i) {
  if (t === null || e === null)
    return;
  let s = {};
  const a = kn.find((o) => o.alias === t);
  if (a && t === a.alias ? s = a : (s.alias = t, kn.push(s)), e == null ? s.label = { text: "" } : s.label = { text: e }, r == null)
    s.type = { text: "container" };
  else if (typeof r == "object") {
    let [o, l] = Object.entries(r)[0];
    s[o] = { text: l };
  } else
    s.type = { text: r };
  if (typeof n == "object") {
    let [o, l] = Object.entries(n)[0];
    s[o] = l;
  } else
    s.tags = n;
  if (typeof i == "object") {
    let [o, l] = Object.entries(i)[0];
    s[o] = l;
  } else
    s.link = i;
  s.parentBoundary = pr, s.wrap = mi(), tn = pr, pr = t, fi.push(tn);
}, RC = function(t, e, r, n, i, s, a, o) {
  if (e === null || r === null)
    return;
  let l = {};
  const u = kn.find((h) => h.alias === e);
  if (u && e === u.alias ? l = u : (l.alias = e, kn.push(l)), r == null ? l.label = { text: "" } : l.label = { text: r }, n == null)
    l.type = { text: "node" };
  else if (typeof n == "object") {
    let [h, f] = Object.entries(n)[0];
    l[h] = { text: f };
  } else
    l.type = { text: n };
  if (i == null)
    l.descr = { text: "" };
  else if (typeof i == "object") {
    let [h, f] = Object.entries(i)[0];
    l[h] = { text: f };
  } else
    l.descr = { text: i };
  if (typeof a == "object") {
    let [h, f] = Object.entries(a)[0];
    l[h] = f;
  } else
    l.tags = a;
  if (typeof o == "object") {
    let [h, f] = Object.entries(o)[0];
    l[h] = f;
  } else
    l.link = o;
  l.nodeType = t, l.parentBoundary = pr, l.wrap = mi(), tn = pr, pr = e, fi.push(tn);
}, FC = function() {
  pr = tn, fi.pop(), tn = fi.pop(), fi.push(tn);
}, OC = function(t, e, r, n, i, s, a, o, l, u, h) {
  let f = nn.find((d) => d.alias === e);
  if (!(f === void 0 && (f = kn.find((d) => d.alias === e), f === void 0))) {
    if (r != null)
      if (typeof r == "object") {
        let [d, p] = Object.entries(r)[0];
        f[d] = p;
      } else
        f.bgColor = r;
    if (n != null)
      if (typeof n == "object") {
        let [d, p] = Object.entries(n)[0];
        f[d] = p;
      } else
        f.fontColor = n;
    if (i != null)
      if (typeof i == "object") {
        let [d, p] = Object.entries(i)[0];
        f[d] = p;
      } else
        f.borderColor = i;
    if (s != null)
      if (typeof s == "object") {
        let [d, p] = Object.entries(s)[0];
        f[d] = p;
      } else
        f.shadowing = s;
    if (a != null)
      if (typeof a == "object") {
        let [d, p] = Object.entries(a)[0];
        f[d] = p;
      } else
        f.shape = a;
    if (o != null)
      if (typeof o == "object") {
        let [d, p] = Object.entries(o)[0];
        f[d] = p;
      } else
        f.sprite = o;
    if (l != null)
      if (typeof l == "object") {
        let [d, p] = Object.entries(l)[0];
        f[d] = p;
      } else
        f.techn = l;
    if (u != null)
      if (typeof u == "object") {
        let [d, p] = Object.entries(u)[0];
        f[d] = p;
      } else
        f.legendText = u;
    if (h != null)
      if (typeof h == "object") {
        let [d, p] = Object.entries(h)[0];
        f[d] = p;
      } else
        f.legendSprite = h;
  }
}, PC = function(t, e, r, n, i, s, a) {
  const o = $a.find((l) => l.from === e && l.to === r);
  if (o !== void 0) {
    if (n != null)
      if (typeof n == "object") {
        let [l, u] = Object.entries(n)[0];
        o[l] = u;
      } else
        o.textColor = n;
    if (i != null)
      if (typeof i == "object") {
        let [l, u] = Object.entries(i)[0];
        o[l] = u;
      } else
        o.lineColor = i;
    if (s != null)
      if (typeof s == "object") {
        let [l, u] = Object.entries(s)[0];
        o[l] = parseInt(u);
      } else
        o.offsetX = parseInt(s);
    if (a != null)
      if (typeof a == "object") {
        let [l, u] = Object.entries(a)[0];
        o[l] = parseInt(u);
      } else
        o.offsetY = parseInt(a);
  }
}, VC = function(t, e, r) {
  let n = Zl, i = Ql;
  if (typeof e == "object") {
    const s = Object.values(e)[0];
    n = parseInt(s);
  } else
    n = parseInt(e);
  if (typeof r == "object") {
    const s = Object.values(r)[0];
    i = parseInt(s);
  } else
    i = parseInt(r);
  n >= 1 && (Zl = n), i >= 1 && (Ql = i);
}, YC = function() {
  return Zl;
}, zC = function() {
  return Ql;
}, UC = function() {
  return pr;
}, WC = function() {
  return tn;
}, my = function(t) {
  return t == null ? nn : nn.filter((e) => e.parentBoundary === t);
}, HC = function(t) {
  return nn.find((e) => e.alias === t);
}, GC = function(t) {
  return Object.keys(my(t));
}, qC = function(t) {
  return t == null ? kn : kn.filter((e) => e.parentBoundary === t);
}, $C = function() {
  return $a;
}, jC = function() {
  return l0;
}, XC = function(t) {
  c0 = t;
}, mi = function() {
  return c0;
}, KC = function() {
  nn = [], kn = [
    {
      alias: "global",
      label: { text: "global" },
      type: { text: "global" },
      tags: null,
      link: null,
      parentBoundary: ""
    }
  ], tn = "", pr = "global", fi = [""], $a = [], fi = [""], l0 = "", c0 = !1, Zl = 4, Ql = 2;
}, ZC = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25
}, QC = {
  FILLED: 0,
  OPEN: 1
}, JC = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
}, t9 = function(t) {
  l0 = Ur(t, q());
}, by = {
  addPersonOrSystem: BC,
  addPersonOrSystemBoundary: MC,
  addContainer: DC,
  addContainerBoundary: NC,
  addComponent: IC,
  addDeploymentNode: RC,
  popBoundaryParseStack: FC,
  addRel: LC,
  updateElStyle: OC,
  updateRelStyle: PC,
  updateLayoutConfig: VC,
  autoWrap: mi,
  setWrap: XC,
  getC4ShapeArray: my,
  getC4Shape: HC,
  getC4ShapeKeys: GC,
  getBoundarys: qC,
  getCurrentBoundaryParse: UC,
  getParentBoundaryParse: WC,
  getRels: $C,
  getTitle: jC,
  getC4Type: CC,
  getC4ShapeInRow: YC,
  getC4BoundaryInRow: zC,
  setAccTitle: Tr,
  getAccTitle: Dr,
  getAccDescription: Mr,
  setAccDescription: Ir,
  parseDirective: AC,
  getConfig: () => q().c4,
  clear: KC,
  LINETYPE: ZC,
  ARROWTYPE: QC,
  PLACEMENT: JC,
  setTitle: t9,
  setC4Type: SC
  // apply,
}, u0 = function(t, e) {
  const r = t.append("rect");
  if (r.attr("x", e.x), r.attr("y", e.y), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("width", e.width), r.attr("height", e.height), r.attr("rx", e.rx), r.attr("ry", e.ry), e.attrs !== "undefined" && e.attrs !== null)
    for (let n in e.attrs)
      r.attr(n, e.attrs[n]);
  return e.class !== "undefined" && r.attr("class", e.class), r;
}, _y = function(t, e, r, n, i, s) {
  const a = t.append("image");
  a.attr("width", e), a.attr("height", r), a.attr("x", n), a.attr("y", i);
  let o = s.startsWith("data:image/png;base64") ? s : Jn(s);
  a.attr("xlink:href", o);
}, e9 = (t, e, r) => {
  const n = t.append("g");
  let i = 0;
  for (let s of e) {
    let a = s.textColor ? s.textColor : "#444444", o = s.lineColor ? s.lineColor : "#444444", l = s.offsetX ? parseInt(s.offsetX) : 0, u = s.offsetY ? parseInt(s.offsetY) : 0, h = "";
    if (i === 0) {
      let d = n.append("line");
      d.attr("x1", s.startPoint.x), d.attr("y1", s.startPoint.y), d.attr("x2", s.endPoint.x), d.attr("y2", s.endPoint.y), d.attr("stroke-width", "1"), d.attr("stroke", o), d.style("fill", "none"), s.type !== "rel_b" && d.attr("marker-end", "url(" + h + "#arrowhead)"), (s.type === "birel" || s.type === "rel_b") && d.attr("marker-start", "url(" + h + "#arrowend)"), i = -1;
    } else {
      let d = n.append("path");
      d.attr("fill", "none").attr("stroke-width", "1").attr("stroke", o).attr(
        "d",
        "Mstartx,starty Qcontrolx,controly stopx,stopy ".replaceAll("startx", s.startPoint.x).replaceAll("starty", s.startPoint.y).replaceAll(
          "controlx",
          s.startPoint.x + (s.endPoint.x - s.startPoint.x) / 2 - (s.endPoint.x - s.startPoint.x) / 4
        ).replaceAll("controly", s.startPoint.y + (s.endPoint.y - s.startPoint.y) / 2).replaceAll("stopx", s.endPoint.x).replaceAll("stopy", s.endPoint.y)
      ), s.type !== "rel_b" && d.attr("marker-end", "url(" + h + "#arrowhead)"), (s.type === "birel" || s.type === "rel_b") && d.attr("marker-start", "url(" + h + "#arrowend)");
    }
    let f = r.messageFont();
    Hn(r)(
      s.label.text,
      n,
      Math.min(s.startPoint.x, s.endPoint.x) + Math.abs(s.endPoint.x - s.startPoint.x) / 2 + l,
      Math.min(s.startPoint.y, s.endPoint.y) + Math.abs(s.endPoint.y - s.startPoint.y) / 2 + u,
      s.label.width,
      s.label.height,
      { fill: a },
      f
    ), s.techn && s.techn.text !== "" && (f = r.messageFont(), Hn(r)(
      "[" + s.techn.text + "]",
      n,
      Math.min(s.startPoint.x, s.endPoint.x) + Math.abs(s.endPoint.x - s.startPoint.x) / 2 + l,
      Math.min(s.startPoint.y, s.endPoint.y) + Math.abs(s.endPoint.y - s.startPoint.y) / 2 + r.messageFontSize + 5 + u,
      Math.max(s.label.width, s.techn.width),
      s.techn.height,
      { fill: a, "font-style": "italic" },
      f
    ));
  }
}, r9 = function(t, e, r) {
  const n = t.append("g");
  let i = e.bgColor ? e.bgColor : "none", s = e.borderColor ? e.borderColor : "#444444", a = e.fontColor ? e.fontColor : "black", o = { "stroke-width": 1, "stroke-dasharray": "7.0,7.0" };
  e.nodeType && (o = { "stroke-width": 1 });
  let l = {
    x: e.x,
    y: e.y,
    fill: i,
    stroke: s,
    width: e.width,
    height: e.height,
    rx: 2.5,
    ry: 2.5,
    attrs: o
  };
  u0(n, l);
  let u = r.boundaryFont();
  u.fontWeight = "bold", u.fontSize = u.fontSize + 2, u.fontColor = a, Hn(r)(
    e.label.text,
    n,
    e.x,
    e.y + e.label.Y,
    e.width,
    e.height,
    { fill: "#444444" },
    u
  ), e.type && e.type.text !== "" && (u = r.boundaryFont(), u.fontColor = a, Hn(r)(
    e.type.text,
    n,
    e.x,
    e.y + e.type.Y,
    e.width,
    e.height,
    { fill: "#444444" },
    u
  )), e.descr && e.descr.text !== "" && (u = r.boundaryFont(), u.fontSize = u.fontSize - 2, u.fontColor = a, Hn(r)(
    e.descr.text,
    n,
    e.x,
    e.y + e.descr.Y,
    e.width,
    e.height,
    { fill: "#444444" },
    u
  ));
}, n9 = function(t, e, r) {
  var f;
  let n = e.bgColor ? e.bgColor : r[e.typeC4Shape.text + "_bg_color"], i = e.borderColor ? e.borderColor : r[e.typeC4Shape.text + "_border_color"], s = e.fontColor ? e.fontColor : "#FFFFFF", a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
  switch (e.typeC4Shape.text) {
    case "person":
      a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
      break;
    case "external_person":
      a = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII=";
      break;
  }
  const o = t.append("g");
  o.attr("class", "person-man");
  const l = xy();
  switch (e.typeC4Shape.text) {
    case "person":
    case "external_person":
    case "system":
    case "external_system":
    case "container":
    case "external_container":
    case "component":
    case "external_component":
      l.x = e.x, l.y = e.y, l.fill = n, l.width = e.width, l.height = e.height, l.stroke = i, l.rx = 2.5, l.ry = 2.5, l.attrs = { "stroke-width": 0.5 }, u0(o, l);
      break;
    case "system_db":
    case "external_system_db":
    case "container_db":
    case "external_container_db":
    case "component_db":
    case "external_component_db":
      o.append("path").attr("fill", n).attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height".replaceAll("startx", e.x).replaceAll("starty", e.y).replaceAll("half", e.width / 2).replaceAll("height", e.height)
      ), o.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10".replaceAll("startx", e.x).replaceAll("starty", e.y).replaceAll("half", e.width / 2)
      );
      break;
    case "system_queue":
    case "external_system_queue":
    case "container_queue":
    case "external_container_queue":
    case "component_queue":
    case "external_component_queue":
      o.append("path").attr("fill", n).attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half".replaceAll("startx", e.x).replaceAll("starty", e.y).replaceAll("width", e.width).replaceAll("half", e.height / 2)
      ), o.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", i).attr(
        "d",
        "Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half".replaceAll("startx", e.x + e.width).replaceAll("starty", e.y).replaceAll("half", e.height / 2)
      );
      break;
  }
  let u = f9(r, e.typeC4Shape.text);
  switch (o.append("text").attr("fill", s).attr("font-family", u.fontFamily).attr("font-size", u.fontSize - 2).attr("font-style", "italic").attr("lengthAdjust", "spacing").attr("textLength", e.typeC4Shape.width).attr("x", e.x + e.width / 2 - e.typeC4Shape.width / 2).attr("y", e.y + e.typeC4Shape.Y).text("<<" + e.typeC4Shape.text + ">>"), e.typeC4Shape.text) {
    case "person":
    case "external_person":
      _y(
        o,
        48,
        48,
        e.x + e.width / 2 - 24,
        e.y + e.image.Y,
        a
      );
      break;
  }
  let h = r[e.typeC4Shape.text + "Font"]();
  return h.fontWeight = "bold", h.fontSize = h.fontSize + 2, h.fontColor = s, Hn(r)(
    e.label.text,
    o,
    e.x,
    e.y + e.label.Y,
    e.width,
    e.height,
    { fill: s },
    h
  ), h = r[e.typeC4Shape.text + "Font"](), h.fontColor = s, e.techn && ((f = e.techn) == null ? void 0 : f.text) !== "" ? Hn(r)(
    e.techn.text,
    o,
    e.x,
    e.y + e.techn.Y,
    e.width,
    e.height,
    { fill: s, "font-style": "italic" },
    h
  ) : e.type && e.type.text !== "" && Hn(r)(
    e.type.text,
    o,
    e.x,
    e.y + e.type.Y,
    e.width,
    e.height,
    { fill: s, "font-style": "italic" },
    h
  ), e.descr && e.descr.text !== "" && (h = r.personFont(), h.fontColor = s, Hn(r)(
    e.descr.text,
    o,
    e.x,
    e.y + e.descr.Y,
    e.width,
    e.height,
    { fill: s },
    h
  )), e.height;
}, i9 = function(t) {
  t.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
}, s9 = function(t) {
  t.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
}, a9 = function(t) {
  t.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
}, o9 = function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
}, l9 = function(t) {
  t.append("defs").append("marker").attr("id", "arrowend").attr("refX", 1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 10 0 L 0 5 L 10 10 z");
}, c9 = function(t) {
  t.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, u9 = function(t) {
  t.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, h9 = function(t) {
  const r = t.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
  r.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z"), r.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
}, xy = function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, f9 = (t, e) => ({
  fontFamily: t[e + "FontFamily"],
  fontSize: t[e + "FontSize"],
  fontWeight: t[e + "FontWeight"]
}), Hn = function() {
  function t(i, s, a, o, l, u, h) {
    const f = s.append("text").attr("x", a + l / 2).attr("y", o + u / 2 + 5).style("text-anchor", "middle").text(i);
    n(f, h);
  }
  function e(i, s, a, o, l, u, h, f) {
    const { fontSize: d, fontFamily: p, fontWeight: m } = f, _ = i.split(Xt.lineBreakRegex);
    for (let v = 0; v < _.length; v++) {
      const k = v * d - d * (_.length - 1) / 2, x = s.append("text").attr("x", a + l / 2).attr("y", o).style("text-anchor", "middle").attr("dominant-baseline", "middle").style("font-size", d).style("font-weight", m).style("font-family", p);
      x.append("tspan").attr("dy", k).text(_[v]).attr("alignment-baseline", "mathematical"), n(x, h);
    }
  }
  function r(i, s, a, o, l, u, h, f) {
    const d = s.append("switch"), m = d.append("foreignObject").attr("x", a).attr("y", o).attr("width", l).attr("height", u).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    m.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, d, a, o, l, u, h, f), n(m, h);
  }
  function n(i, s) {
    for (const a in s)
      s.hasOwnProperty(a) && i.attr(a, s[a]);
  }
  return function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
}(), pn = {
  drawRect: u0,
  drawBoundary: r9,
  drawC4Shape: n9,
  drawRels: e9,
  drawImage: _y,
  insertArrowHead: o9,
  insertArrowEnd: l9,
  insertArrowFilledHead: c9,
  insertDynamicNumber: u9,
  insertArrowCrossHead: h9,
  insertDatabaseIcon: i9,
  insertComputerIcon: s9,
  insertClockIcon: a9,
  getNoteRect: xy,
  sanitizeUrl: Jn
  // TODO why is this exported?
};
let Jl = 0, tc = 0, vy = 4, Nh = 2;
Kl.yy = by;
let Ft = {};
class ky {
  constructor(e) {
    this.name = "", this.data = {}, this.data.startx = void 0, this.data.stopx = void 0, this.data.starty = void 0, this.data.stopy = void 0, this.data.widthLimit = void 0, this.nextData = {}, this.nextData.startx = void 0, this.nextData.stopx = void 0, this.nextData.starty = void 0, this.nextData.stopy = void 0, this.nextData.cnt = 0, Rh(e.db.getConfig());
  }
  setData(e, r, n, i) {
    this.nextData.startx = this.data.startx = e, this.nextData.stopx = this.data.stopx = r, this.nextData.starty = this.data.starty = n, this.nextData.stopy = this.data.stopy = i;
  }
  updateVal(e, r, n, i) {
    e[r] === void 0 ? e[r] = n : e[r] = i(n, e[r]);
  }
  insert(e) {
    this.nextData.cnt = this.nextData.cnt + 1;
    let r = this.nextData.startx === this.nextData.stopx ? this.nextData.stopx + e.margin : this.nextData.stopx + e.margin * 2, n = r + e.width, i = this.nextData.starty + e.margin * 2, s = i + e.height;
    (r >= this.data.widthLimit || n >= this.data.widthLimit || this.nextData.cnt > vy) && (r = this.nextData.startx + e.margin + Ft.nextLinePaddingX, i = this.nextData.stopy + e.margin * 2, this.nextData.stopx = n = r + e.width, this.nextData.starty = this.nextData.stopy, this.nextData.stopy = s = i + e.height, this.nextData.cnt = 1), e.x = r, e.y = i, this.updateVal(this.data, "startx", r, Math.min), this.updateVal(this.data, "starty", i, Math.min), this.updateVal(this.data, "stopx", n, Math.max), this.updateVal(this.data, "stopy", s, Math.max), this.updateVal(this.nextData, "startx", r, Math.min), this.updateVal(this.nextData, "starty", i, Math.min), this.updateVal(this.nextData, "stopx", n, Math.max), this.updateVal(this.nextData, "stopy", s, Math.max);
  }
  init(e) {
    this.name = "", this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      widthLimit: void 0
    }, this.nextData = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      cnt: 0
    }, Rh(e.db.getConfig());
  }
  bumpLastMargin(e) {
    this.data.stopx += e, this.data.stopy += e;
  }
}
const Rh = function(t) {
  Xe(Ft, t), t.fontFamily && (Ft.personFontFamily = Ft.systemFontFamily = Ft.messageFontFamily = t.fontFamily), t.fontSize && (Ft.personFontSize = Ft.systemFontSize = Ft.messageFontSize = t.fontSize), t.fontWeight && (Ft.personFontWeight = Ft.systemFontWeight = Ft.messageFontWeight = t.fontWeight);
}, ua = (t, e) => ({
  fontFamily: t[e + "FontFamily"],
  fontSize: t[e + "FontSize"],
  fontWeight: t[e + "FontWeight"]
}), al = (t) => ({
  fontFamily: t.boundaryFontFamily,
  fontSize: t.boundaryFontSize,
  fontWeight: t.boundaryFontWeight
}), d9 = (t) => ({
  fontFamily: t.messageFontFamily,
  fontSize: t.messageFontSize,
  fontWeight: t.messageFontWeight
});
function Kr(t, e, r, n, i) {
  if (!e[t].width)
    if (r)
      e[t].text = zg(e[t].text, i, n), e[t].textLines = e[t].text.split(Xt.lineBreakRegex).length, e[t].width = i, e[t].height = Ch(e[t].text, n);
    else {
      let s = e[t].text.split(Xt.lineBreakRegex);
      e[t].textLines = s.length;
      let a = 0;
      e[t].height = 0, e[t].width = 0;
      for (const o of s)
        e[t].width = Math.max(
          vn(o, n),
          e[t].width
        ), a = Ch(o, n), e[t].height = e[t].height + a;
    }
}
const wy = function(t, e, r) {
  e.x = r.data.startx, e.y = r.data.starty, e.width = r.data.stopx - r.data.startx, e.height = r.data.stopy - r.data.starty, e.label.y = Ft.c4ShapeMargin - 35;
  let n = e.wrap && Ft.wrap, i = al(Ft);
  i.fontSize = i.fontSize + 2, i.fontWeight = "bold";
  let s = vn(e.label.text, i);
  Kr("label", e, n, i, s), pn.drawBoundary(t, e, Ft);
}, Ty = function(t, e, r, n) {
  let i = 0;
  for (const s of n) {
    i = 0;
    const a = r[s];
    let o = ua(Ft, a.typeC4Shape.text);
    switch (o.fontSize = o.fontSize - 2, a.typeC4Shape.width = vn(
      "<<" + a.typeC4Shape.text + ">>",
      o
    ), a.typeC4Shape.height = o.fontSize + 2, a.typeC4Shape.Y = Ft.c4ShapePadding, i = a.typeC4Shape.Y + a.typeC4Shape.height - 4, a.image = { width: 0, height: 0, Y: 0 }, a.typeC4Shape.text) {
      case "person":
      case "external_person":
        a.image.width = 48, a.image.height = 48, a.image.Y = i, i = a.image.Y + a.image.height;
        break;
    }
    a.sprite && (a.image.width = 48, a.image.height = 48, a.image.Y = i, i = a.image.Y + a.image.height);
    let l = a.wrap && Ft.wrap, u = Ft.width - Ft.c4ShapePadding * 2, h = ua(Ft, a.typeC4Shape.text);
    if (h.fontSize = h.fontSize + 2, h.fontWeight = "bold", Kr("label", a, l, h, u), a.label.Y = i + 8, i = a.label.Y + a.label.height, a.type && a.type.text !== "") {
      a.type.text = "[" + a.type.text + "]";
      let p = ua(Ft, a.typeC4Shape.text);
      Kr("type", a, l, p, u), a.type.Y = i + 5, i = a.type.Y + a.type.height;
    } else if (a.techn && a.techn.text !== "") {
      a.techn.text = "[" + a.techn.text + "]";
      let p = ua(Ft, a.techn.text);
      Kr("techn", a, l, p, u), a.techn.Y = i + 5, i = a.techn.Y + a.techn.height;
    }
    let f = i, d = a.label.width;
    if (a.descr && a.descr.text !== "") {
      let p = ua(Ft, a.typeC4Shape.text);
      Kr("descr", a, l, p, u), a.descr.Y = i + 20, i = a.descr.Y + a.descr.height, d = Math.max(a.label.width, a.descr.width), f = i - a.descr.textLines * 5;
    }
    d = d + Ft.c4ShapePadding, a.width = Math.max(a.width || Ft.width, d, Ft.width), a.height = Math.max(a.height || Ft.height, f, Ft.height), a.margin = a.margin || Ft.c4ShapeMargin, t.insert(a), pn.drawC4Shape(e, a, Ft);
  }
  t.bumpLastMargin(Ft.c4ShapeMargin);
};
class Or {
  constructor(e, r) {
    this.x = e, this.y = r;
  }
}
let vd = function(t, e) {
  let r = t.x, n = t.y, i = e.x, s = e.y, a = r + t.width / 2, o = n + t.height / 2, l = Math.abs(r - i), u = Math.abs(n - s), h = u / l, f = t.height / t.width, d = null;
  return n == s && r < i ? d = new Or(r + t.width, o) : n == s && r > i ? d = new Or(r, o) : r == i && n < s ? d = new Or(a, n + t.height) : r == i && n > s && (d = new Or(a, n)), r > i && n < s ? f >= h ? d = new Or(r, o + h * t.width / 2) : d = new Or(
    a - l / u * t.height / 2,
    n + t.height
  ) : r < i && n < s ? f >= h ? d = new Or(r + t.width, o + h * t.width / 2) : d = new Or(
    a + l / u * t.height / 2,
    n + t.height
  ) : r < i && n > s ? f >= h ? d = new Or(r + t.width, o - h * t.width / 2) : d = new Or(a + t.height / 2 * l / u, n) : r > i && n > s && (f >= h ? d = new Or(r, o - t.width / 2 * h) : d = new Or(a - t.height / 2 * l / u, n)), d;
}, p9 = function(t, e) {
  let r = { x: 0, y: 0 };
  r.x = e.x + e.width / 2, r.y = e.y + e.height / 2;
  let n = vd(t, r);
  r.x = t.x + t.width / 2, r.y = t.y + t.height / 2;
  let i = vd(e, r);
  return { startPoint: n, endPoint: i };
};
const g9 = function(t, e, r, n) {
  let i = 0;
  for (let s of e) {
    i = i + 1;
    let a = s.wrap && Ft.wrap, o = d9(Ft);
    n.db.getC4Type() === "C4Dynamic" && (s.label.text = i + ": " + s.label.text);
    let u = vn(s.label.text, o);
    Kr("label", s, a, o, u), s.techn && s.techn.text !== "" && (u = vn(s.techn.text, o), Kr("techn", s, a, o, u)), s.descr && s.descr.text !== "" && (u = vn(s.descr.text, o), Kr("descr", s, a, o, u));
    let h = r(s.from), f = r(s.to), d = p9(h, f);
    s.startPoint = d.startPoint, s.endPoint = d.endPoint;
  }
  pn.drawRels(t, e, Ft);
};
function Ey(t, e, r, n, i) {
  let s = new ky(i);
  s.data.widthLimit = r.data.widthLimit / Math.min(Nh, n.length);
  for (let [a, o] of n.entries()) {
    let l = 0;
    o.image = { width: 0, height: 0, Y: 0 }, o.sprite && (o.image.width = 48, o.image.height = 48, o.image.Y = l, l = o.image.Y + o.image.height);
    let u = o.wrap && Ft.wrap, h = al(Ft);
    if (h.fontSize = h.fontSize + 2, h.fontWeight = "bold", Kr(
      "label",
      o,
      u,
      h,
      s.data.widthLimit
    ), o.label.Y = l + 8, l = o.label.Y + o.label.height, o.type && o.type.text !== "") {
      o.type.text = "[" + o.type.text + "]";
      let m = al(Ft);
      Kr(
        "type",
        o,
        u,
        m,
        s.data.widthLimit
      ), o.type.Y = l + 5, l = o.type.Y + o.type.height;
    }
    if (o.descr && o.descr.text !== "") {
      let m = al(Ft);
      m.fontSize = m.fontSize - 2, Kr(
        "descr",
        o,
        u,
        m,
        s.data.widthLimit
      ), o.descr.Y = l + 20, l = o.descr.Y + o.descr.height;
    }
    if (a == 0 || a % Nh === 0) {
      let m = r.data.startx + Ft.diagramMarginX, _ = r.data.stopy + Ft.diagramMarginY + l;
      s.setData(m, m, _, _);
    } else {
      let m = s.data.stopx !== s.data.startx ? s.data.stopx + Ft.diagramMarginX : s.data.startx, _ = s.data.starty;
      s.setData(m, m, _, _);
    }
    s.name = o.alias;
    let f = i.db.getC4ShapeArray(o.alias), d = i.db.getC4ShapeKeys(o.alias);
    d.length > 0 && Ty(
      s,
      t,
      f,
      d
    ), e = o.alias;
    let p = i.db.getBoundarys(e);
    p.length > 0 && Ey(
      t,
      e,
      s,
      p,
      i
    ), o.alias !== "global" && wy(t, o, s), r.data.stopy = Math.max(
      s.data.stopy + Ft.c4ShapeMargin,
      r.data.stopy
    ), r.data.stopx = Math.max(
      s.data.stopx + Ft.c4ShapeMargin,
      r.data.stopx
    ), Jl = Math.max(Jl, r.data.stopx), tc = Math.max(tc, r.data.stopy);
  }
}
const y9 = function(t, e, r, n) {
  Ft = q().c4;
  const i = q().securityLevel;
  let s;
  i === "sandbox" && (s = _t("#i" + e));
  const a = _t(i === "sandbox" ? s.nodes()[0].contentDocument.body : "body");
  let o = n.db;
  n.db.setWrap(Ft.wrap), vy = o.getC4ShapeInRow(), Nh = o.getC4BoundaryInRow(), B.debug(`C:${JSON.stringify(Ft, null, 2)}`);
  const l = i === "sandbox" ? a.select(`[id="${e}"]`) : _t(`[id="${e}"]`);
  pn.insertComputerIcon(l), pn.insertDatabaseIcon(l), pn.insertClockIcon(l);
  let u = new ky(n);
  u.setData(
    Ft.diagramMarginX,
    Ft.diagramMarginX,
    Ft.diagramMarginY,
    Ft.diagramMarginY
  ), u.data.widthLimit = screen.availWidth, Jl = Ft.diagramMarginX, tc = Ft.diagramMarginY;
  const h = n.db.getTitle();
  let f = n.db.getBoundarys("");
  Ey(l, "", u, f, n), pn.insertArrowHead(l), pn.insertArrowEnd(l), pn.insertArrowCrossHead(l), pn.insertArrowFilledHead(l), g9(l, n.db.getRels(), n.db.getC4Shape, n), u.data.stopx = Jl, u.data.stopy = tc;
  const d = u.data;
  let m = d.stopy - d.starty + 2 * Ft.diagramMarginY;
  const v = d.stopx - d.startx + 2 * Ft.diagramMarginX;
  h && l.append("text").text(h).attr("x", (d.stopx - d.startx) / 2 - 4 * Ft.diagramMarginX).attr("y", d.starty + Ft.diagramMarginY), cn(l, m, v, Ft.useMaxWidth);
  const k = h ? 60 : 0;
  l.attr(
    "viewBox",
    d.startx - Ft.diagramMarginX + " -" + (Ft.diagramMarginY + k) + " " + v + " " + (m + k)
  ), B.debug("models:", d);
}, kd = {
  drawPersonOrSystemArray: Ty,
  drawBoundary: wy,
  setConf: Rh,
  draw: y9
};
var Fh = function() {
  var t = function(z, A, I, G) {
    for (I = I || {}, G = z.length; G--; I[z[G]] = A)
      ;
    return I;
  }, e = [1, 3], r = [1, 7], n = [1, 8], i = [1, 9], s = [1, 10], a = [1, 13], o = [1, 12], l = [1, 16, 25], u = [1, 20], h = [1, 32], f = [1, 33], d = [1, 34], p = [1, 36], m = [1, 39], _ = [1, 37], v = [1, 38], k = [1, 44], x = [1, 45], D = [1, 40], F = [1, 41], P = [1, 42], V = [1, 43], R = [1, 48], O = [1, 49], C = [1, 50], S = [1, 51], T = [16, 25], b = [1, 65], w = [1, 66], g = [1, 67], M = [1, 68], y = [1, 69], N = [1, 70], it = [1, 71], Y = [1, 80], Z = [16, 25, 32, 45, 46, 54, 60, 61, 62, 63, 64, 65, 66, 71, 73], J = [16, 25, 30, 32, 45, 46, 50, 54, 60, 61, 62, 63, 64, 65, 66, 71, 73, 88, 89, 90, 91], X = [5, 8, 9, 10, 11, 16, 19, 23, 25], tt = [54, 88, 89, 90, 91], st = [54, 65, 66, 88, 89, 90, 91], lt = [54, 60, 61, 62, 63, 64, 88, 89, 90, 91], U = [16, 25, 32], Tt = [1, 107], $ = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, statments: 5, direction: 6, directive: 7, direction_tb: 8, direction_bt: 9, direction_rl: 10, direction_lr: 11, graphConfig: 12, openDirective: 13, typeDirective: 14, closeDirective: 15, NEWLINE: 16, ":": 17, argDirective: 18, open_directive: 19, type_directive: 20, arg_directive: 21, close_directive: 22, CLASS_DIAGRAM: 23, statements: 24, EOF: 25, statement: 26, className: 27, alphaNumToken: 28, classLiteralName: 29, GENERICTYPE: 30, relationStatement: 31, LABEL: 32, classStatement: 33, methodStatement: 34, annotationStatement: 35, clickStatement: 36, cssClassStatement: 37, noteStatement: 38, acc_title: 39, acc_title_value: 40, acc_descr: 41, acc_descr_value: 42, acc_descr_multiline_value: 43, CLASS: 44, STYLE_SEPARATOR: 45, STRUCT_START: 46, members: 47, STRUCT_STOP: 48, ANNOTATION_START: 49, ANNOTATION_END: 50, MEMBER: 51, SEPARATOR: 52, relation: 53, STR: 54, NOTE_FOR: 55, noteText: 56, NOTE: 57, relationType: 58, lineType: 59, AGGREGATION: 60, EXTENSION: 61, COMPOSITION: 62, DEPENDENCY: 63, LOLLIPOP: 64, LINE: 65, DOTTED_LINE: 66, CALLBACK: 67, LINK: 68, LINK_TARGET: 69, CLICK: 70, CALLBACK_NAME: 71, CALLBACK_ARGS: 72, HREF: 73, CSSCLASS: 74, commentToken: 75, textToken: 76, graphCodeTokens: 77, textNoTagsToken: 78, TAGSTART: 79, TAGEND: 80, "==": 81, "--": 82, PCT: 83, DEFAULT: 84, SPACE: 85, MINUS: 86, keywords: 87, UNICODE_TEXT: 88, NUM: 89, ALPHA: 90, BQUOTE_STR: 91, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "statments", 8: "direction_tb", 9: "direction_bt", 10: "direction_rl", 11: "direction_lr", 16: "NEWLINE", 17: ":", 19: "open_directive", 20: "type_directive", 21: "arg_directive", 22: "close_directive", 23: "CLASS_DIAGRAM", 25: "EOF", 30: "GENERICTYPE", 32: "LABEL", 39: "acc_title", 40: "acc_title_value", 41: "acc_descr", 42: "acc_descr_value", 43: "acc_descr_multiline_value", 44: "CLASS", 45: "STYLE_SEPARATOR", 46: "STRUCT_START", 48: "STRUCT_STOP", 49: "ANNOTATION_START", 50: "ANNOTATION_END", 51: "MEMBER", 52: "SEPARATOR", 54: "STR", 55: "NOTE_FOR", 57: "NOTE", 60: "AGGREGATION", 61: "EXTENSION", 62: "COMPOSITION", 63: "DEPENDENCY", 64: "LOLLIPOP", 65: "LINE", 66: "DOTTED_LINE", 67: "CALLBACK", 68: "LINK", 69: "LINK_TARGET", 70: "CLICK", 71: "CALLBACK_NAME", 72: "CALLBACK_ARGS", 73: "HREF", 74: "CSSCLASS", 77: "graphCodeTokens", 79: "TAGSTART", 80: "TAGEND", 81: "==", 82: "--", 83: "PCT", 84: "DEFAULT", 85: "SPACE", 86: "MINUS", 87: "keywords", 88: "UNICODE_TEXT", 89: "NUM", 90: "ALPHA", 91: "BQUOTE_STR" },
    productions_: [0, [3, 1], [3, 1], [3, 1], [3, 2], [6, 1], [6, 1], [6, 1], [6, 1], [4, 1], [7, 4], [7, 6], [13, 1], [14, 1], [18, 1], [15, 1], [12, 4], [24, 1], [24, 2], [24, 3], [27, 1], [27, 1], [27, 2], [27, 2], [27, 2], [26, 1], [26, 2], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 2], [26, 2], [26, 1], [33, 2], [33, 4], [33, 5], [33, 7], [35, 4], [47, 1], [47, 2], [34, 1], [34, 2], [34, 1], [34, 1], [31, 3], [31, 4], [31, 4], [31, 5], [38, 3], [38, 2], [53, 3], [53, 2], [53, 2], [53, 1], [58, 1], [58, 1], [58, 1], [58, 1], [58, 1], [59, 1], [59, 1], [36, 3], [36, 4], [36, 3], [36, 4], [36, 4], [36, 5], [36, 3], [36, 4], [36, 4], [36, 5], [36, 3], [36, 4], [36, 4], [36, 5], [37, 3], [75, 1], [75, 1], [76, 1], [76, 1], [76, 1], [76, 1], [76, 1], [76, 1], [76, 1], [78, 1], [78, 1], [78, 1], [78, 1], [28, 1], [28, 1], [28, 1], [29, 1], [56, 1]],
    performAction: function(A, I, G, L, at, E, Dt) {
      var et = E.length - 1;
      switch (at) {
        case 5:
          L.setDirection("TB");
          break;
        case 6:
          L.setDirection("BT");
          break;
        case 7:
          L.setDirection("RL");
          break;
        case 8:
          L.setDirection("LR");
          break;
        case 12:
          L.parseDirective("%%{", "open_directive");
          break;
        case 13:
          L.parseDirective(E[et], "type_directive");
          break;
        case 14:
          E[et] = E[et].trim().replace(/'/g, '"'), L.parseDirective(E[et], "arg_directive");
          break;
        case 15:
          L.parseDirective("}%%", "close_directive", "class");
          break;
        case 20:
        case 21:
          this.$ = E[et];
          break;
        case 22:
          this.$ = E[et - 1] + E[et];
          break;
        case 23:
        case 24:
          this.$ = E[et - 1] + "~" + E[et];
          break;
        case 25:
          L.addRelation(E[et]);
          break;
        case 26:
          E[et - 1].title = L.cleanupLabel(E[et]), L.addRelation(E[et - 1]);
          break;
        case 35:
          this.$ = E[et].trim(), L.setAccTitle(this.$);
          break;
        case 36:
        case 37:
          this.$ = E[et].trim(), L.setAccDescription(this.$);
          break;
        case 38:
          L.addClass(E[et]);
          break;
        case 39:
          L.addClass(E[et - 2]), L.setCssClass(E[et - 2], E[et]);
          break;
        case 40:
          L.addClass(E[et - 3]), L.addMembers(E[et - 3], E[et - 1]);
          break;
        case 41:
          L.addClass(E[et - 5]), L.setCssClass(E[et - 5], E[et - 3]), L.addMembers(E[et - 5], E[et - 1]);
          break;
        case 42:
          L.addAnnotation(E[et], E[et - 2]);
          break;
        case 43:
          this.$ = [E[et]];
          break;
        case 44:
          E[et].push(E[et - 1]), this.$ = E[et];
          break;
        case 45:
          break;
        case 46:
          L.addMember(E[et - 1], L.cleanupLabel(E[et]));
          break;
        case 47:
          break;
        case 48:
          break;
        case 49:
          this.$ = { id1: E[et - 2], id2: E[et], relation: E[et - 1], relationTitle1: "none", relationTitle2: "none" };
          break;
        case 50:
          this.$ = { id1: E[et - 3], id2: E[et], relation: E[et - 1], relationTitle1: E[et - 2], relationTitle2: "none" };
          break;
        case 51:
          this.$ = { id1: E[et - 3], id2: E[et], relation: E[et - 2], relationTitle1: "none", relationTitle2: E[et - 1] };
          break;
        case 52:
          this.$ = { id1: E[et - 4], id2: E[et], relation: E[et - 2], relationTitle1: E[et - 3], relationTitle2: E[et - 1] };
          break;
        case 53:
          L.addNote(E[et], E[et - 1]);
          break;
        case 54:
          L.addNote(E[et]);
          break;
        case 55:
          this.$ = { type1: E[et - 2], type2: E[et], lineType: E[et - 1] };
          break;
        case 56:
          this.$ = { type1: "none", type2: E[et], lineType: E[et - 1] };
          break;
        case 57:
          this.$ = { type1: E[et - 1], type2: "none", lineType: E[et] };
          break;
        case 58:
          this.$ = { type1: "none", type2: "none", lineType: E[et] };
          break;
        case 59:
          this.$ = L.relationType.AGGREGATION;
          break;
        case 60:
          this.$ = L.relationType.EXTENSION;
          break;
        case 61:
          this.$ = L.relationType.COMPOSITION;
          break;
        case 62:
          this.$ = L.relationType.DEPENDENCY;
          break;
        case 63:
          this.$ = L.relationType.LOLLIPOP;
          break;
        case 64:
          this.$ = L.lineType.LINE;
          break;
        case 65:
          this.$ = L.lineType.DOTTED_LINE;
          break;
        case 66:
        case 72:
          this.$ = E[et - 2], L.setClickEvent(E[et - 1], E[et]);
          break;
        case 67:
        case 73:
          this.$ = E[et - 3], L.setClickEvent(E[et - 2], E[et - 1]), L.setTooltip(E[et - 2], E[et]);
          break;
        case 68:
        case 76:
          this.$ = E[et - 2], L.setLink(E[et - 1], E[et]);
          break;
        case 69:
          this.$ = E[et - 3], L.setLink(E[et - 2], E[et - 1], E[et]);
          break;
        case 70:
        case 78:
          this.$ = E[et - 3], L.setLink(E[et - 2], E[et - 1]), L.setTooltip(E[et - 2], E[et]);
          break;
        case 71:
        case 79:
          this.$ = E[et - 4], L.setLink(E[et - 3], E[et - 2], E[et]), L.setTooltip(E[et - 3], E[et - 1]);
          break;
        case 74:
          this.$ = E[et - 3], L.setClickEvent(E[et - 2], E[et - 1], E[et]);
          break;
        case 75:
          this.$ = E[et - 4], L.setClickEvent(E[et - 3], E[et - 2], E[et - 1]), L.setTooltip(E[et - 3], E[et]);
          break;
        case 77:
          this.$ = E[et - 3], L.setLink(E[et - 2], E[et - 1], E[et]);
          break;
        case 80:
          L.setCssClass(E[et - 1], E[et]);
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: e, 6: 4, 7: 5, 8: r, 9: n, 10: i, 11: s, 12: 6, 13: 11, 19: a, 23: o }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 3: 14, 4: 2, 5: e, 6: 4, 7: 5, 8: r, 9: n, 10: i, 11: s, 12: 6, 13: 11, 19: a, 23: o }, { 1: [2, 9] }, t(l, [2, 5]), t(l, [2, 6]), t(l, [2, 7]), t(l, [2, 8]), { 14: 15, 20: [1, 16] }, { 16: [1, 17] }, { 20: [2, 12] }, { 1: [2, 4] }, { 15: 18, 17: [1, 19], 22: u }, t([17, 22], [2, 13]), { 6: 31, 7: 30, 8: r, 9: n, 10: i, 11: s, 13: 11, 19: a, 24: 21, 26: 22, 27: 35, 28: 46, 29: 47, 31: 23, 33: 24, 34: 25, 35: 26, 36: 27, 37: 28, 38: 29, 39: h, 41: f, 43: d, 44: p, 49: m, 51: _, 52: v, 55: k, 57: x, 67: D, 68: F, 70: P, 74: V, 88: R, 89: O, 90: C, 91: S }, { 16: [1, 52] }, { 18: 53, 21: [1, 54] }, { 16: [2, 15] }, { 25: [1, 55] }, { 16: [1, 56], 25: [2, 17] }, t(T, [2, 25], { 32: [1, 57] }), t(T, [2, 27]), t(T, [2, 28]), t(T, [2, 29]), t(T, [2, 30]), t(T, [2, 31]), t(T, [2, 32]), t(T, [2, 33]), t(T, [2, 34]), { 40: [1, 58] }, { 42: [1, 59] }, t(T, [2, 37]), t(T, [2, 45], { 53: 60, 58: 63, 59: 64, 32: [1, 62], 54: [1, 61], 60: b, 61: w, 62: g, 63: M, 64: y, 65: N, 66: it }), { 27: 72, 28: 46, 29: 47, 88: R, 89: O, 90: C, 91: S }, t(T, [2, 47]), t(T, [2, 48]), { 28: 73, 88: R, 89: O, 90: C }, { 27: 74, 28: 46, 29: 47, 88: R, 89: O, 90: C, 91: S }, { 27: 75, 28: 46, 29: 47, 88: R, 89: O, 90: C, 91: S }, { 27: 76, 28: 46, 29: 47, 88: R, 89: O, 90: C, 91: S }, { 54: [1, 77] }, { 27: 78, 28: 46, 29: 47, 88: R, 89: O, 90: C, 91: S }, { 54: Y, 56: 79 }, t(Z, [2, 20], { 28: 46, 29: 47, 27: 81, 30: [1, 82], 88: R, 89: O, 90: C, 91: S }), t(Z, [2, 21], { 30: [1, 83] }), t(J, [2, 94]), t(J, [2, 95]), t(J, [2, 96]), t([16, 25, 30, 32, 45, 46, 54, 60, 61, 62, 63, 64, 65, 66, 71, 73], [2, 97]), t(X, [2, 10]), { 15: 84, 22: u }, { 22: [2, 14] }, { 1: [2, 16] }, { 6: 31, 7: 30, 8: r, 9: n, 10: i, 11: s, 13: 11, 19: a, 24: 85, 25: [2, 18], 26: 22, 27: 35, 28: 46, 29: 47, 31: 23, 33: 24, 34: 25, 35: 26, 36: 27, 37: 28, 38: 29, 39: h, 41: f, 43: d, 44: p, 49: m, 51: _, 52: v, 55: k, 57: x, 67: D, 68: F, 70: P, 74: V, 88: R, 89: O, 90: C, 91: S }, t(T, [2, 26]), t(T, [2, 35]), t(T, [2, 36]), { 27: 86, 28: 46, 29: 47, 54: [1, 87], 88: R, 89: O, 90: C, 91: S }, { 53: 88, 58: 63, 59: 64, 60: b, 61: w, 62: g, 63: M, 64: y, 65: N, 66: it }, t(T, [2, 46]), { 59: 89, 65: N, 66: it }, t(tt, [2, 58], { 58: 90, 60: b, 61: w, 62: g, 63: M, 64: y }), t(st, [2, 59]), t(st, [2, 60]), t(st, [2, 61]), t(st, [2, 62]), t(st, [2, 63]), t(lt, [2, 64]), t(lt, [2, 65]), t(T, [2, 38], { 45: [1, 91], 46: [1, 92] }), { 50: [1, 93] }, { 54: [1, 94] }, { 54: [1, 95] }, { 71: [1, 96], 73: [1, 97] }, { 28: 98, 88: R, 89: O, 90: C }, { 54: Y, 56: 99 }, t(T, [2, 54]), t(T, [2, 98]), t(Z, [2, 22]), t(Z, [2, 23]), t(Z, [2, 24]), { 16: [1, 100] }, { 25: [2, 19] }, t(U, [2, 49]), { 27: 101, 28: 46, 29: 47, 88: R, 89: O, 90: C, 91: S }, { 27: 102, 28: 46, 29: 47, 54: [1, 103], 88: R, 89: O, 90: C, 91: S }, t(tt, [2, 57], { 58: 104, 60: b, 61: w, 62: g, 63: M, 64: y }), t(tt, [2, 56]), { 28: 105, 88: R, 89: O, 90: C }, { 47: 106, 51: Tt }, { 27: 108, 28: 46, 29: 47, 88: R, 89: O, 90: C, 91: S }, t(T, [2, 66], { 54: [1, 109] }), t(T, [2, 68], { 54: [1, 111], 69: [1, 110] }), t(T, [2, 72], { 54: [1, 112], 72: [1, 113] }), t(T, [2, 76], { 54: [1, 115], 69: [1, 114] }), t(T, [2, 80]), t(T, [2, 53]), t(X, [2, 11]), t(U, [2, 51]), t(U, [2, 50]), { 27: 116, 28: 46, 29: 47, 88: R, 89: O, 90: C, 91: S }, t(tt, [2, 55]), t(T, [2, 39], { 46: [1, 117] }), { 48: [1, 118] }, { 47: 119, 48: [2, 43], 51: Tt }, t(T, [2, 42]), t(T, [2, 67]), t(T, [2, 69]), t(T, [2, 70], { 69: [1, 120] }), t(T, [2, 73]), t(T, [2, 74], { 54: [1, 121] }), t(T, [2, 77]), t(T, [2, 78], { 69: [1, 122] }), t(U, [2, 52]), { 47: 123, 51: Tt }, t(T, [2, 40]), { 48: [2, 44] }, t(T, [2, 71]), t(T, [2, 75]), t(T, [2, 79]), { 48: [1, 124] }, t(T, [2, 41])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 3], 6: [2, 9], 13: [2, 12], 14: [2, 4], 20: [2, 15], 54: [2, 14], 55: [2, 16], 85: [2, 19], 119: [2, 44] },
    parseError: function(A, I) {
      if (I.recoverable)
        this.trace(A);
      else {
        var G = new Error(A);
        throw G.hash = I, G;
      }
    },
    parse: function(A) {
      var I = this, G = [0], L = [], at = [null], E = [], Dt = this.table, et = "", Et = 0, vt = 0, pt = 2, ht = 1, gt = E.slice.call(arguments, 1), ut = Object.create(this.lexer), yt = { yy: {} };
      for (var ue in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ue) && (yt.yy[ue] = this.yy[ue]);
      ut.setInput(A, yt.yy), yt.yy.lexer = ut, yt.yy.parser = this, typeof ut.yylloc > "u" && (ut.yylloc = {});
      var re = ut.yylloc;
      E.push(re);
      var Mt = ut.options && ut.options.ranges;
      typeof yt.yy.parseError == "function" ? this.parseError = yt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Nt() {
        var nt;
        return nt = L.pop() || ut.lex() || ht, typeof nt != "number" && (nt instanceof Array && (L = nt, nt = L.pop()), nt = I.symbols_[nt] || nt), nt;
      }
      for (var Kt, fe, Gt, Ot, Bt = {}, bt, mt, wt, ft; ; ) {
        if (fe = G[G.length - 1], this.defaultActions[fe] ? Gt = this.defaultActions[fe] : ((Kt === null || typeof Kt > "u") && (Kt = Nt()), Gt = Dt[fe] && Dt[fe][Kt]), typeof Gt > "u" || !Gt.length || !Gt[0]) {
          var It = "";
          ft = [];
          for (bt in Dt[fe])
            this.terminals_[bt] && bt > pt && ft.push("'" + this.terminals_[bt] + "'");
          ut.showPosition ? It = "Parse error on line " + (Et + 1) + `:
` + ut.showPosition() + `
Expecting ` + ft.join(", ") + ", got '" + (this.terminals_[Kt] || Kt) + "'" : It = "Parse error on line " + (Et + 1) + ": Unexpected " + (Kt == ht ? "end of input" : "'" + (this.terminals_[Kt] || Kt) + "'"), this.parseError(It, {
            text: ut.match,
            token: this.terminals_[Kt] || Kt,
            line: ut.yylineno,
            loc: re,
            expected: ft
          });
        }
        if (Gt[0] instanceof Array && Gt.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + fe + ", token: " + Kt);
        switch (Gt[0]) {
          case 1:
            G.push(Kt), at.push(ut.yytext), E.push(ut.yylloc), G.push(Gt[1]), Kt = null, vt = ut.yyleng, et = ut.yytext, Et = ut.yylineno, re = ut.yylloc;
            break;
          case 2:
            if (mt = this.productions_[Gt[1]][1], Bt.$ = at[at.length - mt], Bt._$ = {
              first_line: E[E.length - (mt || 1)].first_line,
              last_line: E[E.length - 1].last_line,
              first_column: E[E.length - (mt || 1)].first_column,
              last_column: E[E.length - 1].last_column
            }, Mt && (Bt._$.range = [
              E[E.length - (mt || 1)].range[0],
              E[E.length - 1].range[1]
            ]), Ot = this.performAction.apply(Bt, [
              et,
              vt,
              Et,
              yt.yy,
              Gt[1],
              at,
              E
            ].concat(gt)), typeof Ot < "u")
              return Ot;
            mt && (G = G.slice(0, -1 * mt * 2), at = at.slice(0, -1 * mt), E = E.slice(0, -1 * mt)), G.push(this.productions_[Gt[1]][0]), at.push(Bt.$), E.push(Bt._$), wt = Dt[G[G.length - 2]][G[G.length - 1]], G.push(wt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, j = function() {
    var z = {
      EOF: 1,
      parseError: function(I, G) {
        if (this.yy.parser)
          this.yy.parser.parseError(I, G);
        else
          throw new Error(I);
      },
      // resets the lexer, sets new input
      setInput: function(A, I) {
        return this.yy = I || this.yy || {}, this._input = A, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var A = this._input[0];
        this.yytext += A, this.yyleng++, this.offset++, this.match += A, this.matched += A;
        var I = A.match(/(?:\r\n?|\n).*/g);
        return I ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), A;
      },
      // unshifts one char (or a string) into the input
      unput: function(A) {
        var I = A.length, G = A.split(/(?:\r\n?|\n)/g);
        this._input = A + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - I), this.offset -= I;
        var L = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), G.length - 1 && (this.yylineno -= G.length - 1);
        var at = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: G ? (G.length === L.length ? this.yylloc.first_column : 0) + L[L.length - G.length].length - G[0].length : this.yylloc.first_column - I
        }, this.options.ranges && (this.yylloc.range = [at[0], at[0] + this.yyleng - I]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(A) {
        this.unput(this.match.slice(A));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var A = this.matched.substr(0, this.matched.length - this.match.length);
        return (A.length > 20 ? "..." : "") + A.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var A = this.match;
        return A.length < 20 && (A += this._input.substr(0, 20 - A.length)), (A.substr(0, 20) + (A.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var A = this.pastInput(), I = new Array(A.length + 1).join("-");
        return A + this.upcomingInput() + `
` + I + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(A, I) {
        var G, L, at;
        if (this.options.backtrack_lexer && (at = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (at.yylloc.range = this.yylloc.range.slice(0))), L = A[0].match(/(?:\r\n?|\n).*/g), L && (this.yylineno += L.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: L ? L[L.length - 1].length - L[L.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + A[0].length
        }, this.yytext += A[0], this.match += A[0], this.matches = A, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(A[0].length), this.matched += A[0], G = this.performAction.call(this, this.yy, this, I, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), G)
          return G;
        if (this._backtrack) {
          for (var E in at)
            this[E] = at[E];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var A, I, G, L;
        this._more || (this.yytext = "", this.match = "");
        for (var at = this._currentRules(), E = 0; E < at.length; E++)
          if (G = this._input.match(this.rules[at[E]]), G && (!I || G[0].length > I[0].length)) {
            if (I = G, L = E, this.options.backtrack_lexer) {
              if (A = this.test_match(G, at[E]), A !== !1)
                return A;
              if (this._backtrack) {
                I = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return I ? (A = this.test_match(I, at[L]), A !== !1 ? A : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var I = this.next();
        return I || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(I) {
        this.conditionStack.push(I);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var I = this.conditionStack.length - 1;
        return I > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(I) {
        return I = this.conditionStack.length - 1 - Math.abs(I || 0), I >= 0 ? this.conditionStack[I] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(I) {
        this.begin(I);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function(I, G, L, at) {
        switch (L) {
          case 0:
            return this.begin("open_directive"), 19;
          case 1:
            return 8;
          case 2:
            return 9;
          case 3:
            return 10;
          case 4:
            return 11;
          case 5:
            return this.begin("type_directive"), 20;
          case 6:
            return this.popState(), this.begin("arg_directive"), 17;
          case 7:
            return this.popState(), this.popState(), 22;
          case 8:
            return 21;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return this.begin("acc_title"), 39;
          case 12:
            return this.popState(), "acc_title_value";
          case 13:
            return this.begin("acc_descr"), 41;
          case 14:
            return this.popState(), "acc_descr_value";
          case 15:
            this.begin("acc_descr_multiline");
            break;
          case 16:
            this.popState();
            break;
          case 17:
            return "acc_descr_multiline_value";
          case 18:
            return 16;
          case 19:
            break;
          case 20:
            return 23;
          case 21:
            return 23;
          case 22:
            return this.begin("struct"), 46;
          case 23:
            return "EDGE_STATE";
          case 24:
            return "EOF_IN_STRUCT";
          case 25:
            return "OPEN_IN_STRUCT";
          case 26:
            return this.popState(), 48;
          case 27:
            break;
          case 28:
            return "MEMBER";
          case 29:
            return 44;
          case 30:
            return 74;
          case 31:
            return 67;
          case 32:
            return 68;
          case 33:
            return 70;
          case 34:
            return 55;
          case 35:
            return 57;
          case 36:
            return 49;
          case 37:
            return 50;
          case 38:
            this.begin("generic");
            break;
          case 39:
            this.popState();
            break;
          case 40:
            return "GENERICTYPE";
          case 41:
            this.begin("string");
            break;
          case 42:
            this.popState();
            break;
          case 43:
            return "STR";
          case 44:
            this.begin("bqstring");
            break;
          case 45:
            this.popState();
            break;
          case 46:
            return "BQUOTE_STR";
          case 47:
            this.begin("href");
            break;
          case 48:
            this.popState();
            break;
          case 49:
            return 73;
          case 50:
            this.begin("callback_name");
            break;
          case 51:
            this.popState();
            break;
          case 52:
            this.popState(), this.begin("callback_args");
            break;
          case 53:
            return 71;
          case 54:
            this.popState();
            break;
          case 55:
            return 72;
          case 56:
            return 69;
          case 57:
            return 69;
          case 58:
            return 69;
          case 59:
            return 69;
          case 60:
            return 61;
          case 61:
            return 61;
          case 62:
            return 63;
          case 63:
            return 63;
          case 64:
            return 62;
          case 65:
            return 60;
          case 66:
            return 64;
          case 67:
            return 65;
          case 68:
            return 66;
          case 69:
            return 32;
          case 70:
            return 45;
          case 71:
            return 86;
          case 72:
            return "DOT";
          case 73:
            return "PLUS";
          case 74:
            return 83;
          case 75:
            return "EQUALS";
          case 76:
            return "EQUALS";
          case 77:
            return 90;
          case 78:
            return "PUNCTUATION";
          case 79:
            return 89;
          case 80:
            return 88;
          case 81:
            return 85;
          case 82:
            return 25;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:classDiagram-v2\b)/, /^(?:classDiagram\b)/, /^(?:[{])/, /^(?:\[\*\])/, /^(?:$)/, /^(?:[{])/, /^(?:[}])/, /^(?:[\n])/, /^(?:[^{}\n]*)/, /^(?:class\b)/, /^(?:cssClass\b)/, /^(?:callback\b)/, /^(?:link\b)/, /^(?:click\b)/, /^(?:note for\b)/, /^(?:note\b)/, /^(?:<<)/, /^(?:>>)/, /^(?:[~])/, /^(?:[~])/, /^(?:[^~]*)/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[`])/, /^(?:[`])/, /^(?:[^`]+)/, /^(?:href[\s]+["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:\s*<\|)/, /^(?:\s*\|>)/, /^(?:\s*>)/, /^(?:\s*<)/, /^(?:\s*\*)/, /^(?:\s*o\b)/, /^(?:\s*\(\))/, /^(?:--)/, /^(?:\.\.)/, /^(?::{1}[^:\n;]+)/, /^(?::{3})/, /^(?:-)/, /^(?:\.)/, /^(?:\+)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:\w+)/, /^(?:[!"#$%&'*+,-.`?\\/])/, /^(?:[0-9]+)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\s)/, /^(?:$)/],
      conditions: { acc_descr_multiline: { rules: [16, 17], inclusive: !1 }, acc_descr: { rules: [14], inclusive: !1 }, acc_title: { rules: [12], inclusive: !1 }, arg_directive: { rules: [7, 8], inclusive: !1 }, type_directive: { rules: [6, 7], inclusive: !1 }, open_directive: { rules: [5], inclusive: !1 }, callback_args: { rules: [54, 55], inclusive: !1 }, callback_name: { rules: [51, 52, 53], inclusive: !1 }, href: { rules: [48, 49], inclusive: !1 }, struct: { rules: [23, 24, 25, 26, 27, 28], inclusive: !1 }, generic: { rules: [39, 40], inclusive: !1 }, bqstring: { rules: [45, 46], inclusive: !1 }, string: { rules: [42, 43], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 9, 10, 11, 13, 15, 18, 19, 20, 21, 22, 23, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 41, 44, 47, 50, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82], inclusive: !0 } }
    };
    return z;
  }();
  $.lexer = j;
  function W() {
    this.yy = {};
  }
  return W.prototype = $, $.Parser = W, new W();
}();
Fh.parser = Fh;
const wd = Fh, m9 = (t, e) => {
  var r;
  return ((r = e == null ? void 0 : e.class) == null ? void 0 : r.defaultRenderer) === "dagre-wrapper" ? !1 : t.match(/^\s*classDiagram/) !== null;
}, b9 = (t, e) => {
  var r;
  return t.match(/^\s*classDiagram/) !== null && ((r = e == null ? void 0 : e.class) == null ? void 0 : r.defaultRenderer) === "dagre-wrapper" ? !0 : t.match(/^\s*classDiagram-v2/) !== null;
}, h0 = "classid-";
let f0 = [], Be = {}, ec = [], Td = 0, ja = [];
const Aa = (t) => Xt.sanitizeText(t, q()), _9 = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
}, Xa = function(t) {
  let e = "", r = t;
  if (t.indexOf("~") > 0) {
    let n = t.split("~");
    r = n[0], e = Xt.sanitizeText(n[1], q());
  }
  return { className: r, type: e };
}, Oh = function(t) {
  let e = Xa(t);
  Be[e.className] === void 0 && (Be[e.className] = {
    id: e.className,
    type: e.type,
    cssClasses: [],
    methods: [],
    members: [],
    annotations: [],
    domId: h0 + e.className + "-" + Td
  }, Td++);
}, Cy = function(t) {
  const e = Object.keys(Be);
  for (const r of e)
    if (Be[r].id === t)
      return Be[r].domId;
}, x9 = function() {
  f0 = [], Be = {}, ec = [], ja = [], ja.push(Ay), Br();
}, v9 = function(t) {
  return Be[t];
}, k9 = function() {
  return Be;
}, w9 = function() {
  return f0;
}, T9 = function() {
  return ec;
}, E9 = function(t) {
  B.debug("Adding relation: " + JSON.stringify(t)), Oh(t.id1), Oh(t.id2), t.id1 = Xa(t.id1).className, t.id2 = Xa(t.id2).className, t.relationTitle1 = Xt.sanitizeText(
    t.relationTitle1.trim(),
    q()
  ), t.relationTitle2 = Xt.sanitizeText(
    t.relationTitle2.trim(),
    q()
  ), f0.push(t);
}, C9 = function(t, e) {
  const r = Xa(t).className;
  Be[r].annotations.push(e);
}, Sy = function(t, e) {
  const r = Xa(t).className, n = Be[r];
  if (typeof e == "string") {
    const i = e.trim();
    i.startsWith("<<") && i.endsWith(">>") ? n.annotations.push(Aa(i.substring(2, i.length - 2))) : i.indexOf(")") > 0 ? n.methods.push(Aa(i)) : i && n.members.push(Aa(i));
  }
}, S9 = function(t, e) {
  Array.isArray(e) && (e.reverse(), e.forEach((r) => Sy(t, r)));
}, A9 = function(t, e) {
  const r = {
    id: `note${ec.length}`,
    class: e,
    text: t
  };
  ec.push(r);
}, L9 = function(t) {
  return t.substring(0, 1) === ":" ? Xt.sanitizeText(t.substr(1).trim(), q()) : Aa(t.trim());
}, d0 = function(t, e) {
  t.split(",").forEach(function(r) {
    let n = r;
    r[0].match(/\d/) && (n = h0 + n), Be[n] !== void 0 && Be[n].cssClasses.push(e);
  });
}, B9 = function(t, e) {
  const r = q();
  t.split(",").forEach(function(n) {
    e !== void 0 && (Be[n].tooltip = Xt.sanitizeText(e, r));
  });
}, D9 = function(t) {
  return Be[t].tooltip;
}, I9 = function(t, e, r) {
  const n = q();
  t.split(",").forEach(function(i) {
    let s = i;
    i[0].match(/\d/) && (s = h0 + s), Be[s] !== void 0 && (Be[s].link = jt.formatUrl(e, n), n.securityLevel === "sandbox" ? Be[s].linkTarget = "_top" : typeof r == "string" ? Be[s].linkTarget = Aa(r) : Be[s].linkTarget = "_blank");
  }), d0(t, "clickable");
}, M9 = function(t, e, r) {
  t.split(",").forEach(function(n) {
    N9(n, e, r), Be[n].haveCallback = !0;
  }), d0(t, "clickable");
}, N9 = function(t, e, r) {
  const n = q();
  let i = t, s = Cy(i);
  if (n.securityLevel === "loose" && e !== void 0 && Be[i] !== void 0) {
    let a = [];
    if (typeof r == "string") {
      a = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
      for (let o = 0; o < a.length; o++) {
        let l = a[o].trim();
        l.charAt(0) === '"' && l.charAt(l.length - 1) === '"' && (l = l.substr(1, l.length - 2)), a[o] = l;
      }
    }
    a.length === 0 && a.push(s), ja.push(function() {
      const o = document.querySelector(`[id="${s}"]`);
      o !== null && o.addEventListener(
        "click",
        function() {
          jt.runFunc(e, ...a);
        },
        !1
      );
    });
  }
}, R9 = function(t) {
  ja.forEach(function(e) {
    e(t);
  });
}, F9 = {
  LINE: 0,
  DOTTED_LINE: 1
}, O9 = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3,
  LOLLIPOP: 4
}, Ay = function(t) {
  let e = _t(".mermaidTooltip");
  (e._groups || e)[0][0] === null && (e = _t("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), _t(t).select("svg").selectAll("g.node").on("mouseover", function() {
    const i = _t(this);
    if (i.attr("title") === null)
      return;
    const a = this.getBoundingClientRect();
    e.transition().duration(200).style("opacity", ".9"), e.text(i.attr("title")).style("left", window.scrollX + a.left + (a.right - a.left) / 2 + "px").style("top", window.scrollY + a.top - 14 + document.body.scrollTop + "px"), e.html(e.html().replace(/&lt;br\/&gt;/g, "<br/>")), i.classed("hover", !0);
  }).on("mouseout", function() {
    e.transition().duration(500).style("opacity", 0), _t(this).classed("hover", !1);
  });
};
ja.push(Ay);
let Ly = "TB";
const P9 = () => Ly, V9 = (t) => {
  Ly = t;
}, ps = {
  parseDirective: _9,
  setAccTitle: Tr,
  getAccTitle: Dr,
  getAccDescription: Mr,
  setAccDescription: Ir,
  getConfig: () => q().class,
  addClass: Oh,
  bindFunctions: R9,
  clear: x9,
  getClass: v9,
  getClasses: k9,
  getNotes: T9,
  addAnnotation: C9,
  addNote: A9,
  getRelations: w9,
  addRelation: E9,
  getDirection: P9,
  setDirection: V9,
  addMember: Sy,
  addMembers: S9,
  cleanupLabel: L9,
  lineType: F9,
  relationType: O9,
  setClickEvent: M9,
  setCssClass: d0,
  setLink: I9,
  getTooltip: D9,
  setTooltip: B9,
  lookUpDomId: Cy,
  setDiagramTitle: un,
  getDiagramTitle: hn
};
function wn(t) {
  return t != null && typeof t == "object";
}
var Y9 = "[object Symbol]";
function Ui(t) {
  return typeof t == "symbol" || wn(t) && Qi(t) == Y9;
}
function _s(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = Array(n); ++r < n; )
    i[r] = e(t[r], r, t);
  return i;
}
var z9 = Array.isArray;
const Pe = z9;
var U9 = 1 / 0, Ed = Wr ? Wr.prototype : void 0, Cd = Ed ? Ed.toString : void 0;
function By(t) {
  if (typeof t == "string")
    return t;
  if (Pe(t))
    return _s(t, By) + "";
  if (Ui(t))
    return Cd ? Cd.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -U9 ? "-0" : e;
}
var W9 = /\s/;
function H9(t) {
  for (var e = t.length; e-- && W9.test(t.charAt(e)); )
    ;
  return e;
}
var G9 = /^\s+/;
function q9(t) {
  return t && t.slice(0, H9(t) + 1).replace(G9, "");
}
var Sd = 0 / 0, $9 = /^[-+]0x[0-9a-f]+$/i, j9 = /^0b[01]+$/i, X9 = /^0o[0-7]+$/i, K9 = parseInt;
function Z9(t) {
  if (typeof t == "number")
    return t;
  if (Ui(t))
    return Sd;
  if (Lr(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Lr(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = q9(t);
  var r = j9.test(t);
  return r || X9.test(t) ? K9(t.slice(2), r ? 2 : 8) : $9.test(t) ? Sd : +t;
}
var Ad = 1 / 0, Q9 = 17976931348623157e292;
function ol(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = Z9(t), t === Ad || t === -Ad) {
    var e = t < 0 ? -1 : 1;
    return e * Q9;
  }
  return t === t ? t : 0;
}
function J9(t) {
  var e = ol(t), r = e % 1;
  return e === e ? r ? e - r : e : 0;
}
function es(t) {
  return t;
}
var tS = ts(ln, "WeakMap");
const Ph = tS;
var Ld = Object.create, eS = function() {
  function t() {
  }
  return function(e) {
    if (!Lr(e))
      return {};
    if (Ld)
      return Ld(e);
    t.prototype = e;
    var r = new t();
    return t.prototype = void 0, r;
  };
}();
const rS = eS;
function nS(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2]);
  }
  return t.apply(e, r);
}
function iS() {
}
function Dy(t, e) {
  var r = -1, n = t.length;
  for (e || (e = Array(n)); ++r < n; )
    e[r] = t[r];
  return e;
}
var sS = 800, aS = 16, oS = Date.now;
function lS(t) {
  var e = 0, r = 0;
  return function() {
    var n = oS(), i = aS - (n - r);
    if (r = n, i > 0) {
      if (++e >= sS)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
function gs(t) {
  return function() {
    return t;
  };
}
var cS = function() {
  try {
    var t = ts(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}();
const rc = cS;
var uS = rc ? function(t, e) {
  return rc(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: gs(e),
    writable: !0
  });
} : es;
const hS = uS;
var fS = lS(hS);
const Iy = fS;
function My(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n && e(t[r], r, t) !== !1; )
    ;
  return t;
}
function Ny(t, e, r, n) {
  for (var i = t.length, s = r + (n ? 1 : -1); n ? s-- : ++s < i; )
    if (e(t[s], s, t))
      return s;
  return -1;
}
function dS(t) {
  return t !== t;
}
function pS(t, e, r) {
  for (var n = r - 1, i = t.length; ++n < i; )
    if (t[n] === e)
      return n;
  return -1;
}
function gS(t, e, r) {
  return e === e ? pS(t, e, r) : Ny(t, dS, r);
}
function yS(t, e) {
  var r = t == null ? 0 : t.length;
  return !!r && gS(t, e, 0) > -1;
}
var mS = 9007199254740991, bS = /^(?:0|[1-9]\d*)$/;
function Vc(t, e) {
  var r = typeof t;
  return e = e ?? mS, !!e && (r == "number" || r != "symbol" && bS.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
function Yc(t, e, r) {
  e == "__proto__" && rc ? rc(t, e, {
    configurable: !0,
    enumerable: !0,
    value: r,
    writable: !0
  }) : t[e] = r;
}
var _S = Object.prototype, xS = _S.hasOwnProperty;
function zc(t, e, r) {
  var n = t[e];
  (!(xS.call(t, e) && Xs(n, r)) || r === void 0 && !(e in t)) && Yc(t, e, r);
}
function po(t, e, r, n) {
  var i = !r;
  r || (r = {});
  for (var s = -1, a = e.length; ++s < a; ) {
    var o = e[s], l = n ? n(r[o], t[o], o, r, t) : void 0;
    l === void 0 && (l = t[o]), i ? Yc(r, o, l) : zc(r, o, l);
  }
  return r;
}
var Bd = Math.max;
function Ry(t, e, r) {
  return e = Bd(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var n = arguments, i = -1, s = Bd(n.length - e, 0), a = Array(s); ++i < s; )
      a[i] = n[e + i];
    i = -1;
    for (var o = Array(e + 1); ++i < e; )
      o[i] = n[i];
    return o[e] = r(a), nS(t, this, o);
  };
}
function Uc(t, e) {
  return Iy(Ry(t, e, es), t + "");
}
var vS = 9007199254740991;
function p0(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= vS;
}
function bi(t) {
  return t != null && p0(t.length) && !Ns(t);
}
function Ka(t, e, r) {
  if (!Lr(r))
    return !1;
  var n = typeof e;
  return (n == "number" ? bi(r) && Vc(e, r.length) : n == "string" && e in r) ? Xs(r[e], t) : !1;
}
function kS(t) {
  return Uc(function(e, r) {
    var n = -1, i = r.length, s = i > 1 ? r[i - 1] : void 0, a = i > 2 ? r[2] : void 0;
    for (s = t.length > 3 && typeof s == "function" ? (i--, s) : void 0, a && Ka(r[0], r[1], a) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++n < i; ) {
      var o = r[n];
      o && t(e, o, n, s);
    }
    return e;
  });
}
var wS = Object.prototype;
function Wc(t) {
  var e = t && t.constructor, r = typeof e == "function" && e.prototype || wS;
  return t === r;
}
function TS(t, e) {
  for (var r = -1, n = Array(t); ++r < t; )
    n[r] = e(r);
  return n;
}
var ES = "[object Arguments]";
function Dd(t) {
  return wn(t) && Qi(t) == ES;
}
var Fy = Object.prototype, CS = Fy.hasOwnProperty, SS = Fy.propertyIsEnumerable, AS = Dd(function() {
  return arguments;
}()) ? Dd : function(t) {
  return wn(t) && CS.call(t, "callee") && !SS.call(t, "callee");
};
const Ps = AS;
function LS() {
  return !1;
}
var Oy = typeof exports == "object" && exports && !exports.nodeType && exports, Id = Oy && typeof module == "object" && module && !module.nodeType && module, BS = Id && Id.exports === Oy, Md = BS ? ln.Buffer : void 0, DS = Md ? Md.isBuffer : void 0, IS = DS || LS;
const Vs = IS;
var MS = "[object Arguments]", NS = "[object Array]", RS = "[object Boolean]", FS = "[object Date]", OS = "[object Error]", PS = "[object Function]", VS = "[object Map]", YS = "[object Number]", zS = "[object Object]", US = "[object RegExp]", WS = "[object Set]", HS = "[object String]", GS = "[object WeakMap]", qS = "[object ArrayBuffer]", $S = "[object DataView]", jS = "[object Float32Array]", XS = "[object Float64Array]", KS = "[object Int8Array]", ZS = "[object Int16Array]", QS = "[object Int32Array]", JS = "[object Uint8Array]", tA = "[object Uint8ClampedArray]", eA = "[object Uint16Array]", rA = "[object Uint32Array]", ye = {};
ye[jS] = ye[XS] = ye[KS] = ye[ZS] = ye[QS] = ye[JS] = ye[tA] = ye[eA] = ye[rA] = !0;
ye[MS] = ye[NS] = ye[qS] = ye[RS] = ye[$S] = ye[FS] = ye[OS] = ye[PS] = ye[VS] = ye[YS] = ye[zS] = ye[US] = ye[WS] = ye[HS] = ye[GS] = !1;
function nA(t) {
  return wn(t) && p0(t.length) && !!ye[Qi(t)];
}
function Hc(t) {
  return function(e) {
    return t(e);
  };
}
var Py = typeof exports == "object" && exports && !exports.nodeType && exports, La = Py && typeof module == "object" && module && !module.nodeType && module, iA = La && La.exports === Py, Vu = iA && Fg.process, sA = function() {
  try {
    var t = La && La.require && La.require("util").types;
    return t || Vu && Vu.binding && Vu.binding("util");
  } catch {
  }
}();
const Ys = sA;
var Nd = Ys && Ys.isTypedArray, aA = Nd ? Hc(Nd) : nA;
const Gc = aA;
var oA = Object.prototype, lA = oA.hasOwnProperty;
function Vy(t, e) {
  var r = Pe(t), n = !r && Ps(t), i = !r && !n && Vs(t), s = !r && !n && !i && Gc(t), a = r || n || i || s, o = a ? TS(t.length, String) : [], l = o.length;
  for (var u in t)
    (e || lA.call(t, u)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
    Vc(u, l))) && o.push(u);
  return o;
}
function Yy(t, e) {
  return function(r) {
    return t(e(r));
  };
}
var cA = Yy(Object.keys, Object);
const uA = cA;
var hA = Object.prototype, fA = hA.hasOwnProperty;
function zy(t) {
  if (!Wc(t))
    return uA(t);
  var e = [];
  for (var r in Object(t))
    fA.call(t, r) && r != "constructor" && e.push(r);
  return e;
}
function Sr(t) {
  return bi(t) ? Vy(t) : zy(t);
}
function dA(t) {
  var e = [];
  if (t != null)
    for (var r in Object(t))
      e.push(r);
  return e;
}
var pA = Object.prototype, gA = pA.hasOwnProperty;
function yA(t) {
  if (!Lr(t))
    return dA(t);
  var e = Wc(t), r = [];
  for (var n in t)
    n == "constructor" && (e || !gA.call(t, n)) || r.push(n);
  return r;
}
function rs(t) {
  return bi(t) ? Vy(t, !0) : yA(t);
}
var mA = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, bA = /^\w*$/;
function g0(t, e) {
  if (Pe(t))
    return !1;
  var r = typeof t;
  return r == "number" || r == "symbol" || r == "boolean" || t == null || Ui(t) ? !0 : bA.test(t) || !mA.test(t) || e != null && t in Object(e);
}
var _A = 500;
function xA(t) {
  var e = Ks(t, function(n) {
    return r.size === _A && r.clear(), n;
  }), r = e.cache;
  return e;
}
var vA = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, kA = /\\(\\)?/g, wA = xA(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(vA, function(r, n, i, s) {
    e.push(i ? s.replace(kA, "$1") : n || r);
  }), e;
});
const TA = wA;
function Uy(t) {
  return t == null ? "" : By(t);
}
function qc(t, e) {
  return Pe(t) ? t : g0(t, e) ? [t] : TA(Uy(t));
}
var EA = 1 / 0;
function go(t) {
  if (typeof t == "string" || Ui(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -EA ? "-0" : e;
}
function $c(t, e) {
  e = qc(e, t);
  for (var r = 0, n = e.length; t != null && r < n; )
    t = t[go(e[r++])];
  return r && r == n ? t : void 0;
}
function CA(t, e, r) {
  var n = t == null ? void 0 : $c(t, e);
  return n === void 0 ? r : n;
}
function y0(t, e) {
  for (var r = -1, n = e.length, i = t.length; ++r < n; )
    t[i + r] = e[r];
  return t;
}
var Rd = Wr ? Wr.isConcatSpreadable : void 0;
function SA(t) {
  return Pe(t) || Ps(t) || !!(Rd && t && t[Rd]);
}
function jc(t, e, r, n, i) {
  var s = -1, a = t.length;
  for (r || (r = SA), i || (i = []); ++s < a; ) {
    var o = t[s];
    e > 0 && r(o) ? e > 1 ? jc(o, e - 1, r, n, i) : y0(i, o) : n || (i[i.length] = o);
  }
  return i;
}
function Qs(t) {
  var e = t == null ? 0 : t.length;
  return e ? jc(t, 1) : [];
}
function AA(t) {
  return Iy(Ry(t, void 0, Qs), t + "");
}
var LA = Yy(Object.getPrototypeOf, Object);
const m0 = LA;
var BA = "[object Object]", DA = Function.prototype, IA = Object.prototype, Wy = DA.toString, MA = IA.hasOwnProperty, NA = Wy.call(Object);
function Hy(t) {
  if (!wn(t) || Qi(t) != BA)
    return !1;
  var e = m0(t);
  if (e === null)
    return !0;
  var r = MA.call(e, "constructor") && e.constructor;
  return typeof r == "function" && r instanceof r && Wy.call(r) == NA;
}
function RA(t, e, r, n) {
  var i = -1, s = t == null ? 0 : t.length;
  for (n && s && (r = t[++i]); ++i < s; )
    r = e(r, t[i], i, t);
  return r;
}
function FA() {
  this.__data__ = new ti(), this.size = 0;
}
function OA(t) {
  var e = this.__data__, r = e.delete(t);
  return this.size = e.size, r;
}
function PA(t) {
  return this.__data__.get(t);
}
function VA(t) {
  return this.__data__.has(t);
}
var YA = 200;
function zA(t, e) {
  var r = this.__data__;
  if (r instanceof ti) {
    var n = r.__data__;
    if (!Ua || n.length < YA - 1)
      return n.push([t, e]), this.size = ++r.size, this;
    r = this.__data__ = new ei(n);
  }
  return r.set(t, e), this.size = r.size, this;
}
function en(t) {
  var e = this.__data__ = new ti(t);
  this.size = e.size;
}
en.prototype.clear = FA;
en.prototype.delete = OA;
en.prototype.get = PA;
en.prototype.has = VA;
en.prototype.set = zA;
function UA(t, e) {
  return t && po(e, Sr(e), t);
}
function WA(t, e) {
  return t && po(e, rs(e), t);
}
var Gy = typeof exports == "object" && exports && !exports.nodeType && exports, Fd = Gy && typeof module == "object" && module && !module.nodeType && module, HA = Fd && Fd.exports === Gy, Od = HA ? ln.Buffer : void 0, Pd = Od ? Od.allocUnsafe : void 0;
function qy(t, e) {
  if (e)
    return t.slice();
  var r = t.length, n = Pd ? Pd(r) : new t.constructor(r);
  return t.copy(n), n;
}
function $y(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length, i = 0, s = []; ++r < n; ) {
    var a = t[r];
    e(a, r, t) && (s[i++] = a);
  }
  return s;
}
function jy() {
  return [];
}
var GA = Object.prototype, qA = GA.propertyIsEnumerable, Vd = Object.getOwnPropertySymbols, $A = Vd ? function(t) {
  return t == null ? [] : (t = Object(t), $y(Vd(t), function(e) {
    return qA.call(t, e);
  }));
} : jy;
const b0 = $A;
function jA(t, e) {
  return po(t, b0(t), e);
}
var XA = Object.getOwnPropertySymbols, KA = XA ? function(t) {
  for (var e = []; t; )
    y0(e, b0(t)), t = m0(t);
  return e;
} : jy;
const Xy = KA;
function ZA(t, e) {
  return po(t, Xy(t), e);
}
function Ky(t, e, r) {
  var n = e(t);
  return Pe(t) ? n : y0(n, r(t));
}
function Vh(t) {
  return Ky(t, Sr, b0);
}
function QA(t) {
  return Ky(t, rs, Xy);
}
var JA = ts(ln, "DataView");
const Yh = JA;
var tL = ts(ln, "Promise");
const zh = tL;
var eL = ts(ln, "Set");
const xs = eL;
var Yd = "[object Map]", rL = "[object Object]", zd = "[object Promise]", Ud = "[object Set]", Wd = "[object WeakMap]", Hd = "[object DataView]", nL = Ji(Yh), iL = Ji(Ua), sL = Ji(zh), aL = Ji(xs), oL = Ji(Ph), Ai = Qi;
(Yh && Ai(new Yh(new ArrayBuffer(1))) != Hd || Ua && Ai(new Ua()) != Yd || zh && Ai(zh.resolve()) != zd || xs && Ai(new xs()) != Ud || Ph && Ai(new Ph()) != Wd) && (Ai = function(t) {
  var e = Qi(t), r = e == rL ? t.constructor : void 0, n = r ? Ji(r) : "";
  if (n)
    switch (n) {
      case nL:
        return Hd;
      case iL:
        return Yd;
      case sL:
        return zd;
      case aL:
        return Ud;
      case oL:
        return Wd;
    }
  return e;
});
const zs = Ai;
var lL = Object.prototype, cL = lL.hasOwnProperty;
function uL(t) {
  var e = t.length, r = new t.constructor(e);
  return e && typeof t[0] == "string" && cL.call(t, "index") && (r.index = t.index, r.input = t.input), r;
}
var hL = ln.Uint8Array;
const nc = hL;
function _0(t) {
  var e = new t.constructor(t.byteLength);
  return new nc(e).set(new nc(t)), e;
}
function fL(t, e) {
  var r = e ? _0(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.byteLength);
}
var dL = /\w*$/;
function pL(t) {
  var e = new t.constructor(t.source, dL.exec(t));
  return e.lastIndex = t.lastIndex, e;
}
var Gd = Wr ? Wr.prototype : void 0, qd = Gd ? Gd.valueOf : void 0;
function gL(t) {
  return qd ? Object(qd.call(t)) : {};
}
function Zy(t, e) {
  var r = e ? _0(t.buffer) : t.buffer;
  return new t.constructor(r, t.byteOffset, t.length);
}
var yL = "[object Boolean]", mL = "[object Date]", bL = "[object Map]", _L = "[object Number]", xL = "[object RegExp]", vL = "[object Set]", kL = "[object String]", wL = "[object Symbol]", TL = "[object ArrayBuffer]", EL = "[object DataView]", CL = "[object Float32Array]", SL = "[object Float64Array]", AL = "[object Int8Array]", LL = "[object Int16Array]", BL = "[object Int32Array]", DL = "[object Uint8Array]", IL = "[object Uint8ClampedArray]", ML = "[object Uint16Array]", NL = "[object Uint32Array]";
function RL(t, e, r) {
  var n = t.constructor;
  switch (e) {
    case TL:
      return _0(t);
    case yL:
    case mL:
      return new n(+t);
    case EL:
      return fL(t, r);
    case CL:
    case SL:
    case AL:
    case LL:
    case BL:
    case DL:
    case IL:
    case ML:
    case NL:
      return Zy(t, r);
    case bL:
      return new n();
    case _L:
    case kL:
      return new n(t);
    case xL:
      return pL(t);
    case vL:
      return new n();
    case wL:
      return gL(t);
  }
}
function Qy(t) {
  return typeof t.constructor == "function" && !Wc(t) ? rS(m0(t)) : {};
}
var FL = "[object Map]";
function OL(t) {
  return wn(t) && zs(t) == FL;
}
var $d = Ys && Ys.isMap, PL = $d ? Hc($d) : OL;
const VL = PL;
var YL = "[object Set]";
function zL(t) {
  return wn(t) && zs(t) == YL;
}
var jd = Ys && Ys.isSet, UL = jd ? Hc(jd) : zL;
const WL = UL;
var HL = 1, GL = 2, qL = 4, Jy = "[object Arguments]", $L = "[object Array]", jL = "[object Boolean]", XL = "[object Date]", KL = "[object Error]", tm = "[object Function]", ZL = "[object GeneratorFunction]", QL = "[object Map]", JL = "[object Number]", em = "[object Object]", tB = "[object RegExp]", eB = "[object Set]", rB = "[object String]", nB = "[object Symbol]", iB = "[object WeakMap]", sB = "[object ArrayBuffer]", aB = "[object DataView]", oB = "[object Float32Array]", lB = "[object Float64Array]", cB = "[object Int8Array]", uB = "[object Int16Array]", hB = "[object Int32Array]", fB = "[object Uint8Array]", dB = "[object Uint8ClampedArray]", pB = "[object Uint16Array]", gB = "[object Uint32Array]", pe = {};
pe[Jy] = pe[$L] = pe[sB] = pe[aB] = pe[jL] = pe[XL] = pe[oB] = pe[lB] = pe[cB] = pe[uB] = pe[hB] = pe[QL] = pe[JL] = pe[em] = pe[tB] = pe[eB] = pe[rB] = pe[nB] = pe[fB] = pe[dB] = pe[pB] = pe[gB] = !0;
pe[KL] = pe[tm] = pe[iB] = !1;
function Ba(t, e, r, n, i, s) {
  var a, o = e & HL, l = e & GL, u = e & qL;
  if (r && (a = i ? r(t, n, i, s) : r(t)), a !== void 0)
    return a;
  if (!Lr(t))
    return t;
  var h = Pe(t);
  if (h) {
    if (a = uL(t), !o)
      return Dy(t, a);
  } else {
    var f = zs(t), d = f == tm || f == ZL;
    if (Vs(t))
      return qy(t, o);
    if (f == em || f == Jy || d && !i) {
      if (a = l || d ? {} : Qy(t), !o)
        return l ? ZA(t, WA(a, t)) : jA(t, UA(a, t));
    } else {
      if (!pe[f])
        return i ? t : {};
      a = RL(t, f, o);
    }
  }
  s || (s = new en());
  var p = s.get(t);
  if (p)
    return p;
  s.set(t, a), WL(t) ? t.forEach(function(v) {
    a.add(Ba(v, e, r, v, t, s));
  }) : VL(t) && t.forEach(function(v, k) {
    a.set(k, Ba(v, e, r, k, t, s));
  });
  var m = u ? l ? QA : Vh : l ? rs : Sr, _ = h ? void 0 : m(t);
  return My(_ || t, function(v, k) {
    _ && (k = v, v = t[k]), zc(a, k, Ba(v, e, r, k, t, s));
  }), a;
}
var yB = 4;
function mB(t) {
  return Ba(t, yB);
}
var bB = 1, _B = 4;
function xB(t) {
  return Ba(t, bB | _B);
}
var vB = "__lodash_hash_undefined__";
function kB(t) {
  return this.__data__.set(t, vB), this;
}
function wB(t) {
  return this.__data__.has(t);
}
function Za(t) {
  var e = -1, r = t == null ? 0 : t.length;
  for (this.__data__ = new ei(); ++e < r; )
    this.add(t[e]);
}
Za.prototype.add = Za.prototype.push = kB;
Za.prototype.has = wB;
function TB(t, e) {
  for (var r = -1, n = t == null ? 0 : t.length; ++r < n; )
    if (e(t[r], r, t))
      return !0;
  return !1;
}
function rm(t, e) {
  return t.has(e);
}
var EB = 1, CB = 2;
function nm(t, e, r, n, i, s) {
  var a = r & EB, o = t.length, l = e.length;
  if (o != l && !(a && l > o))
    return !1;
  var u = s.get(t), h = s.get(e);
  if (u && h)
    return u == e && h == t;
  var f = -1, d = !0, p = r & CB ? new Za() : void 0;
  for (s.set(t, e), s.set(e, t); ++f < o; ) {
    var m = t[f], _ = e[f];
    if (n)
      var v = a ? n(_, m, f, e, t, s) : n(m, _, f, t, e, s);
    if (v !== void 0) {
      if (v)
        continue;
      d = !1;
      break;
    }
    if (p) {
      if (!TB(e, function(k, x) {
        if (!rm(p, x) && (m === k || i(m, k, r, n, s)))
          return p.push(x);
      })) {
        d = !1;
        break;
      }
    } else if (!(m === _ || i(m, _, r, n, s))) {
      d = !1;
      break;
    }
  }
  return s.delete(t), s.delete(e), d;
}
function SB(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n, i) {
    r[++e] = [i, n];
  }), r;
}
function x0(t) {
  var e = -1, r = Array(t.size);
  return t.forEach(function(n) {
    r[++e] = n;
  }), r;
}
var AB = 1, LB = 2, BB = "[object Boolean]", DB = "[object Date]", IB = "[object Error]", MB = "[object Map]", NB = "[object Number]", RB = "[object RegExp]", FB = "[object Set]", OB = "[object String]", PB = "[object Symbol]", VB = "[object ArrayBuffer]", YB = "[object DataView]", Xd = Wr ? Wr.prototype : void 0, Yu = Xd ? Xd.valueOf : void 0;
function zB(t, e, r, n, i, s, a) {
  switch (r) {
    case YB:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case VB:
      return !(t.byteLength != e.byteLength || !s(new nc(t), new nc(e)));
    case BB:
    case DB:
    case NB:
      return Xs(+t, +e);
    case IB:
      return t.name == e.name && t.message == e.message;
    case RB:
    case OB:
      return t == e + "";
    case MB:
      var o = SB;
    case FB:
      var l = n & AB;
      if (o || (o = x0), t.size != e.size && !l)
        return !1;
      var u = a.get(t);
      if (u)
        return u == e;
      n |= LB, a.set(t, e);
      var h = nm(o(t), o(e), n, i, s, a);
      return a.delete(t), h;
    case PB:
      if (Yu)
        return Yu.call(t) == Yu.call(e);
  }
  return !1;
}
var UB = 1, WB = Object.prototype, HB = WB.hasOwnProperty;
function GB(t, e, r, n, i, s) {
  var a = r & UB, o = Vh(t), l = o.length, u = Vh(e), h = u.length;
  if (l != h && !a)
    return !1;
  for (var f = l; f--; ) {
    var d = o[f];
    if (!(a ? d in e : HB.call(e, d)))
      return !1;
  }
  var p = s.get(t), m = s.get(e);
  if (p && m)
    return p == e && m == t;
  var _ = !0;
  s.set(t, e), s.set(e, t);
  for (var v = a; ++f < l; ) {
    d = o[f];
    var k = t[d], x = e[d];
    if (n)
      var D = a ? n(x, k, d, e, t, s) : n(k, x, d, t, e, s);
    if (!(D === void 0 ? k === x || i(k, x, r, n, s) : D)) {
      _ = !1;
      break;
    }
    v || (v = d == "constructor");
  }
  if (_ && !v) {
    var F = t.constructor, P = e.constructor;
    F != P && "constructor" in t && "constructor" in e && !(typeof F == "function" && F instanceof F && typeof P == "function" && P instanceof P) && (_ = !1);
  }
  return s.delete(t), s.delete(e), _;
}
var qB = 1, Kd = "[object Arguments]", Zd = "[object Array]", Yo = "[object Object]", $B = Object.prototype, Qd = $B.hasOwnProperty;
function jB(t, e, r, n, i, s) {
  var a = Pe(t), o = Pe(e), l = a ? Zd : zs(t), u = o ? Zd : zs(e);
  l = l == Kd ? Yo : l, u = u == Kd ? Yo : u;
  var h = l == Yo, f = u == Yo, d = l == u;
  if (d && Vs(t)) {
    if (!Vs(e))
      return !1;
    a = !0, h = !1;
  }
  if (d && !h)
    return s || (s = new en()), a || Gc(t) ? nm(t, e, r, n, i, s) : zB(t, e, l, r, n, i, s);
  if (!(r & qB)) {
    var p = h && Qd.call(t, "__wrapped__"), m = f && Qd.call(e, "__wrapped__");
    if (p || m) {
      var _ = p ? t.value() : t, v = m ? e.value() : e;
      return s || (s = new en()), i(_, v, r, n, s);
    }
  }
  return d ? (s || (s = new en()), GB(t, e, r, n, i, s)) : !1;
}
function v0(t, e, r, n, i) {
  return t === e ? !0 : t == null || e == null || !wn(t) && !wn(e) ? t !== t && e !== e : jB(t, e, r, n, v0, i);
}
var XB = 1, KB = 2;
function ZB(t, e, r, n) {
  var i = r.length, s = i, a = !n;
  if (t == null)
    return !s;
  for (t = Object(t); i--; ) {
    var o = r[i];
    if (a && o[2] ? o[1] !== t[o[0]] : !(o[0] in t))
      return !1;
  }
  for (; ++i < s; ) {
    o = r[i];
    var l = o[0], u = t[l], h = o[1];
    if (a && o[2]) {
      if (u === void 0 && !(l in t))
        return !1;
    } else {
      var f = new en();
      if (n)
        var d = n(u, h, l, t, e, f);
      if (!(d === void 0 ? v0(h, u, XB | KB, n, f) : d))
        return !1;
    }
  }
  return !0;
}
function im(t) {
  return t === t && !Lr(t);
}
function QB(t) {
  for (var e = Sr(t), r = e.length; r--; ) {
    var n = e[r], i = t[n];
    e[r] = [n, i, im(i)];
  }
  return e;
}
function sm(t, e) {
  return function(r) {
    return r == null ? !1 : r[t] === e && (e !== void 0 || t in Object(r));
  };
}
function JB(t) {
  var e = QB(t);
  return e.length == 1 && e[0][2] ? sm(e[0][0], e[0][1]) : function(r) {
    return r === t || ZB(r, t, e);
  };
}
function tD(t, e) {
  return t != null && e in Object(t);
}
function am(t, e, r) {
  e = qc(e, t);
  for (var n = -1, i = e.length, s = !1; ++n < i; ) {
    var a = go(e[n]);
    if (!(s = t != null && r(t, a)))
      break;
    t = t[a];
  }
  return s || ++n != i ? s : (i = t == null ? 0 : t.length, !!i && p0(i) && Vc(a, i) && (Pe(t) || Ps(t)));
}
function om(t, e) {
  return t != null && am(t, e, tD);
}
var eD = 1, rD = 2;
function nD(t, e) {
  return g0(t) && im(e) ? sm(go(t), e) : function(r) {
    var n = CA(r, t);
    return n === void 0 && n === e ? om(r, t) : v0(e, n, eD | rD);
  };
}
function iD(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
function sD(t) {
  return function(e) {
    return $c(e, t);
  };
}
function aD(t) {
  return g0(t) ? iD(go(t)) : sD(t);
}
function _i(t) {
  return typeof t == "function" ? t : t == null ? es : typeof t == "object" ? Pe(t) ? nD(t[0], t[1]) : JB(t) : aD(t);
}
function oD(t) {
  return function(e, r, n) {
    for (var i = -1, s = Object(e), a = n(e), o = a.length; o--; ) {
      var l = a[t ? o : ++i];
      if (r(s[l], l, s) === !1)
        break;
    }
    return e;
  };
}
var lD = oD();
const k0 = lD;
function lm(t, e) {
  return t && k0(t, e, Sr);
}
function cD(t, e) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!bi(r))
      return t(r, n);
    for (var i = r.length, s = e ? i : -1, a = Object(r); (e ? s-- : ++s < i) && n(a[s], s, a) !== !1; )
      ;
    return r;
  };
}
var uD = cD(lm);
const Xc = uD;
var hD = function() {
  return ln.Date.now();
};
const Jd = hD;
var cm = Object.prototype, fD = cm.hasOwnProperty, dD = Uc(function(t, e) {
  t = Object(t);
  var r = -1, n = e.length, i = n > 2 ? e[2] : void 0;
  for (i && Ka(e[0], e[1], i) && (n = 1); ++r < n; )
    for (var s = e[r], a = rs(s), o = -1, l = a.length; ++o < l; ) {
      var u = a[o], h = t[u];
      (h === void 0 || Xs(h, cm[u]) && !fD.call(t, u)) && (t[u] = s[u]);
    }
  return t;
});
const ls = dD;
function Uh(t, e, r) {
  (r !== void 0 && !Xs(t[e], r) || r === void 0 && !(e in t)) && Yc(t, e, r);
}
function um(t) {
  return wn(t) && bi(t);
}
function Wh(t, e) {
  if (!(e === "constructor" && typeof t[e] == "function") && e != "__proto__")
    return t[e];
}
function pD(t) {
  return po(t, rs(t));
}
function gD(t, e, r, n, i, s, a) {
  var o = Wh(t, r), l = Wh(e, r), u = a.get(l);
  if (u) {
    Uh(t, r, u);
    return;
  }
  var h = s ? s(o, l, r + "", t, e, a) : void 0, f = h === void 0;
  if (f) {
    var d = Pe(l), p = !d && Vs(l), m = !d && !p && Gc(l);
    h = l, d || p || m ? Pe(o) ? h = o : um(o) ? h = Dy(o) : p ? (f = !1, h = qy(l, !0)) : m ? (f = !1, h = Zy(l, !0)) : h = [] : Hy(l) || Ps(l) ? (h = o, Ps(o) ? h = pD(o) : (!Lr(o) || Ns(o)) && (h = Qy(l))) : f = !1;
  }
  f && (a.set(l, h), i(h, l, n, s, a), a.delete(l)), Uh(t, r, h);
}
function hm(t, e, r, n, i) {
  t !== e && k0(e, function(s, a) {
    if (i || (i = new en()), Lr(s))
      gD(t, e, a, r, hm, n, i);
    else {
      var o = n ? n(Wh(t, a), s, a + "", t, e, i) : void 0;
      o === void 0 && (o = s), Uh(t, a, o);
    }
  }, rs);
}
function yD(t, e, r) {
  for (var n = -1, i = t == null ? 0 : t.length; ++n < i; )
    if (r(e, t[n]))
      return !0;
  return !1;
}
function ic(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
function fm(t) {
  return typeof t == "function" ? t : es;
}
function dt(t, e) {
  var r = Pe(t) ? My : Xc;
  return r(t, fm(e));
}
function mD(t, e) {
  var r = [];
  return Xc(t, function(n, i, s) {
    e(n, i, s) && r.push(n);
  }), r;
}
function Gn(t, e) {
  var r = Pe(t) ? $y : mD;
  return r(t, _i(e));
}
function bD(t) {
  return function(e, r, n) {
    var i = Object(e);
    if (!bi(e)) {
      var s = _i(r);
      e = Sr(e), r = function(o) {
        return s(i[o], o, i);
      };
    }
    var a = t(e, r, n);
    return a > -1 ? i[s ? e[a] : a] : void 0;
  };
}
var _D = Math.max;
function xD(t, e, r) {
  var n = t == null ? 0 : t.length;
  if (!n)
    return -1;
  var i = r == null ? 0 : J9(r);
  return i < 0 && (i = _D(n + i, 0)), Ny(t, _i(e), i);
}
var vD = bD(xD);
const w0 = vD;
function dm(t, e) {
  var r = -1, n = bi(t) ? Array(t.length) : [];
  return Xc(t, function(i, s, a) {
    n[++r] = e(i, s, a);
  }), n;
}
function Oe(t, e) {
  var r = Pe(t) ? _s : dm;
  return r(t, _i(e));
}
function kD(t, e) {
  return t == null ? t : k0(t, fm(e), rs);
}
function wD(t, e) {
  return t > e;
}
var TD = Object.prototype, ED = TD.hasOwnProperty;
function CD(t, e) {
  return t != null && ED.call(t, e);
}
function Qt(t, e) {
  return t != null && am(t, e, CD);
}
function SD(t, e) {
  return _s(e, function(r) {
    return t[r];
  });
}
function Xn(t) {
  return t == null ? [] : SD(t, Sr(t));
}
var AD = "[object Map]", LD = "[object Set]", BD = Object.prototype, DD = BD.hasOwnProperty;
function vs(t) {
  if (t == null)
    return !0;
  if (bi(t) && (Pe(t) || typeof t == "string" || typeof t.splice == "function" || Vs(t) || Gc(t) || Ps(t)))
    return !t.length;
  var e = zs(t);
  if (e == AD || e == LD)
    return !t.size;
  if (Wc(t))
    return !zy(t).length;
  for (var r in t)
    if (DD.call(t, r))
      return !1;
  return !0;
}
function De(t) {
  return t === void 0;
}
function pm(t, e) {
  return t < e;
}
function Kc(t, e) {
  var r = {};
  return e = _i(e), lm(t, function(n, i, s) {
    Yc(r, i, e(n, i, s));
  }), r;
}
function T0(t, e, r) {
  for (var n = -1, i = t.length; ++n < i; ) {
    var s = t[n], a = e(s);
    if (a != null && (o === void 0 ? a === a && !Ui(a) : r(a, o)))
      var o = a, l = s;
  }
  return l;
}
function Wi(t) {
  return t && t.length ? T0(t, es, wD) : void 0;
}
var ID = kS(function(t, e, r) {
  hm(t, e, r);
});
const Hh = ID;
function Qa(t) {
  return t && t.length ? T0(t, es, pm) : void 0;
}
function E0(t, e) {
  return t && t.length ? T0(t, _i(e), pm) : void 0;
}
function MD(t, e, r, n) {
  if (!Lr(t))
    return t;
  e = qc(e, t);
  for (var i = -1, s = e.length, a = s - 1, o = t; o != null && ++i < s; ) {
    var l = go(e[i]), u = r;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return t;
    if (i != a) {
      var h = o[l];
      u = n ? n(h, l, o) : void 0, u === void 0 && (u = Lr(h) ? h : Vc(e[i + 1]) ? [] : {});
    }
    zc(o, l, u), o = o[l];
  }
  return t;
}
function ND(t, e, r) {
  for (var n = -1, i = e.length, s = {}; ++n < i; ) {
    var a = e[n], o = $c(t, a);
    r(o, a) && MD(s, qc(a, t), o);
  }
  return s;
}
function RD(t, e) {
  var r = t.length;
  for (t.sort(e); r--; )
    t[r] = t[r].value;
  return t;
}
function FD(t, e) {
  if (t !== e) {
    var r = t !== void 0, n = t === null, i = t === t, s = Ui(t), a = e !== void 0, o = e === null, l = e === e, u = Ui(e);
    if (!o && !u && !s && t > e || s && a && l && !o && !u || n && a && l || !r && l || !i)
      return 1;
    if (!n && !s && !u && t < e || u && r && i && !n && !s || o && r && i || !a && i || !l)
      return -1;
  }
  return 0;
}
function OD(t, e, r) {
  for (var n = -1, i = t.criteria, s = e.criteria, a = i.length, o = r.length; ++n < a; ) {
    var l = FD(i[n], s[n]);
    if (l) {
      if (n >= o)
        return l;
      var u = r[n];
      return l * (u == "desc" ? -1 : 1);
    }
  }
  return t.index - e.index;
}
function PD(t, e, r) {
  e.length ? e = _s(e, function(s) {
    return Pe(s) ? function(a) {
      return $c(a, s.length === 1 ? s[0] : s);
    } : s;
  }) : e = [es];
  var n = -1;
  e = _s(e, Hc(_i));
  var i = dm(t, function(s, a, o) {
    var l = _s(e, function(u) {
      return u(s);
    });
    return { criteria: l, index: ++n, value: s };
  });
  return RD(i, function(s, a) {
    return OD(s, a, r);
  });
}
function VD(t, e) {
  return ND(t, e, function(r, n) {
    return om(t, n);
  });
}
var YD = AA(function(t, e) {
  return t == null ? {} : VD(t, e);
});
const Ja = YD;
var zD = Math.ceil, UD = Math.max;
function WD(t, e, r, n) {
  for (var i = -1, s = UD(zD((e - t) / (r || 1)), 0), a = Array(s); s--; )
    a[n ? s : ++i] = t, t += r;
  return a;
}
function HD(t) {
  return function(e, r, n) {
    return n && typeof n != "number" && Ka(e, r, n) && (r = n = void 0), e = ol(e), r === void 0 ? (r = e, e = 0) : r = ol(r), n = n === void 0 ? e < r ? 1 : -1 : ol(n), WD(e, r, n, t);
  };
}
var GD = HD();
const Hi = GD;
function qD(t, e, r, n, i) {
  return i(t, function(s, a, o) {
    r = n ? (n = !1, s) : e(r, s, a, o);
  }), r;
}
function yo(t, e, r) {
  var n = Pe(t) ? RA : qD, i = arguments.length < 3;
  return n(t, _i(e), r, i, Xc);
}
var $D = Uc(function(t, e) {
  if (t == null)
    return [];
  var r = e.length;
  return r > 1 && Ka(t, e[0], e[1]) ? e = [] : r > 2 && Ka(e[0], e[1], e[2]) && (e = [e[0]]), PD(t, jc(e, 1), []);
});
const mo = $D;
var jD = 1 / 0, XD = xs && 1 / x0(new xs([, -0]))[1] == jD ? function(t) {
  return new xs(t);
} : iS;
const KD = XD;
var ZD = 200;
function QD(t, e, r) {
  var n = -1, i = yS, s = t.length, a = !0, o = [], l = o;
  if (r)
    a = !1, i = yD;
  else if (s >= ZD) {
    var u = e ? null : KD(t);
    if (u)
      return x0(u);
    a = !1, i = rm, l = new Za();
  } else
    l = e ? [] : o;
  t:
    for (; ++n < s; ) {
      var h = t[n], f = e ? e(h) : h;
      if (h = r || h !== 0 ? h : 0, a && f === f) {
        for (var d = l.length; d--; )
          if (l[d] === f)
            continue t;
        e && l.push(f), o.push(h);
      } else
        i(l, f, r) || (l !== o && l.push(f), o.push(h));
    }
  return o;
}
var JD = Uc(function(t) {
  return QD(jc(t, 1, um, !0));
});
const tI = JD;
var eI = 0;
function Zc(t) {
  var e = ++eI;
  return Uy(t) + e;
}
function rI(t, e, r) {
  for (var n = -1, i = t.length, s = e.length, a = {}; ++n < i; ) {
    var o = n < s ? e[n] : void 0;
    r(a, t[n], o);
  }
  return a;
}
function nI(t, e) {
  return rI(t || [], e || [], zc);
}
var iI = "\0", Ci = "\0", t2 = "";
class Ve {
  constructor(e = {}) {
    this._isDirected = Qt(e, "directed") ? e.directed : !0, this._isMultigraph = Qt(e, "multigraph") ? e.multigraph : !1, this._isCompound = Qt(e, "compound") ? e.compound : !1, this._label = void 0, this._defaultNodeLabelFn = gs(void 0), this._defaultEdgeLabelFn = gs(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children[Ci] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
  }
  /* === Graph functions ========= */
  isDirected() {
    return this._isDirected;
  }
  isMultigraph() {
    return this._isMultigraph;
  }
  isCompound() {
    return this._isCompound;
  }
  setGraph(e) {
    return this._label = e, this;
  }
  graph() {
    return this._label;
  }
  /* === Node functions ========== */
  setDefaultNodeLabel(e) {
    return Ns(e) || (e = gs(e)), this._defaultNodeLabelFn = e, this;
  }
  nodeCount() {
    return this._nodeCount;
  }
  nodes() {
    return Sr(this._nodes);
  }
  sources() {
    var e = this;
    return Gn(this.nodes(), function(r) {
      return vs(e._in[r]);
    });
  }
  sinks() {
    var e = this;
    return Gn(this.nodes(), function(r) {
      return vs(e._out[r]);
    });
  }
  setNodes(e, r) {
    var n = arguments, i = this;
    return dt(e, function(s) {
      n.length > 1 ? i.setNode(s, r) : i.setNode(s);
    }), this;
  }
  setNode(e, r) {
    return Qt(this._nodes, e) ? (arguments.length > 1 && (this._nodes[e] = r), this) : (this._nodes[e] = arguments.length > 1 ? r : this._defaultNodeLabelFn(e), this._isCompound && (this._parent[e] = Ci, this._children[e] = {}, this._children[Ci][e] = !0), this._in[e] = {}, this._preds[e] = {}, this._out[e] = {}, this._sucs[e] = {}, ++this._nodeCount, this);
  }
  node(e) {
    return this._nodes[e];
  }
  hasNode(e) {
    return Qt(this._nodes, e);
  }
  removeNode(e) {
    var r = this;
    if (Qt(this._nodes, e)) {
      var n = function(i) {
        r.removeEdge(r._edgeObjs[i]);
      };
      delete this._nodes[e], this._isCompound && (this._removeFromParentsChildList(e), delete this._parent[e], dt(this.children(e), function(i) {
        r.setParent(i);
      }), delete this._children[e]), dt(Sr(this._in[e]), n), delete this._in[e], delete this._preds[e], dt(Sr(this._out[e]), n), delete this._out[e], delete this._sucs[e], --this._nodeCount;
    }
    return this;
  }
  setParent(e, r) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (De(r))
      r = Ci;
    else {
      r += "";
      for (var n = r; !De(n); n = this.parent(n))
        if (n === e)
          throw new Error("Setting " + r + " as parent of " + e + " would create a cycle");
      this.setNode(r);
    }
    return this.setNode(e), this._removeFromParentsChildList(e), this._parent[e] = r, this._children[r][e] = !0, this;
  }
  _removeFromParentsChildList(e) {
    delete this._children[this._parent[e]][e];
  }
  parent(e) {
    if (this._isCompound) {
      var r = this._parent[e];
      if (r !== Ci)
        return r;
    }
  }
  children(e) {
    if (De(e) && (e = Ci), this._isCompound) {
      var r = this._children[e];
      if (r)
        return Sr(r);
    } else {
      if (e === Ci)
        return this.nodes();
      if (this.hasNode(e))
        return [];
    }
  }
  predecessors(e) {
    var r = this._preds[e];
    if (r)
      return Sr(r);
  }
  successors(e) {
    var r = this._sucs[e];
    if (r)
      return Sr(r);
  }
  neighbors(e) {
    var r = this.predecessors(e);
    if (r)
      return tI(r, this.successors(e));
  }
  isLeaf(e) {
    var r;
    return this.isDirected() ? r = this.successors(e) : r = this.neighbors(e), r.length === 0;
  }
  filterNodes(e) {
    var r = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    r.setGraph(this.graph());
    var n = this;
    dt(this._nodes, function(a, o) {
      e(o) && r.setNode(o, a);
    }), dt(this._edgeObjs, function(a) {
      r.hasNode(a.v) && r.hasNode(a.w) && r.setEdge(a, n.edge(a));
    });
    var i = {};
    function s(a) {
      var o = n.parent(a);
      return o === void 0 || r.hasNode(o) ? (i[a] = o, o) : o in i ? i[o] : s(o);
    }
    return this._isCompound && dt(r.nodes(), function(a) {
      r.setParent(a, s(a));
    }), r;
  }
  /* === Edge functions ========== */
  setDefaultEdgeLabel(e) {
    return Ns(e) || (e = gs(e)), this._defaultEdgeLabelFn = e, this;
  }
  edgeCount() {
    return this._edgeCount;
  }
  edges() {
    return Xn(this._edgeObjs);
  }
  setPath(e, r) {
    var n = this, i = arguments;
    return yo(e, function(s, a) {
      return i.length > 1 ? n.setEdge(s, a, r) : n.setEdge(s, a), a;
    }), this;
  }
  /*
   * setEdge(v, w, [value, [name]])
   * setEdge({ v, w, [name] }, [value])
   */
  setEdge() {
    var e, r, n, i, s = !1, a = arguments[0];
    typeof a == "object" && a !== null && "v" in a ? (e = a.v, r = a.w, n = a.name, arguments.length === 2 && (i = arguments[1], s = !0)) : (e = a, r = arguments[1], n = arguments[3], arguments.length > 2 && (i = arguments[2], s = !0)), e = "" + e, r = "" + r, De(n) || (n = "" + n);
    var o = xa(this._isDirected, e, r, n);
    if (Qt(this._edgeLabels, o))
      return s && (this._edgeLabels[o] = i), this;
    if (!De(n) && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(e), this.setNode(r), this._edgeLabels[o] = s ? i : this._defaultEdgeLabelFn(e, r, n);
    var l = sI(this._isDirected, e, r, n);
    return e = l.v, r = l.w, Object.freeze(l), this._edgeObjs[o] = l, e2(this._preds[r], e), e2(this._sucs[e], r), this._in[r][o] = l, this._out[e][o] = l, this._edgeCount++, this;
  }
  edge(e, r, n) {
    var i = arguments.length === 1 ? zu(this._isDirected, arguments[0]) : xa(this._isDirected, e, r, n);
    return this._edgeLabels[i];
  }
  hasEdge(e, r, n) {
    var i = arguments.length === 1 ? zu(this._isDirected, arguments[0]) : xa(this._isDirected, e, r, n);
    return Qt(this._edgeLabels, i);
  }
  removeEdge(e, r, n) {
    var i = arguments.length === 1 ? zu(this._isDirected, arguments[0]) : xa(this._isDirected, e, r, n), s = this._edgeObjs[i];
    return s && (e = s.v, r = s.w, delete this._edgeLabels[i], delete this._edgeObjs[i], r2(this._preds[r], e), r2(this._sucs[e], r), delete this._in[r][i], delete this._out[e][i], this._edgeCount--), this;
  }
  inEdges(e, r) {
    var n = this._in[e];
    if (n) {
      var i = Xn(n);
      return r ? Gn(i, function(s) {
        return s.v === r;
      }) : i;
    }
  }
  outEdges(e, r) {
    var n = this._out[e];
    if (n) {
      var i = Xn(n);
      return r ? Gn(i, function(s) {
        return s.w === r;
      }) : i;
    }
  }
  nodeEdges(e, r) {
    var n = this.inEdges(e, r);
    if (n)
      return n.concat(this.outEdges(e, r));
  }
}
Ve.prototype._nodeCount = 0;
Ve.prototype._edgeCount = 0;
function e2(t, e) {
  t[e] ? t[e]++ : t[e] = 1;
}
function r2(t, e) {
  --t[e] || delete t[e];
}
function xa(t, e, r, n) {
  var i = "" + e, s = "" + r;
  if (!t && i > s) {
    var a = i;
    i = s, s = a;
  }
  return i + t2 + s + t2 + (De(n) ? iI : n);
}
function sI(t, e, r, n) {
  var i = "" + e, s = "" + r;
  if (!t && i > s) {
    var a = i;
    i = s, s = a;
  }
  var o = { v: i, w: s };
  return n && (o.name = n), o;
}
function zu(t, e) {
  return xa(t, e.v, e.w, e.name);
}
class aI {
  constructor() {
    var e = {};
    e._next = e._prev = e, this._sentinel = e;
  }
  dequeue() {
    var e = this._sentinel, r = e._prev;
    if (r !== e)
      return n2(r), r;
  }
  enqueue(e) {
    var r = this._sentinel;
    e._prev && e._next && n2(e), e._next = r._next, r._next._prev = e, r._next = e, e._prev = r;
  }
  toString() {
    for (var e = [], r = this._sentinel, n = r._prev; n !== r; )
      e.push(JSON.stringify(n, oI)), n = n._prev;
    return "[" + e.join(", ") + "]";
  }
}
function n2(t) {
  t._prev._next = t._next, t._next._prev = t._prev, delete t._next, delete t._prev;
}
function oI(t, e) {
  if (t !== "_next" && t !== "_prev")
    return e;
}
var lI = gs(1);
function cI(t, e) {
  if (t.nodeCount() <= 1)
    return [];
  var r = hI(t, e || lI), n = uI(r.graph, r.buckets, r.zeroIdx);
  return Qs(
    Oe(n, function(i) {
      return t.outEdges(i.v, i.w);
    })
  );
}
function uI(t, e, r) {
  for (var n = [], i = e[e.length - 1], s = e[0], a; t.nodeCount(); ) {
    for (; a = s.dequeue(); )
      Uu(t, e, r, a);
    for (; a = i.dequeue(); )
      Uu(t, e, r, a);
    if (t.nodeCount()) {
      for (var o = e.length - 2; o > 0; --o)
        if (a = e[o].dequeue(), a) {
          n = n.concat(Uu(t, e, r, a, !0));
          break;
        }
    }
  }
  return n;
}
function Uu(t, e, r, n, i) {
  var s = i ? [] : void 0;
  return dt(t.inEdges(n.v), function(a) {
    var o = t.edge(a), l = t.node(a.v);
    i && s.push({ v: a.v, w: a.w }), l.out -= o, Gh(e, r, l);
  }), dt(t.outEdges(n.v), function(a) {
    var o = t.edge(a), l = a.w, u = t.node(l);
    u.in -= o, Gh(e, r, u);
  }), t.removeNode(n.v), s;
}
function hI(t, e) {
  var r = new Ve(), n = 0, i = 0;
  dt(t.nodes(), function(o) {
    r.setNode(o, { v: o, in: 0, out: 0 });
  }), dt(t.edges(), function(o) {
    var l = r.edge(o.v, o.w) || 0, u = e(o), h = l + u;
    r.setEdge(o.v, o.w, h), i = Math.max(i, r.node(o.v).out += u), n = Math.max(n, r.node(o.w).in += u);
  });
  var s = Hi(i + n + 3).map(function() {
    return new aI();
  }), a = n + 1;
  return dt(r.nodes(), function(o) {
    Gh(s, a, r.node(o));
  }), { graph: r, buckets: s, zeroIdx: a };
}
function Gh(t, e, r) {
  r.out ? r.in ? t[r.out - r.in + e].enqueue(r) : t[t.length - 1].enqueue(r) : t[0].enqueue(r);
}
function fI(t) {
  var e = t.graph().acyclicer === "greedy" ? cI(t, r(t)) : dI(t);
  dt(e, function(n) {
    var i = t.edge(n);
    t.removeEdge(n), i.forwardName = n.name, i.reversed = !0, t.setEdge(n.w, n.v, i, Zc("rev"));
  });
  function r(n) {
    return function(i) {
      return n.edge(i).weight;
    };
  }
}
function dI(t) {
  var e = [], r = {}, n = {};
  function i(s) {
    Qt(n, s) || (n[s] = !0, r[s] = !0, dt(t.outEdges(s), function(a) {
      Qt(r, a.w) ? e.push(a) : i(a.w);
    }), delete r[s]);
  }
  return dt(t.nodes(), i), e;
}
function pI(t) {
  dt(t.edges(), function(e) {
    var r = t.edge(e);
    if (r.reversed) {
      t.removeEdge(e);
      var n = r.forwardName;
      delete r.reversed, delete r.forwardName, t.setEdge(e.w, e.v, r, n);
    }
  });
}
function Js(t, e, r, n) {
  var i;
  do
    i = Zc(n);
  while (t.hasNode(i));
  return r.dummy = e, t.setNode(i, r), i;
}
function gI(t) {
  var e = new Ve().setGraph(t.graph());
  return dt(t.nodes(), function(r) {
    e.setNode(r, t.node(r));
  }), dt(t.edges(), function(r) {
    var n = e.edge(r.v, r.w) || { weight: 0, minlen: 1 }, i = t.edge(r);
    e.setEdge(r.v, r.w, {
      weight: n.weight + i.weight,
      minlen: Math.max(n.minlen, i.minlen)
    });
  }), e;
}
function gm(t) {
  var e = new Ve({ multigraph: t.isMultigraph() }).setGraph(t.graph());
  return dt(t.nodes(), function(r) {
    t.children(r).length || e.setNode(r, t.node(r));
  }), dt(t.edges(), function(r) {
    e.setEdge(r, t.edge(r));
  }), e;
}
function i2(t, e) {
  var r = t.x, n = t.y, i = e.x - r, s = e.y - n, a = t.width / 2, o = t.height / 2;
  if (!i && !s)
    throw new Error("Not possible to find intersection inside of the rectangle");
  var l, u;
  return Math.abs(s) * a > Math.abs(i) * o ? (s < 0 && (o = -o), l = o * i / s, u = o) : (i < 0 && (a = -a), l = a, u = a * s / i), { x: r + l, y: n + u };
}
function Qc(t) {
  var e = Oe(Hi(ym(t) + 1), function() {
    return [];
  });
  return dt(t.nodes(), function(r) {
    var n = t.node(r), i = n.rank;
    De(i) || (e[i][n.order] = r);
  }), e;
}
function yI(t) {
  var e = Qa(
    Oe(t.nodes(), function(r) {
      return t.node(r).rank;
    })
  );
  dt(t.nodes(), function(r) {
    var n = t.node(r);
    Qt(n, "rank") && (n.rank -= e);
  });
}
function mI(t) {
  var e = Qa(
    Oe(t.nodes(), function(s) {
      return t.node(s).rank;
    })
  ), r = [];
  dt(t.nodes(), function(s) {
    var a = t.node(s).rank - e;
    r[a] || (r[a] = []), r[a].push(s);
  });
  var n = 0, i = t.graph().nodeRankFactor;
  dt(r, function(s, a) {
    De(s) && a % i !== 0 ? --n : n && dt(s, function(o) {
      t.node(o).rank += n;
    });
  });
}
function s2(t, e, r, n) {
  var i = {
    width: 0,
    height: 0
  };
  return arguments.length >= 4 && (i.rank = r, i.order = n), Js(t, "border", i, e);
}
function ym(t) {
  return Wi(
    Oe(t.nodes(), function(e) {
      var r = t.node(e).rank;
      if (!De(r))
        return r;
    })
  );
}
function bI(t, e) {
  var r = { lhs: [], rhs: [] };
  return dt(t, function(n) {
    e(n) ? r.lhs.push(n) : r.rhs.push(n);
  }), r;
}
function _I(t, e) {
  var r = Jd();
  try {
    return e();
  } finally {
    console.log(t + " time: " + (Jd() - r) + "ms");
  }
}
function xI(t, e) {
  return e();
}
function vI(t) {
  function e(r) {
    var n = t.children(r), i = t.node(r);
    if (n.length && dt(n, e), Qt(i, "minRank")) {
      i.borderLeft = [], i.borderRight = [];
      for (var s = i.minRank, a = i.maxRank + 1; s < a; ++s)
        a2(t, "borderLeft", "_bl", r, i, s), a2(t, "borderRight", "_br", r, i, s);
    }
  }
  dt(t.children(), e);
}
function a2(t, e, r, n, i, s) {
  var a = { width: 0, height: 0, rank: s, borderType: e }, o = i[e][s - 1], l = Js(t, "border", a, r);
  i[e][s] = l, t.setParent(l, n), o && t.setEdge(o, l, { weight: 1 });
}
function kI(t) {
  var e = t.graph().rankdir.toLowerCase();
  (e === "lr" || e === "rl") && mm(t);
}
function wI(t) {
  var e = t.graph().rankdir.toLowerCase();
  (e === "bt" || e === "rl") && TI(t), (e === "lr" || e === "rl") && (EI(t), mm(t));
}
function mm(t) {
  dt(t.nodes(), function(e) {
    o2(t.node(e));
  }), dt(t.edges(), function(e) {
    o2(t.edge(e));
  });
}
function o2(t) {
  var e = t.width;
  t.width = t.height, t.height = e;
}
function TI(t) {
  dt(t.nodes(), function(e) {
    Wu(t.node(e));
  }), dt(t.edges(), function(e) {
    var r = t.edge(e);
    dt(r.points, Wu), Qt(r, "y") && Wu(r);
  });
}
function Wu(t) {
  t.y = -t.y;
}
function EI(t) {
  dt(t.nodes(), function(e) {
    Hu(t.node(e));
  }), dt(t.edges(), function(e) {
    var r = t.edge(e);
    dt(r.points, Hu), Qt(r, "x") && Hu(r);
  });
}
function Hu(t) {
  var e = t.x;
  t.x = t.y, t.y = e;
}
function CI(t) {
  t.graph().dummyChains = [], dt(t.edges(), function(e) {
    SI(t, e);
  });
}
function SI(t, e) {
  var r = e.v, n = t.node(r).rank, i = e.w, s = t.node(i).rank, a = e.name, o = t.edge(e), l = o.labelRank;
  if (s !== n + 1) {
    t.removeEdge(e);
    var u, h, f;
    for (f = 0, ++n; n < s; ++f, ++n)
      o.points = [], h = {
        width: 0,
        height: 0,
        edgeLabel: o,
        edgeObj: e,
        rank: n
      }, u = Js(t, "edge", h, "_d"), n === l && (h.width = o.width, h.height = o.height, h.dummy = "edge-label", h.labelpos = o.labelpos), t.setEdge(r, u, { weight: o.weight }, a), f === 0 && t.graph().dummyChains.push(u), r = u;
    t.setEdge(r, i, { weight: o.weight }, a);
  }
}
function AI(t) {
  dt(t.graph().dummyChains, function(e) {
    var r = t.node(e), n = r.edgeLabel, i;
    for (t.setEdge(r.edgeObj, n); r.dummy; )
      i = t.successors(e)[0], t.removeNode(e), n.points.push({ x: r.x, y: r.y }), r.dummy === "edge-label" && (n.x = r.x, n.y = r.y, n.width = r.width, n.height = r.height), e = i, r = t.node(e);
  });
}
function C0(t) {
  var e = {};
  function r(n) {
    var i = t.node(n);
    if (Qt(e, n))
      return i.rank;
    e[n] = !0;
    var s = Qa(
      Oe(t.outEdges(n), function(a) {
        return r(a.w) - t.edge(a).minlen;
      })
    );
    return (s === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
    s === void 0 || // return value of _.map([]) for Lodash 4
    s === null) && (s = 0), i.rank = s;
  }
  dt(t.sources(), r);
}
function to(t, e) {
  return t.node(e.w).rank - t.node(e.v).rank - t.edge(e).minlen;
}
function bm(t) {
  var e = new Ve({ directed: !1 }), r = t.nodes()[0], n = t.nodeCount();
  e.setNode(r, {});
  for (var i, s; LI(e, t) < n; )
    i = BI(e, t), s = e.hasNode(i.v) ? to(t, i) : -to(t, i), DI(e, t, s);
  return e;
}
function LI(t, e) {
  function r(n) {
    dt(e.nodeEdges(n), function(i) {
      var s = i.v, a = n === s ? i.w : s;
      !t.hasNode(a) && !to(e, i) && (t.setNode(a, {}), t.setEdge(n, a, {}), r(a));
    });
  }
  return dt(t.nodes(), r), t.nodeCount();
}
function BI(t, e) {
  return E0(e.edges(), function(r) {
    if (t.hasNode(r.v) !== t.hasNode(r.w))
      return to(e, r);
  });
}
function DI(t, e, r) {
  dt(t.nodes(), function(n) {
    e.node(n).rank += r;
  });
}
function II() {
}
II.prototype = new Error();
function _m(t, e, r) {
  Pe(e) || (e = [e]);
  var n = (t.isDirected() ? t.successors : t.neighbors).bind(t), i = [], s = {};
  return dt(e, function(a) {
    if (!t.hasNode(a))
      throw new Error("Graph does not have node: " + a);
    xm(t, a, r === "post", s, n, i);
  }), i;
}
function xm(t, e, r, n, i, s) {
  Qt(n, e) || (n[e] = !0, r || s.push(e), dt(i(e), function(a) {
    xm(t, a, r, n, i, s);
  }), r && s.push(e));
}
function MI(t, e) {
  return _m(t, e, "post");
}
function NI(t, e) {
  return _m(t, e, "pre");
}
ns.initLowLimValues = A0;
ns.initCutValues = S0;
ns.calcCutValue = vm;
ns.leaveEdge = wm;
ns.enterEdge = Tm;
ns.exchangeEdges = Em;
function ns(t) {
  t = gI(t), C0(t);
  var e = bm(t);
  A0(e), S0(e, t);
  for (var r, n; r = wm(e); )
    n = Tm(e, t, r), Em(e, t, r, n);
}
function S0(t, e) {
  var r = MI(t, t.nodes());
  r = r.slice(0, r.length - 1), dt(r, function(n) {
    RI(t, e, n);
  });
}
function RI(t, e, r) {
  var n = t.node(r), i = n.parent;
  t.edge(r, i).cutvalue = vm(t, e, r);
}
function vm(t, e, r) {
  var n = t.node(r), i = n.parent, s = !0, a = e.edge(r, i), o = 0;
  return a || (s = !1, a = e.edge(i, r)), o = a.weight, dt(e.nodeEdges(r), function(l) {
    var u = l.v === r, h = u ? l.w : l.v;
    if (h !== i) {
      var f = u === s, d = e.edge(l).weight;
      if (o += f ? d : -d, OI(t, r, h)) {
        var p = t.edge(r, h).cutvalue;
        o += f ? -p : p;
      }
    }
  }), o;
}
function A0(t, e) {
  arguments.length < 2 && (e = t.nodes()[0]), km(t, {}, 1, e);
}
function km(t, e, r, n, i) {
  var s = r, a = t.node(n);
  return e[n] = !0, dt(t.neighbors(n), function(o) {
    Qt(e, o) || (r = km(t, e, r, o, n));
  }), a.low = s, a.lim = r++, i ? a.parent = i : delete a.parent, r;
}
function wm(t) {
  return w0(t.edges(), function(e) {
    return t.edge(e).cutvalue < 0;
  });
}
function Tm(t, e, r) {
  var n = r.v, i = r.w;
  e.hasEdge(n, i) || (n = r.w, i = r.v);
  var s = t.node(n), a = t.node(i), o = s, l = !1;
  s.lim > a.lim && (o = a, l = !0);
  var u = Gn(e.edges(), function(h) {
    return l === l2(t, t.node(h.v), o) && l !== l2(t, t.node(h.w), o);
  });
  return E0(u, function(h) {
    return to(e, h);
  });
}
function Em(t, e, r, n) {
  var i = r.v, s = r.w;
  t.removeEdge(i, s), t.setEdge(n.v, n.w, {}), A0(t), S0(t, e), FI(t, e);
}
function FI(t, e) {
  var r = w0(t.nodes(), function(i) {
    return !e.node(i).parent;
  }), n = NI(t, r);
  n = n.slice(1), dt(n, function(i) {
    var s = t.node(i).parent, a = e.edge(i, s), o = !1;
    a || (a = e.edge(s, i), o = !0), e.node(i).rank = e.node(s).rank + (o ? a.minlen : -a.minlen);
  });
}
function OI(t, e, r) {
  return t.hasEdge(e, r);
}
function l2(t, e, r) {
  return r.low <= e.lim && e.lim <= r.lim;
}
function PI(t) {
  switch (t.graph().ranker) {
    case "network-simplex":
      c2(t);
      break;
    case "tight-tree":
      YI(t);
      break;
    case "longest-path":
      VI(t);
      break;
    default:
      c2(t);
  }
}
var VI = C0;
function YI(t) {
  C0(t), bm(t);
}
function c2(t) {
  ns(t);
}
function zI(t) {
  var e = Js(t, "root", {}, "_root"), r = UI(t), n = Wi(Xn(r)) - 1, i = 2 * n + 1;
  t.graph().nestingRoot = e, dt(t.edges(), function(a) {
    t.edge(a).minlen *= i;
  });
  var s = WI(t) + 1;
  dt(t.children(), function(a) {
    Cm(t, e, i, s, n, r, a);
  }), t.graph().nodeRankFactor = i;
}
function Cm(t, e, r, n, i, s, a) {
  var o = t.children(a);
  if (!o.length) {
    a !== e && t.setEdge(e, a, { weight: 0, minlen: r });
    return;
  }
  var l = s2(t, "_bt"), u = s2(t, "_bb"), h = t.node(a);
  t.setParent(l, a), h.borderTop = l, t.setParent(u, a), h.borderBottom = u, dt(o, function(f) {
    Cm(t, e, r, n, i, s, f);
    var d = t.node(f), p = d.borderTop ? d.borderTop : f, m = d.borderBottom ? d.borderBottom : f, _ = d.borderTop ? n : 2 * n, v = p !== m ? 1 : i - s[a] + 1;
    t.setEdge(l, p, {
      weight: _,
      minlen: v,
      nestingEdge: !0
    }), t.setEdge(m, u, {
      weight: _,
      minlen: v,
      nestingEdge: !0
    });
  }), t.parent(a) || t.setEdge(e, l, { weight: 0, minlen: i + s[a] });
}
function UI(t) {
  var e = {};
  function r(n, i) {
    var s = t.children(n);
    s && s.length && dt(s, function(a) {
      r(a, i + 1);
    }), e[n] = i;
  }
  return dt(t.children(), function(n) {
    r(n, 1);
  }), e;
}
function WI(t) {
  return yo(
    t.edges(),
    function(e, r) {
      return e + t.edge(r).weight;
    },
    0
  );
}
function HI(t) {
  var e = t.graph();
  t.removeNode(e.nestingRoot), delete e.nestingRoot, dt(t.edges(), function(r) {
    var n = t.edge(r);
    n.nestingEdge && t.removeEdge(r);
  });
}
function GI(t, e, r) {
  var n = {}, i;
  dt(r, function(s) {
    for (var a = t.parent(s), o, l; a; ) {
      if (o = t.parent(a), o ? (l = n[o], n[o] = a) : (l = i, i = a), l && l !== a) {
        e.setEdge(l, a);
        return;
      }
      a = o;
    }
  });
}
function qI(t, e, r) {
  var n = $I(t), i = new Ve({ compound: !0 }).setGraph({ root: n }).setDefaultNodeLabel(function(s) {
    return t.node(s);
  });
  return dt(t.nodes(), function(s) {
    var a = t.node(s), o = t.parent(s);
    (a.rank === e || a.minRank <= e && e <= a.maxRank) && (i.setNode(s), i.setParent(s, o || n), dt(t[r](s), function(l) {
      var u = l.v === s ? l.w : l.v, h = i.edge(u, s), f = De(h) ? 0 : h.weight;
      i.setEdge(u, s, { weight: t.edge(l).weight + f });
    }), Qt(a, "minRank") && i.setNode(s, {
      borderLeft: a.borderLeft[e],
      borderRight: a.borderRight[e]
    }));
  }), i;
}
function $I(t) {
  for (var e; t.hasNode(e = Zc("_root")); )
    ;
  return e;
}
function jI(t, e) {
  for (var r = 0, n = 1; n < e.length; ++n)
    r += XI(t, e[n - 1], e[n]);
  return r;
}
function XI(t, e, r) {
  for (var n = nI(
    r,
    Oe(r, function(u, h) {
      return h;
    })
  ), i = Qs(
    Oe(e, function(u) {
      return mo(
        Oe(t.outEdges(u), function(h) {
          return { pos: n[h.w], weight: t.edge(h).weight };
        }),
        "pos"
      );
    })
  ), s = 1; s < r.length; )
    s <<= 1;
  var a = 2 * s - 1;
  s -= 1;
  var o = Oe(new Array(a), function() {
    return 0;
  }), l = 0;
  return dt(
    // @ts-expect-error
    i.forEach(function(u) {
      var h = u.pos + s;
      o[h] += u.weight;
      for (var f = 0; h > 0; )
        h % 2 && (f += o[h + 1]), h = h - 1 >> 1, o[h] += u.weight;
      l += u.weight * f;
    })
  ), l;
}
function KI(t) {
  var e = {}, r = Gn(t.nodes(), function(o) {
    return !t.children(o).length;
  }), n = Wi(
    Oe(r, function(o) {
      return t.node(o).rank;
    })
  ), i = Oe(Hi(n + 1), function() {
    return [];
  });
  function s(o) {
    if (!Qt(e, o)) {
      e[o] = !0;
      var l = t.node(o);
      i[l.rank].push(o), dt(t.successors(o), s);
    }
  }
  var a = mo(r, function(o) {
    return t.node(o).rank;
  });
  return dt(a, s), i;
}
function ZI(t, e) {
  return Oe(e, function(r) {
    var n = t.inEdges(r);
    if (n.length) {
      var i = yo(
        n,
        function(s, a) {
          var o = t.edge(a), l = t.node(a.v);
          return {
            sum: s.sum + o.weight * l.order,
            weight: s.weight + o.weight
          };
        },
        { sum: 0, weight: 0 }
      );
      return {
        v: r,
        barycenter: i.sum / i.weight,
        weight: i.weight
      };
    } else
      return { v: r };
  });
}
function QI(t, e) {
  var r = {};
  dt(t, function(i, s) {
    var a = r[i.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [i.v],
      i: s
    };
    De(i.barycenter) || (a.barycenter = i.barycenter, a.weight = i.weight);
  }), dt(e.edges(), function(i) {
    var s = r[i.v], a = r[i.w];
    !De(s) && !De(a) && (a.indegree++, s.out.push(r[i.w]));
  });
  var n = Gn(r, function(i) {
    return !i.indegree;
  });
  return JI(n);
}
function JI(t) {
  var e = [];
  function r(s) {
    return function(a) {
      a.merged || (De(a.barycenter) || De(s.barycenter) || a.barycenter >= s.barycenter) && tM(s, a);
    };
  }
  function n(s) {
    return function(a) {
      a.in.push(s), --a.indegree === 0 && t.push(a);
    };
  }
  for (; t.length; ) {
    var i = t.pop();
    e.push(i), dt(i.in.reverse(), r(i)), dt(i.out, n(i));
  }
  return Oe(
    Gn(e, function(s) {
      return !s.merged;
    }),
    function(s) {
      return Ja(s, ["vs", "i", "barycenter", "weight"]);
    }
  );
}
function tM(t, e) {
  var r = 0, n = 0;
  t.weight && (r += t.barycenter * t.weight, n += t.weight), e.weight && (r += e.barycenter * e.weight, n += e.weight), t.vs = e.vs.concat(t.vs), t.barycenter = r / n, t.weight = n, t.i = Math.min(e.i, t.i), e.merged = !0;
}
function eM(t, e) {
  var r = bI(t, function(h) {
    return Qt(h, "barycenter");
  }), n = r.lhs, i = mo(r.rhs, function(h) {
    return -h.i;
  }), s = [], a = 0, o = 0, l = 0;
  n.sort(rM(!!e)), l = u2(s, i, l), dt(n, function(h) {
    l += h.vs.length, s.push(h.vs), a += h.barycenter * h.weight, o += h.weight, l = u2(s, i, l);
  });
  var u = { vs: Qs(s) };
  return o && (u.barycenter = a / o, u.weight = o), u;
}
function u2(t, e, r) {
  for (var n; e.length && (n = ic(e)).i <= r; )
    e.pop(), t.push(n.vs), r++;
  return r;
}
function rM(t) {
  return function(e, r) {
    return e.barycenter < r.barycenter ? -1 : e.barycenter > r.barycenter ? 1 : t ? r.i - e.i : e.i - r.i;
  };
}
function Sm(t, e, r, n) {
  var i = t.children(e), s = t.node(e), a = s ? s.borderLeft : void 0, o = s ? s.borderRight : void 0, l = {};
  a && (i = Gn(i, function(m) {
    return m !== a && m !== o;
  }));
  var u = ZI(t, i);
  dt(u, function(m) {
    if (t.children(m.v).length) {
      var _ = Sm(t, m.v, r, n);
      l[m.v] = _, Qt(_, "barycenter") && iM(m, _);
    }
  });
  var h = QI(u, r);
  nM(h, l);
  var f = eM(h, n);
  if (a && (f.vs = Qs([a, f.vs, o]), t.predecessors(a).length)) {
    var d = t.node(t.predecessors(a)[0]), p = t.node(t.predecessors(o)[0]);
    Qt(f, "barycenter") || (f.barycenter = 0, f.weight = 0), f.barycenter = (f.barycenter * f.weight + d.order + p.order) / (f.weight + 2), f.weight += 2;
  }
  return f;
}
function nM(t, e) {
  dt(t, function(r) {
    r.vs = Qs(
      r.vs.map(function(n) {
        return e[n] ? e[n].vs : n;
      })
    );
  });
}
function iM(t, e) {
  De(t.barycenter) ? (t.barycenter = e.barycenter, t.weight = e.weight) : (t.barycenter = (t.barycenter * t.weight + e.barycenter * e.weight) / (t.weight + e.weight), t.weight += e.weight);
}
function sM(t) {
  var e = ym(t), r = h2(t, Hi(1, e + 1), "inEdges"), n = h2(t, Hi(e - 1, -1, -1), "outEdges"), i = KI(t);
  f2(t, i);
  for (var s = Number.POSITIVE_INFINITY, a, o = 0, l = 0; l < 4; ++o, ++l) {
    aM(o % 2 ? r : n, o % 4 >= 2), i = Qc(t);
    var u = jI(t, i);
    u < s && (l = 0, a = xB(i), s = u);
  }
  f2(t, a);
}
function h2(t, e, r) {
  return Oe(e, function(n) {
    return qI(t, n, r);
  });
}
function aM(t, e) {
  var r = new Ve();
  dt(t, function(n) {
    var i = n.graph().root, s = Sm(n, i, r, e);
    dt(s.vs, function(a, o) {
      n.node(a).order = o;
    }), GI(n, r, s.vs);
  });
}
function f2(t, e) {
  dt(e, function(r) {
    dt(r, function(n, i) {
      t.node(n).order = i;
    });
  });
}
function oM(t) {
  var e = cM(t);
  dt(t.graph().dummyChains, function(r) {
    for (var n = t.node(r), i = n.edgeObj, s = lM(t, e, i.v, i.w), a = s.path, o = s.lca, l = 0, u = a[l], h = !0; r !== i.w; ) {
      if (n = t.node(r), h) {
        for (; (u = a[l]) !== o && t.node(u).maxRank < n.rank; )
          l++;
        u === o && (h = !1);
      }
      if (!h) {
        for (; l < a.length - 1 && t.node(u = a[l + 1]).minRank <= n.rank; )
          l++;
        u = a[l];
      }
      t.setParent(r, u), r = t.successors(r)[0];
    }
  });
}
function lM(t, e, r, n) {
  var i = [], s = [], a = Math.min(e[r].low, e[n].low), o = Math.max(e[r].lim, e[n].lim), l, u;
  l = r;
  do
    l = t.parent(l), i.push(l);
  while (l && (e[l].low > a || o > e[l].lim));
  for (u = l, l = n; (l = t.parent(l)) !== u; )
    s.push(l);
  return { path: i.concat(s.reverse()), lca: u };
}
function cM(t) {
  var e = {}, r = 0;
  function n(i) {
    var s = r;
    dt(t.children(i), n), e[i] = { low: s, lim: r++ };
  }
  return dt(t.children(), n), e;
}
function uM(t, e) {
  var r = {};
  function n(i, s) {
    var a = 0, o = 0, l = i.length, u = ic(s);
    return dt(s, function(h, f) {
      var d = fM(t, h), p = d ? t.node(d).order : l;
      (d || h === u) && (dt(s.slice(o, f + 1), function(m) {
        dt(t.predecessors(m), function(_) {
          var v = t.node(_), k = v.order;
          (k < a || p < k) && !(v.dummy && t.node(m).dummy) && Am(r, _, m);
        });
      }), o = f + 1, a = p);
    }), s;
  }
  return yo(e, n), r;
}
function hM(t, e) {
  var r = {};
  function n(s, a, o, l, u) {
    var h;
    dt(Hi(a, o), function(f) {
      h = s[f], t.node(h).dummy && dt(t.predecessors(h), function(d) {
        var p = t.node(d);
        p.dummy && (p.order < l || p.order > u) && Am(r, d, h);
      });
    });
  }
  function i(s, a) {
    var o = -1, l, u = 0;
    return dt(a, function(h, f) {
      if (t.node(h).dummy === "border") {
        var d = t.predecessors(h);
        d.length && (l = t.node(d[0]).order, n(a, u, f, o, l), u = f, o = l);
      }
      n(a, u, a.length, l, s.length);
    }), a;
  }
  return yo(e, i), r;
}
function fM(t, e) {
  if (t.node(e).dummy)
    return w0(t.predecessors(e), function(r) {
      return t.node(r).dummy;
    });
}
function Am(t, e, r) {
  if (e > r) {
    var n = e;
    e = r, r = n;
  }
  var i = t[e];
  i || (t[e] = i = {}), i[r] = !0;
}
function dM(t, e, r) {
  if (e > r) {
    var n = e;
    e = r, r = n;
  }
  return Qt(t[e], r);
}
function pM(t, e, r, n) {
  var i = {}, s = {}, a = {};
  return dt(e, function(o) {
    dt(o, function(l, u) {
      i[l] = l, s[l] = l, a[l] = u;
    });
  }), dt(e, function(o) {
    var l = -1;
    dt(o, function(u) {
      var h = n(u);
      if (h.length) {
        h = mo(h, function(_) {
          return a[_];
        });
        for (var f = (h.length - 1) / 2, d = Math.floor(f), p = Math.ceil(f); d <= p; ++d) {
          var m = h[d];
          s[u] === u && l < a[m] && !dM(r, u, m) && (s[m] = u, s[u] = i[u] = i[m], l = a[m]);
        }
      }
    });
  }), { root: i, align: s };
}
function gM(t, e, r, n, i) {
  var s = {}, a = yM(t, e, r, i), o = i ? "borderLeft" : "borderRight";
  function l(f, d) {
    for (var p = a.nodes(), m = p.pop(), _ = {}; m; )
      _[m] ? f(m) : (_[m] = !0, p.push(m), p = p.concat(d(m))), m = p.pop();
  }
  function u(f) {
    s[f] = a.inEdges(f).reduce(function(d, p) {
      return Math.max(d, s[p.v] + a.edge(p));
    }, 0);
  }
  function h(f) {
    var d = a.outEdges(f).reduce(function(m, _) {
      return Math.min(m, s[_.w] - a.edge(_));
    }, Number.POSITIVE_INFINITY), p = t.node(f);
    d !== Number.POSITIVE_INFINITY && p.borderType !== o && (s[f] = Math.max(s[f], d));
  }
  return l(u, a.predecessors.bind(a)), l(h, a.successors.bind(a)), dt(n, function(f) {
    s[f] = s[r[f]];
  }), s;
}
function yM(t, e, r, n) {
  var i = new Ve(), s = t.graph(), a = vM(s.nodesep, s.edgesep, n);
  return dt(e, function(o) {
    var l;
    dt(o, function(u) {
      var h = r[u];
      if (i.setNode(h), l) {
        var f = r[l], d = i.edge(f, h);
        i.setEdge(f, h, Math.max(a(t, u, l), d || 0));
      }
      l = u;
    });
  }), i;
}
function mM(t, e) {
  return E0(Xn(e), function(r) {
    var n = Number.NEGATIVE_INFINITY, i = Number.POSITIVE_INFINITY;
    return kD(r, function(s, a) {
      var o = kM(t, a) / 2;
      n = Math.max(s + o, n), i = Math.min(s - o, i);
    }), n - i;
  });
}
function bM(t, e) {
  var r = Xn(e), n = Qa(r), i = Wi(r);
  dt(["u", "d"], function(s) {
    dt(["l", "r"], function(a) {
      var o = s + a, l = t[o], u;
      if (l !== e) {
        var h = Xn(l);
        u = a === "l" ? n - Qa(h) : i - Wi(h), u && (t[o] = Kc(l, function(f) {
          return f + u;
        }));
      }
    });
  });
}
function _M(t, e) {
  return Kc(t.ul, function(r, n) {
    if (e)
      return t[e.toLowerCase()][n];
    var i = mo(Oe(t, n));
    return (i[1] + i[2]) / 2;
  });
}
function xM(t) {
  var e = Qc(t), r = Hh(uM(t, e), hM(t, e)), n = {}, i;
  dt(["u", "d"], function(a) {
    i = a === "u" ? e : Xn(e).reverse(), dt(["l", "r"], function(o) {
      o === "r" && (i = Oe(i, function(f) {
        return Xn(f).reverse();
      }));
      var l = (a === "u" ? t.predecessors : t.successors).bind(t), u = pM(t, i, r, l), h = gM(t, i, u.root, u.align, o === "r");
      o === "r" && (h = Kc(h, function(f) {
        return -f;
      })), n[a + o] = h;
    });
  });
  var s = mM(t, n);
  return bM(n, s), _M(n, t.graph().align);
}
function vM(t, e, r) {
  return function(n, i, s) {
    var a = n.node(i), o = n.node(s), l = 0, u;
    if (l += a.width / 2, Qt(a, "labelpos"))
      switch (a.labelpos.toLowerCase()) {
        case "l":
          u = -a.width / 2;
          break;
        case "r":
          u = a.width / 2;
          break;
      }
    if (u && (l += r ? u : -u), u = 0, l += (a.dummy ? e : t) / 2, l += (o.dummy ? e : t) / 2, l += o.width / 2, Qt(o, "labelpos"))
      switch (o.labelpos.toLowerCase()) {
        case "l":
          u = o.width / 2;
          break;
        case "r":
          u = -o.width / 2;
          break;
      }
    return u && (l += r ? u : -u), u = 0, l;
  };
}
function kM(t, e) {
  return t.node(e).width;
}
function wM(t) {
  t = gm(t), TM(t), dt(xM(t), function(e, r) {
    t.node(r).x = e;
  });
}
function TM(t) {
  var e = Qc(t), r = t.graph().ranksep, n = 0;
  dt(e, function(i) {
    var s = Wi(
      Oe(i, function(a) {
        return t.node(a).height;
      })
    );
    dt(i, function(a) {
      t.node(a).y = n + s / 2;
    }), n += s + r;
  });
}
function ta(t, e) {
  var r = e && e.debugTiming ? _I : xI;
  r("layout", function() {
    var n = r("  buildLayoutGraph", function() {
      return RM(t);
    });
    r("  runLayout", function() {
      EM(n, r);
    }), r("  updateInputGraph", function() {
      CM(t, n);
    });
  });
}
function EM(t, e) {
  e("    makeSpaceForEdgeLabels", function() {
    FM(t);
  }), e("    removeSelfEdges", function() {
    GM(t);
  }), e("    acyclic", function() {
    fI(t);
  }), e("    nestingGraph.run", function() {
    zI(t);
  }), e("    rank", function() {
    PI(gm(t));
  }), e("    injectEdgeLabelProxies", function() {
    OM(t);
  }), e("    removeEmptyRanks", function() {
    mI(t);
  }), e("    nestingGraph.cleanup", function() {
    HI(t);
  }), e("    normalizeRanks", function() {
    yI(t);
  }), e("    assignRankMinMax", function() {
    PM(t);
  }), e("    removeEdgeLabelProxies", function() {
    VM(t);
  }), e("    normalize.run", function() {
    CI(t);
  }), e("    parentDummyChains", function() {
    oM(t);
  }), e("    addBorderSegments", function() {
    vI(t);
  }), e("    order", function() {
    sM(t);
  }), e("    insertSelfEdges", function() {
    qM(t);
  }), e("    adjustCoordinateSystem", function() {
    kI(t);
  }), e("    position", function() {
    wM(t);
  }), e("    positionSelfEdges", function() {
    $M(t);
  }), e("    removeBorderNodes", function() {
    HM(t);
  }), e("    normalize.undo", function() {
    AI(t);
  }), e("    fixupEdgeLabelCoords", function() {
    UM(t);
  }), e("    undoCoordinateSystem", function() {
    wI(t);
  }), e("    translateGraph", function() {
    YM(t);
  }), e("    assignNodeIntersects", function() {
    zM(t);
  }), e("    reversePoints", function() {
    WM(t);
  }), e("    acyclic.undo", function() {
    pI(t);
  });
}
function CM(t, e) {
  dt(t.nodes(), function(r) {
    var n = t.node(r), i = e.node(r);
    n && (n.x = i.x, n.y = i.y, e.children(r).length && (n.width = i.width, n.height = i.height));
  }), dt(t.edges(), function(r) {
    var n = t.edge(r), i = e.edge(r);
    n.points = i.points, Qt(i, "x") && (n.x = i.x, n.y = i.y);
  }), t.graph().width = e.graph().width, t.graph().height = e.graph().height;
}
var SM = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], AM = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, LM = ["acyclicer", "ranker", "rankdir", "align"], BM = ["width", "height"], DM = { width: 0, height: 0 }, IM = ["minlen", "weight", "width", "height", "labeloffset"], MM = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
}, NM = ["labelpos"];
function RM(t) {
  var e = new Ve({ multigraph: !0, compound: !0 }), r = qu(t.graph());
  return e.setGraph(
    Hh({}, AM, Gu(r, SM), Ja(r, LM))
  ), dt(t.nodes(), function(n) {
    var i = qu(t.node(n));
    e.setNode(n, ls(Gu(i, BM), DM)), e.setParent(n, t.parent(n));
  }), dt(t.edges(), function(n) {
    var i = qu(t.edge(n));
    e.setEdge(
      n,
      Hh({}, MM, Gu(i, IM), Ja(i, NM))
    );
  }), e;
}
function FM(t) {
  var e = t.graph();
  e.ranksep /= 2, dt(t.edges(), function(r) {
    var n = t.edge(r);
    n.minlen *= 2, n.labelpos.toLowerCase() !== "c" && (e.rankdir === "TB" || e.rankdir === "BT" ? n.width += n.labeloffset : n.height += n.labeloffset);
  });
}
function OM(t) {
  dt(t.edges(), function(e) {
    var r = t.edge(e);
    if (r.width && r.height) {
      var n = t.node(e.v), i = t.node(e.w), s = { rank: (i.rank - n.rank) / 2 + n.rank, e };
      Js(t, "edge-proxy", s, "_ep");
    }
  });
}
function PM(t) {
  var e = 0;
  dt(t.nodes(), function(r) {
    var n = t.node(r);
    n.borderTop && (n.minRank = t.node(n.borderTop).rank, n.maxRank = t.node(n.borderBottom).rank, e = Wi(e, n.maxRank));
  }), t.graph().maxRank = e;
}
function VM(t) {
  dt(t.nodes(), function(e) {
    var r = t.node(e);
    r.dummy === "edge-proxy" && (t.edge(r.e).labelRank = r.rank, t.removeNode(e));
  });
}
function YM(t) {
  var e = Number.POSITIVE_INFINITY, r = 0, n = Number.POSITIVE_INFINITY, i = 0, s = t.graph(), a = s.marginx || 0, o = s.marginy || 0;
  function l(u) {
    var h = u.x, f = u.y, d = u.width, p = u.height;
    e = Math.min(e, h - d / 2), r = Math.max(r, h + d / 2), n = Math.min(n, f - p / 2), i = Math.max(i, f + p / 2);
  }
  dt(t.nodes(), function(u) {
    l(t.node(u));
  }), dt(t.edges(), function(u) {
    var h = t.edge(u);
    Qt(h, "x") && l(h);
  }), e -= a, n -= o, dt(t.nodes(), function(u) {
    var h = t.node(u);
    h.x -= e, h.y -= n;
  }), dt(t.edges(), function(u) {
    var h = t.edge(u);
    dt(h.points, function(f) {
      f.x -= e, f.y -= n;
    }), Qt(h, "x") && (h.x -= e), Qt(h, "y") && (h.y -= n);
  }), s.width = r - e + a, s.height = i - n + o;
}
function zM(t) {
  dt(t.edges(), function(e) {
    var r = t.edge(e), n = t.node(e.v), i = t.node(e.w), s, a;
    r.points ? (s = r.points[0], a = r.points[r.points.length - 1]) : (r.points = [], s = i, a = n), r.points.unshift(i2(n, s)), r.points.push(i2(i, a));
  });
}
function UM(t) {
  dt(t.edges(), function(e) {
    var r = t.edge(e);
    if (Qt(r, "x"))
      switch ((r.labelpos === "l" || r.labelpos === "r") && (r.width -= r.labeloffset), r.labelpos) {
        case "l":
          r.x -= r.width / 2 + r.labeloffset;
          break;
        case "r":
          r.x += r.width / 2 + r.labeloffset;
          break;
      }
  });
}
function WM(t) {
  dt(t.edges(), function(e) {
    var r = t.edge(e);
    r.reversed && r.points.reverse();
  });
}
function HM(t) {
  dt(t.nodes(), function(e) {
    if (t.children(e).length) {
      var r = t.node(e), n = t.node(r.borderTop), i = t.node(r.borderBottom), s = t.node(ic(r.borderLeft)), a = t.node(ic(r.borderRight));
      r.width = Math.abs(a.x - s.x), r.height = Math.abs(i.y - n.y), r.x = s.x + r.width / 2, r.y = n.y + r.height / 2;
    }
  }), dt(t.nodes(), function(e) {
    t.node(e).dummy === "border" && t.removeNode(e);
  });
}
function GM(t) {
  dt(t.edges(), function(e) {
    if (e.v === e.w) {
      var r = t.node(e.v);
      r.selfEdges || (r.selfEdges = []), r.selfEdges.push({ e, label: t.edge(e) }), t.removeEdge(e);
    }
  });
}
function qM(t) {
  var e = Qc(t);
  dt(e, function(r) {
    var n = 0;
    dt(r, function(i, s) {
      var a = t.node(i);
      a.order = s + n, dt(a.selfEdges, function(o) {
        Js(
          t,
          "selfedge",
          {
            width: o.label.width,
            height: o.label.height,
            rank: a.rank,
            order: s + ++n,
            e: o.e,
            label: o.label
          },
          "_se"
        );
      }), delete a.selfEdges;
    });
  });
}
function $M(t) {
  dt(t.nodes(), function(e) {
    var r = t.node(e);
    if (r.dummy === "selfedge") {
      var n = t.node(r.e.v), i = n.x + n.width / 2, s = n.y, a = r.x - i, o = n.height / 2;
      t.setEdge(r.e, r.label), t.removeNode(e), r.label.points = [
        { x: i + 2 * a / 3, y: s - o },
        { x: i + 5 * a / 6, y: s - o },
        { x: i + a, y: s },
        { x: i + 5 * a / 6, y: s + o },
        { x: i + 2 * a / 3, y: s + o }
      ], r.label.x = r.x, r.label.y = r.y;
    }
  });
}
function Gu(t, e) {
  return Kc(Ja(t, e), Number);
}
function qu(t) {
  var e = {};
  return dt(t, function(r, n) {
    e[n.toLowerCase()] = r;
  }), e;
}
let d2 = 0;
const jM = function(t, e, r, n, i) {
  const s = function(x) {
    switch (x) {
      case i.db.relationType.AGGREGATION:
        return "aggregation";
      case i.db.relationType.EXTENSION:
        return "extension";
      case i.db.relationType.COMPOSITION:
        return "composition";
      case i.db.relationType.DEPENDENCY:
        return "dependency";
      case i.db.relationType.LOLLIPOP:
        return "lollipop";
    }
  };
  e.points = e.points.filter((x) => !Number.isNaN(x.y));
  const a = e.points, o = js().x(function(x) {
    return x.x;
  }).y(function(x) {
    return x.y;
  }).curve(Is), l = t.append("path").attr("d", o(a)).attr("id", "edge" + d2).attr("class", "relation");
  let u = "";
  n.arrowMarkerAbsolute && (u = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, u = u.replace(/\(/g, "\\("), u = u.replace(/\)/g, "\\)")), r.relation.lineType == 1 && l.attr("class", "relation dashed-line"), r.relation.lineType == 10 && l.attr("class", "relation dotted-line"), r.relation.type1 !== "none" && l.attr(
    "marker-start",
    "url(" + u + "#" + s(r.relation.type1) + "Start)"
  ), r.relation.type2 !== "none" && l.attr(
    "marker-end",
    "url(" + u + "#" + s(r.relation.type2) + "End)"
  );
  let h, f;
  const d = e.points.length;
  let p = jt.calcLabelPosition(e.points);
  h = p.x, f = p.y;
  let m, _, v, k;
  if (d % 2 !== 0 && d > 1) {
    let x = jt.calcCardinalityPosition(
      r.relation.type1 !== "none",
      e.points,
      e.points[0]
    ), D = jt.calcCardinalityPosition(
      r.relation.type2 !== "none",
      e.points,
      e.points[d - 1]
    );
    B.debug("cardinality_1_point " + JSON.stringify(x)), B.debug("cardinality_2_point " + JSON.stringify(D)), m = x.x, _ = x.y, v = D.x, k = D.y;
  }
  if (r.title !== void 0) {
    const x = t.append("g").attr("class", "classLabel"), D = x.append("text").attr("class", "label").attr("x", h).attr("y", f).attr("fill", "red").attr("text-anchor", "middle").text(r.title);
    window.label = D;
    const F = D.node().getBBox();
    x.insert("rect", ":first-child").attr("class", "box").attr("x", F.x - n.padding / 2).attr("y", F.y - n.padding / 2).attr("width", F.width + n.padding).attr("height", F.height + n.padding);
  }
  B.info("Rendering relation " + JSON.stringify(r)), r.relationTitle1 !== void 0 && r.relationTitle1 !== "none" && t.append("g").attr("class", "cardinality").append("text").attr("class", "type1").attr("x", m).attr("y", _).attr("fill", "black").attr("font-size", "6").text(r.relationTitle1), r.relationTitle2 !== void 0 && r.relationTitle2 !== "none" && t.append("g").attr("class", "cardinality").append("text").attr("class", "type2").attr("x", v).attr("y", k).attr("fill", "black").attr("font-size", "6").text(r.relationTitle2), d2++;
}, XM = function(t, e, r, n) {
  B.debug("Rendering class ", e, r);
  const i = e.id, s = {
    id: i,
    label: e.id,
    width: 0,
    height: 0
  }, a = t.append("g").attr("id", n.db.lookUpDomId(i)).attr("class", "classGroup");
  let o;
  e.link ? o = a.append("svg:a").attr("xlink:href", e.link).attr("target", e.linkTarget).append("text").attr("y", r.textHeight + r.padding).attr("x", 0) : o = a.append("text").attr("y", r.textHeight + r.padding).attr("x", 0);
  let l = !0;
  e.annotations.forEach(function(P) {
    const V = o.append("tspan").text("" + P + "");
    l || V.attr("dy", r.textHeight), l = !1;
  });
  let u = e.id;
  e.type !== void 0 && e.type !== "" && (u += "<" + e.type + ">");
  const h = o.append("tspan").text(u).attr("class", "title");
  l || h.attr("dy", r.textHeight);
  const f = o.node().getBBox().height, d = a.append("line").attr("x1", 0).attr("y1", r.padding + f + r.dividerMargin / 2).attr("y2", r.padding + f + r.dividerMargin / 2), p = a.append("text").attr("x", r.padding).attr("y", f + r.dividerMargin + r.textHeight).attr("fill", "white").attr("class", "classText");
  l = !0, e.members.forEach(function(P) {
    p2(p, P, l, r), l = !1;
  });
  const m = p.node().getBBox(), _ = a.append("line").attr("x1", 0).attr("y1", r.padding + f + r.dividerMargin + m.height).attr("y2", r.padding + f + r.dividerMargin + m.height), v = a.append("text").attr("x", r.padding).attr("y", f + 2 * r.dividerMargin + m.height + r.textHeight).attr("fill", "white").attr("class", "classText");
  l = !0, e.methods.forEach(function(P) {
    p2(v, P, l, r), l = !1;
  });
  const k = a.node().getBBox();
  var x = " ";
  e.cssClasses.length > 0 && (x = x + e.cssClasses.join(" "));
  const F = a.insert("rect", ":first-child").attr("x", 0).attr("y", 0).attr("width", k.width + 2 * r.padding).attr("height", k.height + r.padding + 0.5 * r.dividerMargin).attr("class", x).node().getBBox().width;
  return o.node().childNodes.forEach(function(P) {
    P.setAttribute("x", (F - P.getBBox().width) / 2);
  }), e.tooltip && o.insert("title").text(e.tooltip), d.attr("x2", F), _.attr("x2", F), s.width = F, s.height = k.height + r.padding + 0.5 * r.dividerMargin, s;
}, KM = function(t, e, r, n) {
  B.debug("Rendering note ", e, r);
  const i = e.id, s = {
    id: i,
    text: e.text,
    width: 0,
    height: 0
  }, a = t.append("g").attr("id", i).attr("class", "classGroup");
  let o = a.append("text").attr("y", r.textHeight + r.padding).attr("x", 0);
  const l = JSON.parse(`"${e.text}"`).split(`
`);
  l.forEach(function(d) {
    B.debug(`Adding line: ${d}`), o.append("tspan").text(d).attr("class", "title").attr("dy", r.textHeight);
  });
  const u = a.node().getBBox(), f = a.insert("rect", ":first-child").attr("x", 0).attr("y", 0).attr("width", u.width + 2 * r.padding).attr(
    "height",
    u.height + l.length * r.textHeight + r.padding + 0.5 * r.dividerMargin
  ).node().getBBox().width;
  return o.node().childNodes.forEach(function(d) {
    d.setAttribute("x", (f - d.getBBox().width) / 2);
  }), s.width = f, s.height = u.height + l.length * r.textHeight + r.padding + 0.5 * r.dividerMargin, s;
}, sc = function(t) {
  const e = /^([#+~-])?(\w+)(~\w+~|\[])?\s+(\w+) *([$*])?$/, r = /^([#+|~-])?(\w+) *\( *(.*)\) *([$*])? *(\w*[[\]|~]*\s*\w*~?)$/;
  let n = t.match(e), i = t.match(r);
  return n && !i ? ZM(n) : i ? QM(i) : JM(t);
}, ZM = function(t) {
  let e = "", r = "";
  try {
    let n = t[1] ? t[1].trim() : "", i = t[2] ? t[2].trim() : "", s = t[3] ? ci(t[3].trim()) : "", a = t[4] ? t[4].trim() : "", o = t[5] ? t[5].trim() : "";
    r = n + i + s + " " + a, e = L0(o);
  } catch {
    r = t;
  }
  return {
    displayText: r,
    cssStyle: e
  };
}, QM = function(t) {
  let e = "", r = "";
  try {
    let n = t[1] ? t[1].trim() : "", i = t[2] ? t[2].trim() : "", s = t[3] ? ci(t[3].trim()) : "", a = t[4] ? t[4].trim() : "", o = t[5] ? " : " + ci(t[5]).trim() : "";
    r = n + i + "(" + s + ")" + o, e = L0(a);
  } catch {
    r = t;
  }
  return {
    displayText: r,
    cssStyle: e
  };
}, JM = function(t) {
  let e = "", r = "", n = "", i = t.indexOf("("), s = t.indexOf(")");
  if (i > 1 && s > i && s <= t.length) {
    let a = "", o = "", l = t.substring(0, 1);
    l.match(/\w/) ? o = t.substring(0, i).trim() : (l.match(/[#+~-]/) && (a = l), o = t.substring(1, i).trim());
    const u = t.substring(i + 1, s);
    t.substring(s + 1, 1), r = L0(t.substring(s + 1, s + 2)), e = a + o + "(" + ci(u.trim()) + ")", s < t.length && (n = t.substring(s + 2).trim(), n !== "" && (n = " : " + ci(n), e += n));
  } else
    e = ci(t);
  return {
    displayText: e,
    cssStyle: r
  };
}, p2 = function(t, e, r, n) {
  let i = sc(e);
  const s = t.append("tspan").attr("x", n.padding).text(i.displayText);
  i.cssStyle !== "" && s.attr("style", i.cssStyle), r || s.attr("dy", n.textHeight);
}, L0 = function(t) {
  switch (t) {
    case "*":
      return "font-style:italic;";
    case "$":
      return "text-decoration:underline;";
    default:
      return "";
  }
}, $u = {
  drawClass: XM,
  drawEdge: jM,
  drawNote: KM,
  parseMember: sc
};
let ll = {};
const zo = 20, ha = function(t) {
  const e = Object.entries(ll).find((r) => r[1].label === t);
  if (e)
    return e[0];
}, tN = function(t) {
  t.append("defs").append("marker").attr("id", "extensionStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), t.append("defs").append("marker").attr("id", "extensionEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z"), t.append("defs").append("marker").attr("id", "compositionStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", "compositionEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", "aggregationStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", "aggregationEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", "dependencyStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, eN = function(t, e, r, n) {
  const i = q().class;
  ll = {}, B.info("Rendering diagram " + t);
  const s = q().securityLevel;
  let a;
  s === "sandbox" && (a = _t("#i" + e));
  const o = _t(s === "sandbox" ? a.nodes()[0].contentDocument.body : "body"), l = o.select(`[id='${e}']`);
  tN(l);
  const u = new Ve({
    multigraph: !0
  });
  u.setGraph({
    isMultiGraph: !0
  }), u.setDefaultEdgeLabel(function() {
    return {};
  });
  const h = n.db.getClasses(), f = Object.keys(h);
  for (const x of f) {
    const D = h[x], F = $u.drawClass(l, D, i, n);
    ll[F.id] = F, u.setNode(F.id, F), B.info("Org height: " + F.height);
  }
  n.db.getRelations().forEach(function(x) {
    B.info(
      "tjoho" + ha(x.id1) + ha(x.id2) + JSON.stringify(x)
    ), u.setEdge(
      ha(x.id1),
      ha(x.id2),
      {
        relation: x
      },
      x.title || "DEFAULT"
    );
  }), n.db.getNotes().forEach(function(x) {
    B.debug(`Adding note: ${JSON.stringify(x)}`);
    const D = $u.drawNote(l, x, i, n);
    ll[D.id] = D, u.setNode(D.id, D), x.class && x.class in h && u.setEdge(
      x.id,
      ha(x.class),
      {
        relation: {
          id1: x.id,
          id2: x.class,
          relation: {
            type1: "none",
            type2: "none",
            lineType: 10
          }
        }
      },
      "DEFAULT"
    );
  }), ta(u), u.nodes().forEach(function(x) {
    x !== void 0 && u.node(x) !== void 0 && (B.debug("Node " + x + ": " + JSON.stringify(u.node(x))), o.select("#" + (n.db.lookUpDomId(x) || x)).attr(
      "transform",
      "translate(" + (u.node(x).x - u.node(x).width / 2) + "," + (u.node(x).y - u.node(x).height / 2) + " )"
    ));
  }), u.edges().forEach(function(x) {
    x !== void 0 && u.edge(x) !== void 0 && (B.debug("Edge " + x.v + " -> " + x.w + ": " + JSON.stringify(u.edge(x))), $u.drawEdge(l, u.edge(x), u.edge(x).relation, i, n));
  });
  const m = l.node().getBBox(), _ = m.width + zo * 2, v = m.height + zo * 2;
  cn(l, v, _, i.useMaxWidth);
  const k = `${m.x - zo} ${m.y - zo} ${_} ${v}`;
  B.debug(`viewBox ${k}`), l.attr("viewBox", k);
}, rN = {
  draw: eN
};
function qn(t) {
  var e = {
    options: {
      directed: t.isDirected(),
      multigraph: t.isMultigraph(),
      compound: t.isCompound()
    },
    nodes: nN(t),
    edges: iN(t)
  };
  return De(t.graph()) || (e.value = mB(t.graph())), e;
}
function nN(t) {
  return Oe(t.nodes(), function(e) {
    var r = t.node(e), n = t.parent(e), i = { v: e };
    return De(r) || (i.value = r), De(n) || (i.parent = n), i;
  });
}
function iN(t) {
  return Oe(t.edges(), function(e) {
    var r = t.edge(e), n = { v: e.v, w: e.w };
    return De(e.name) || (n.name = e.name), De(r) || (n.value = r), n;
  });
}
const sN = (t, e, r, n) => {
  e.forEach((i) => {
    gN[i](t, r, n);
  });
}, aN = (t, e, r) => {
  B.trace("Making markers for ", r), t.append("defs").append("marker").attr("id", e + "-extensionStart").attr("class", "marker extension " + e).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), t.append("defs").append("marker").attr("id", e + "-extensionEnd").attr("class", "marker extension " + e).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, oN = (t, e) => {
  t.append("defs").append("marker").attr("id", e + "-compositionStart").attr("class", "marker composition " + e).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", e + "-compositionEnd").attr("class", "marker composition " + e).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, lN = (t, e) => {
  t.append("defs").append("marker").attr("id", e + "-aggregationStart").attr("class", "marker aggregation " + e).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", e + "-aggregationEnd").attr("class", "marker aggregation " + e).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, cN = (t, e) => {
  t.append("defs").append("marker").attr("id", e + "-dependencyStart").attr("class", "marker dependency " + e).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), t.append("defs").append("marker").attr("id", e + "-dependencyEnd").attr("class", "marker dependency " + e).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, uN = (t, e) => {
  t.append("defs").append("marker").attr("id", e + "-lollipopStart").attr("class", "marker lollipop " + e).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "white").attr("cx", 6).attr("cy", 7).attr("r", 6);
}, hN = (t, e) => {
  t.append("marker").attr("id", e + "-pointEnd").attr("class", "marker " + e).attr("viewBox", "0 0 12 20").attr("refX", 10).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", e + "-pointStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 0).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, fN = (t, e) => {
  t.append("marker").attr("id", e + "-circleEnd").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", e + "-circleStart").attr("class", "marker " + e).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, dN = (t, e) => {
  t.append("marker").attr("id", e + "-crossEnd").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), t.append("marker").attr("id", e + "-crossStart").attr("class", "marker cross " + e).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, pN = (t, e) => {
  t.append("defs").append("marker").attr("id", e + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, gN = {
  extension: aN,
  composition: oN,
  aggregation: lN,
  dependency: cN,
  lollipop: uN,
  point: hN,
  circle: fN,
  cross: dN,
  barb: pN
}, yN = sN;
function mN(t, e) {
  e && t.attr("style", e);
}
function bN(t) {
  const e = _t(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), r = e.append("xhtml:div"), n = t.label, i = t.isNode ? "nodeLabel" : "edgeLabel";
  return r.html(
    '<span class="' + i + '" ' + (t.labelStyle ? 'style="' + t.labelStyle + '"' : "") + ">" + n + "</span>"
  ), mN(r, t.labelStyle), r.style("display", "inline-block"), r.style("white-space", "nowrap"), r.attr("xmlns", "http://www.w3.org/1999/xhtml"), e.node();
}
const _N = (t, e, r, n) => {
  let i = t || "";
  if (typeof i == "object" && (i = i[0]), Ke(q().flowchart.htmlLabels)) {
    i = i.replace(/\\n|\n/g, "<br />"), B.info("vertexText" + i);
    const s = {
      isNode: n,
      label: af(i).replace(
        /fa[blrs]?:fa-[\w-]+/g,
        (o) => `<i class='${o.replace(":", " ")}'></i>`
      ),
      labelStyle: e.replace("fill:", "color:")
    };
    return bN(s);
  } else {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "text");
    s.setAttribute("style", e.replace("color:", "fill:"));
    let a = [];
    typeof i == "string" ? a = i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? a = i : a = [];
    for (const o of a) {
      const l = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      l.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), l.setAttribute("dy", "1em"), l.setAttribute("x", "0"), r ? l.setAttribute("class", "title-row") : l.setAttribute("class", "row"), l.textContent = o.trim(), s.appendChild(l);
    }
    return s;
  }
}, xr = _N, cr = (t, e, r, n) => {
  let i;
  r ? i = r : i = "node default";
  const s = t.insert("g").attr("class", i).attr("id", e.domId || e.id), a = s.insert("g").attr("class", "label").attr("style", e.labelStyle);
  let o;
  e.labelText === void 0 ? o = "" : o = typeof e.labelText == "string" ? e.labelText : e.labelText[0];
  const l = a.node().appendChild(
    xr(
      Ur(af(o), q()),
      e.labelStyle,
      !1,
      n
    )
  );
  let u = l.getBBox();
  if (Ke(q().flowchart.htmlLabels)) {
    const f = l.children[0], d = _t(l);
    u = f.getBoundingClientRect(), d.attr("width", u.width), d.attr("height", u.height);
  }
  const h = e.padding / 2;
  return a.attr("transform", "translate(" + -u.width / 2 + ", " + -u.height / 2 + ")"), { shapeSvg: s, bbox: u, halfPadding: h, label: a };
}, Ie = (t, e) => {
  const r = e.node().getBBox();
  t.width = r.width, t.height = r.height;
};
function ri(t, e, r, n) {
  return t.insert("polygon", ":first-child").attr(
    "points",
    n.map(function(i) {
      return i.x + "," + i.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -e / 2 + "," + r / 2 + ")");
}
let ce = {}, Zr = {}, Lm = {};
const xN = () => {
  Zr = {}, Lm = {}, ce = {};
}, ac = (t, e) => (B.trace("In isDecendant", e, " ", t, " = ", Zr[e].includes(t)), !!Zr[e].includes(t)), vN = (t, e) => (B.info("Decendants of ", e, " is ", Zr[e]), B.info("Edge is ", t), t.v === e || t.w === e ? !1 : Zr[e] ? Zr[e].includes(t.v) || ac(t.v, e) || ac(t.w, e) || Zr[e].includes(t.w) : (B.debug("Tilt, ", e, ",not in decendants"), !1)), Bm = (t, e, r, n) => {
  B.warn(
    "Copying children of ",
    t,
    "root",
    n,
    "data",
    e.node(t),
    n
  );
  const i = e.children(t) || [];
  t !== n && i.push(t), B.warn("Copying (nodes) clusterId", t, "nodes", i), i.forEach((s) => {
    if (e.children(s).length > 0)
      Bm(s, e, r, n);
    else {
      const a = e.node(s);
      B.info("cp ", s, " to ", n, " with parent ", t), r.setNode(s, a), n !== e.parent(s) && (B.warn("Setting parent", s, e.parent(s)), r.setParent(s, e.parent(s))), t !== n && s !== t ? (B.debug("Setting parent", s, t), r.setParent(s, t)) : (B.info("In copy ", t, "root", n, "data", e.node(t), n), B.debug(
        "Not Setting parent for node=",
        s,
        "cluster!==rootId",
        t !== n,
        "node!==clusterId",
        s !== t
      ));
      const o = e.edges(s);
      B.debug("Copying Edges", o), o.forEach((l) => {
        B.info("Edge", l);
        const u = e.edge(l.v, l.w, l.name);
        B.info("Edge data", u, n);
        try {
          vN(l, n) ? (B.info("Copying as ", l.v, l.w, u, l.name), r.setEdge(l.v, l.w, u, l.name), B.info("newGraph edges ", r.edges(), r.edge(r.edges()[0]))) : B.info(
            "Skipping copy of edge ",
            l.v,
            "-->",
            l.w,
            " rootId: ",
            n,
            " clusterId:",
            t
          );
        } catch (h) {
          B.error(h);
        }
      });
    }
    B.debug("Removing node", s), e.removeNode(s);
  });
}, Dm = (t, e) => {
  const r = e.children(t);
  let n = [...r];
  for (const i of r)
    Lm[i] = t, n = [...n, ...Dm(i, e)];
  return n;
}, eo = (t, e) => {
  B.trace("Searching", t);
  const r = e.children(t);
  if (B.trace("Searching children of id ", t, r), r.length < 1)
    return B.trace("This is a valid node", t), t;
  for (const n of r) {
    const i = eo(n, e);
    if (i)
      return B.trace("Found replacement for", t, " => ", i), i;
  }
}, Uo = (t) => !ce[t] || !ce[t].externalConnections ? t : ce[t] ? ce[t].id : t, kN = (t, e) => {
  if (!t || e > 10) {
    B.debug("Opting out, no graph ");
    return;
  } else
    B.debug("Opting in, graph ");
  t.nodes().forEach(function(r) {
    t.children(r).length > 0 && (B.warn(
      "Cluster identified",
      r,
      " Replacement id in edges: ",
      eo(r, t)
    ), Zr[r] = Dm(r, t), ce[r] = { id: eo(r, t), clusterData: t.node(r) });
  }), t.nodes().forEach(function(r) {
    const n = t.children(r), i = t.edges();
    n.length > 0 ? (B.debug("Cluster identified", r, Zr), i.forEach((s) => {
      if (s.v !== r && s.w !== r) {
        const a = ac(s.v, r), o = ac(s.w, r);
        a ^ o && (B.warn("Edge: ", s, " leaves cluster ", r), B.warn("Decendants of XXX ", r, ": ", Zr[r]), ce[r].externalConnections = !0);
      }
    })) : B.debug("Not a cluster ", r, Zr);
  }), t.edges().forEach(function(r) {
    const n = t.edge(r);
    B.warn("Edge " + r.v + " -> " + r.w + ": " + JSON.stringify(r)), B.warn("Edge " + r.v + " -> " + r.w + ": " + JSON.stringify(t.edge(r)));
    let i = r.v, s = r.w;
    if (B.warn(
      "Fix XXX",
      ce,
      "ids:",
      r.v,
      r.w,
      "Translating: ",
      ce[r.v],
      " --- ",
      ce[r.w]
    ), ce[r.v] && ce[r.w] && ce[r.v] === ce[r.w]) {
      B.warn("Fixing and trixing link to self - removing XXX", r.v, r.w, r.name), B.warn("Fixing and trixing - removing XXX", r.v, r.w, r.name), i = Uo(r.v), s = Uo(r.w), t.removeEdge(r.v, r.w, r.name);
      const a = r.w + "---" + r.v;
      t.setNode(a, {
        domId: a,
        id: a,
        labelStyle: "",
        labelText: n.label,
        padding: 0,
        shape: "labelRect",
        style: ""
      });
      const o = JSON.parse(JSON.stringify(n)), l = JSON.parse(JSON.stringify(n));
      o.label = "", o.arrowTypeEnd = "none", l.label = "", o.fromCluster = r.v, l.toCluster = r.v, t.setEdge(i, a, o, r.name + "-cyclic-special"), t.setEdge(a, s, l, r.name + "-cyclic-special");
    } else
      (ce[r.v] || ce[r.w]) && (B.warn("Fixing and trixing - removing XXX", r.v, r.w, r.name), i = Uo(r.v), s = Uo(r.w), t.removeEdge(r.v, r.w, r.name), i !== r.v && (n.fromCluster = r.v), s !== r.w && (n.toCluster = r.w), B.warn("Fix Replacing with XXX", i, s, r.name), t.setEdge(i, s, n, r.name));
  }), B.warn("Adjusted Graph", qn(t)), Im(t, 0), B.trace(ce);
}, Im = (t, e) => {
  if (B.warn("extractor - ", e, qn(t), t.children("D")), e > 10) {
    B.error("Bailing out");
    return;
  }
  let r = t.nodes(), n = !1;
  for (const i of r) {
    const s = t.children(i);
    n = n || s.length > 0;
  }
  if (!n) {
    B.debug("Done, no node has children", t.nodes());
    return;
  }
  B.debug("Nodes = ", r, e);
  for (const i of r)
    if (B.debug(
      "Extracting node",
      i,
      ce,
      ce[i] && !ce[i].externalConnections,
      !t.parent(i),
      t.node(i),
      t.children("D"),
      " Depth ",
      e
    ), !ce[i])
      B.debug("Not a cluster", i, e);
    else if (!ce[i].externalConnections && // !graph.parent(node) &&
    t.children(i) && t.children(i).length > 0) {
      B.warn(
        "Cluster without external connections, without a parent and with children",
        i,
        e
      );
      let a = t.graph().rankdir === "TB" ? "LR" : "TB";
      ce[i] && ce[i].clusterData && ce[i].clusterData.dir && (a = ce[i].clusterData.dir, B.warn("Fixing dir", ce[i].clusterData.dir, a));
      const o = new Ve({
        multigraph: !0,
        compound: !0
      }).setGraph({
        rankdir: a,
        // Todo: set proper spacing
        nodesep: 50,
        ranksep: 50,
        marginx: 8,
        marginy: 8
      }).setDefaultEdgeLabel(function() {
        return {};
      });
      B.warn("Old graph before copy", qn(t)), Bm(i, t, o, i), t.setNode(i, {
        clusterNode: !0,
        id: i,
        clusterData: ce[i].clusterData,
        labelText: ce[i].labelText,
        graph: o
      }), B.warn("New graph after copy node: (", i, ")", qn(o)), B.debug("Old graph after copy", qn(t));
    } else
      B.warn(
        "Cluster ** ",
        i,
        " **not meeting the criteria !externalConnections:",
        !ce[i].externalConnections,
        " no parent: ",
        !t.parent(i),
        " children ",
        t.children(i) && t.children(i).length > 0,
        t.children("D"),
        e
      ), B.debug(ce);
  r = t.nodes(), B.warn("New list of nodes", r);
  for (const i of r) {
    const s = t.node(i);
    B.warn(" Now next level", i, s), s.clusterNode && Im(s.graph, e + 1);
  }
}, Mm = (t, e) => {
  if (e.length === 0)
    return [];
  let r = Object.assign(e);
  return e.forEach((n) => {
    const i = t.children(n), s = Mm(t, i);
    r = [...r, ...s];
  }), r;
}, wN = (t) => Mm(t, t.children());
function TN(t, e) {
  return t.intersect(e);
}
function Nm(t, e, r, n) {
  var i = t.x, s = t.y, a = i - n.x, o = s - n.y, l = Math.sqrt(e * e * o * o + r * r * a * a), u = Math.abs(e * r * a / l);
  n.x < i && (u = -u);
  var h = Math.abs(e * r * o / l);
  return n.y < s && (h = -h), { x: i + u, y: s + h };
}
function EN(t, e, r) {
  return Nm(t, e, e, r);
}
function CN(t, e, r, n) {
  var i, s, a, o, l, u, h, f, d, p, m, _, v, k, x;
  if (i = e.y - t.y, a = t.x - e.x, l = e.x * t.y - t.x * e.y, d = i * r.x + a * r.y + l, p = i * n.x + a * n.y + l, !(d !== 0 && p !== 0 && g2(d, p)) && (s = n.y - r.y, o = r.x - n.x, u = n.x * r.y - r.x * n.y, h = s * t.x + o * t.y + u, f = s * e.x + o * e.y + u, !(h !== 0 && f !== 0 && g2(h, f)) && (m = i * o - s * a, m !== 0)))
    return _ = Math.abs(m / 2), v = a * u - o * l, k = v < 0 ? (v - _) / m : (v + _) / m, v = s * l - i * u, x = v < 0 ? (v - _) / m : (v + _) / m, { x: k, y: x };
}
function g2(t, e) {
  return t * e > 0;
}
function SN(t, e, r) {
  var n = t.x, i = t.y, s = [], a = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;
  typeof e.forEach == "function" ? e.forEach(function(m) {
    a = Math.min(a, m.x), o = Math.min(o, m.y);
  }) : (a = Math.min(a, e.x), o = Math.min(o, e.y));
  for (var l = n - t.width / 2 - a, u = i - t.height / 2 - o, h = 0; h < e.length; h++) {
    var f = e[h], d = e[h < e.length - 1 ? h + 1 : 0], p = CN(
      t,
      r,
      { x: l + f.x, y: u + f.y },
      { x: l + d.x, y: u + d.y }
    );
    p && s.push(p);
  }
  return s.length ? (s.length > 1 && s.sort(function(m, _) {
    var v = m.x - r.x, k = m.y - r.y, x = Math.sqrt(v * v + k * k), D = _.x - r.x, F = _.y - r.y, P = Math.sqrt(D * D + F * F);
    return x < P ? -1 : x === P ? 0 : 1;
  }), s[0]) : t;
}
const AN = (t, e) => {
  var r = t.x, n = t.y, i = e.x - r, s = e.y - n, a = t.width / 2, o = t.height / 2, l, u;
  return Math.abs(s) * a > Math.abs(i) * o ? (s < 0 && (o = -o), l = s === 0 ? 0 : o * i / s, u = o) : (i < 0 && (a = -a), l = a, u = i === 0 ? 0 : a * s / i), { x: r + l, y: n + u };
}, bo = AN, Ee = {
  node: TN,
  circle: EN,
  ellipse: Nm,
  polygon: SN,
  rect: bo
}, LN = (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = cr(t, e, "node " + e.classes, !0);
  B.info("Classes = ", e.classes);
  const s = r.insert("rect", ":first-child");
  return s.attr("rx", e.rx).attr("ry", e.ry).attr("x", -n.width / 2 - i).attr("y", -n.height / 2 - i).attr("width", n.width + e.padding).attr("height", n.height + e.padding), Ie(e, s), e.intersect = function(a) {
    return Ee.rect(e, a);
  }, r;
}, BN = LN, y2 = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = n.width + e.padding, s = n.height + e.padding, a = i + s, o = [
    { x: a / 2, y: 0 },
    { x: a, y: -a / 2 },
    { x: a / 2, y: -a },
    { x: 0, y: -a / 2 }
  ];
  B.info("Question main (Circle)");
  const l = ri(r, a, a, o);
  return l.attr("style", e.style), Ie(e, l), e.intersect = function(u) {
    return B.warn("Intersect called"), Ee.polygon(e, o, u);
  }, r;
}, DN = (t, e) => {
  const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), n = 28, i = [
    { x: 0, y: n / 2 },
    { x: n / 2, y: 0 },
    { x: 0, y: -n / 2 },
    { x: -n / 2, y: 0 }
  ];
  return r.insert("polygon", ":first-child").attr(
    "points",
    i.map(function(a) {
      return a.x + "," + a.y;
    }).join(" ")
  ).attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28), e.width = 28, e.height = 28, e.intersect = function(a) {
    return Ee.circle(e, 14, a);
  }, r;
}, IN = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = 4, s = n.height + e.padding, a = s / i, o = n.width + 2 * a + e.padding, l = [
    { x: a, y: 0 },
    { x: o - a, y: 0 },
    { x: o, y: -s / 2 },
    { x: o - a, y: -s },
    { x: a, y: -s },
    { x: 0, y: -s / 2 }
  ], u = ri(r, o, s, l);
  return u.attr("style", e.style), Ie(e, u), e.intersect = function(h) {
    return Ee.polygon(e, l, h);
  }, r;
}, MN = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = n.width + e.padding, s = n.height + e.padding, a = [
    { x: -s / 2, y: 0 },
    { x: i, y: 0 },
    { x: i, y: -s },
    { x: -s / 2, y: -s },
    { x: 0, y: -s / 2 }
  ];
  return ri(r, i, s, a).attr("style", e.style), e.width = i + s, e.height = s, e.intersect = function(l) {
    return Ee.polygon(e, a, l);
  }, r;
}, NN = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = n.width + e.padding, s = n.height + e.padding, a = [
    { x: -2 * s / 6, y: 0 },
    { x: i - s / 6, y: 0 },
    { x: i + 2 * s / 6, y: -s },
    { x: s / 6, y: -s }
  ], o = ri(r, i, s, a);
  return o.attr("style", e.style), Ie(e, o), e.intersect = function(l) {
    return Ee.polygon(e, a, l);
  }, r;
}, RN = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = n.width + e.padding, s = n.height + e.padding, a = [
    { x: 2 * s / 6, y: 0 },
    { x: i + s / 6, y: 0 },
    { x: i - 2 * s / 6, y: -s },
    { x: -s / 6, y: -s }
  ], o = ri(r, i, s, a);
  return o.attr("style", e.style), Ie(e, o), e.intersect = function(l) {
    return Ee.polygon(e, a, l);
  }, r;
}, FN = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = n.width + e.padding, s = n.height + e.padding, a = [
    { x: -2 * s / 6, y: 0 },
    { x: i + 2 * s / 6, y: 0 },
    { x: i - s / 6, y: -s },
    { x: s / 6, y: -s }
  ], o = ri(r, i, s, a);
  return o.attr("style", e.style), Ie(e, o), e.intersect = function(l) {
    return Ee.polygon(e, a, l);
  }, r;
}, ON = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = n.width + e.padding, s = n.height + e.padding, a = [
    { x: s / 6, y: 0 },
    { x: i - s / 6, y: 0 },
    { x: i + 2 * s / 6, y: -s },
    { x: -2 * s / 6, y: -s }
  ], o = ri(r, i, s, a);
  return o.attr("style", e.style), Ie(e, o), e.intersect = function(l) {
    return Ee.polygon(e, a, l);
  }, r;
}, PN = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = n.width + e.padding, s = n.height + e.padding, a = [
    { x: 0, y: 0 },
    { x: i + s / 2, y: 0 },
    { x: i, y: -s / 2 },
    { x: i + s / 2, y: -s },
    { x: 0, y: -s }
  ], o = ri(r, i, s, a);
  return o.attr("style", e.style), Ie(e, o), e.intersect = function(l) {
    return Ee.polygon(e, a, l);
  }, r;
}, VN = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = n.width + e.padding, s = i / 2, a = s / (2.5 + i / 50), o = n.height + a + e.padding, l = "M 0," + a + " a " + s + "," + a + " 0,0,0 " + i + " 0 a " + s + "," + a + " 0,0,0 " + -i + " 0 l 0," + o + " a " + s + "," + a + " 0,0,0 " + i + " 0 l 0," + -o, u = r.attr("label-offset-y", a).insert("path", ":first-child").attr("style", e.style).attr("d", l).attr("transform", "translate(" + -i / 2 + "," + -(o / 2 + a) + ")");
  return Ie(e, u), e.intersect = function(h) {
    const f = Ee.rect(e, h), d = f.x - e.x;
    if (s != 0 && (Math.abs(d) < e.width / 2 || Math.abs(d) == e.width / 2 && Math.abs(f.y - e.y) > e.height / 2 - a)) {
      let p = a * a * (1 - d * d / (s * s));
      p != 0 && (p = Math.sqrt(p)), p = a - p, h.y - e.y > 0 && (p = -p), f.y += p;
    }
    return f;
  }, r;
}, YN = (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = cr(t, e, "node " + e.classes, !0);
  B.trace("Classes = ", e.classes);
  const s = r.insert("rect", ":first-child"), a = n.width + e.padding, o = n.height + e.padding;
  if (s.attr("class", "basic label-container").attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("x", -n.width / 2 - i).attr("y", -n.height / 2 - i).attr("width", a).attr("height", o), e.props) {
    const l = new Set(Object.keys(e.props));
    e.props.borders && (Rm(s, e.props.borders, a, o), l.delete("borders")), l.forEach((u) => {
      B.warn(`Unknown node property ${u}`);
    });
  }
  return Ie(e, s), e.intersect = function(l) {
    return Ee.rect(e, l);
  }, r;
}, zN = (t, e) => {
  const { shapeSvg: r } = cr(t, e, "label", !0);
  B.trace("Classes = ", e.classes);
  const n = r.insert("rect", ":first-child"), i = 0, s = 0;
  if (n.attr("width", i).attr("height", s), r.attr("class", "label edgeLabel"), e.props) {
    const a = new Set(Object.keys(e.props));
    e.props.borders && (Rm(n, e.props.borders, i, s), a.delete("borders")), a.forEach((o) => {
      B.warn(`Unknown node property ${o}`);
    });
  }
  return Ie(e, n), e.intersect = function(a) {
    return Ee.rect(e, a);
  }, r;
};
function Rm(t, e, r, n) {
  const i = [], s = (o) => {
    i.push(o, 0);
  }, a = (o) => {
    i.push(0, o);
  };
  e.includes("t") ? (B.debug("add top border"), s(r)) : a(r), e.includes("r") ? (B.debug("add right border"), s(n)) : a(n), e.includes("b") ? (B.debug("add bottom border"), s(r)) : a(r), e.includes("l") ? (B.debug("add left border"), s(n)) : a(n), t.attr("stroke-dasharray", i.join(" "));
}
const UN = (t, e) => {
  let r;
  e.classes ? r = "node " + e.classes : r = "node default";
  const n = t.insert("g").attr("class", r).attr("id", e.domId || e.id), i = n.insert("rect", ":first-child"), s = n.insert("line"), a = n.insert("g").attr("class", "label"), o = e.labelText.flat ? e.labelText.flat() : e.labelText;
  let l = "";
  typeof o == "object" ? l = o[0] : l = o, B.info("Label text abc79", l, o, typeof o == "object");
  const u = a.node().appendChild(xr(l, e.labelStyle, !0, !0));
  let h = { width: 0, height: 0 };
  if (Ke(q().flowchart.htmlLabels)) {
    const _ = u.children[0], v = _t(u);
    h = _.getBoundingClientRect(), v.attr("width", h.width), v.attr("height", h.height);
  }
  B.info("Text 2", o);
  const f = o.slice(1, o.length);
  let d = u.getBBox();
  const p = a.node().appendChild(
    xr(f.join ? f.join("<br/>") : f, e.labelStyle, !0, !0)
  );
  if (Ke(q().flowchart.htmlLabels)) {
    const _ = p.children[0], v = _t(p);
    h = _.getBoundingClientRect(), v.attr("width", h.width), v.attr("height", h.height);
  }
  const m = e.padding / 2;
  return _t(p).attr(
    "transform",
    "translate( " + // (titleBox.width - bbox.width) / 2 +
    (h.width > d.width ? 0 : (d.width - h.width) / 2) + ", " + (d.height + m + 5) + ")"
  ), _t(u).attr(
    "transform",
    "translate( " + // (titleBox.width - bbox.width) / 2 +
    (h.width < d.width ? 0 : -(d.width - h.width) / 2) + ", " + 0 + ")"
  ), h = a.node().getBBox(), a.attr(
    "transform",
    "translate(" + -h.width / 2 + ", " + (-h.height / 2 - m + 3) + ")"
  ), i.attr("class", "outer title-state").attr("x", -h.width / 2 - m).attr("y", -h.height / 2 - m).attr("width", h.width + e.padding).attr("height", h.height + e.padding), s.attr("class", "divider").attr("x1", -h.width / 2 - m).attr("x2", h.width / 2 + m).attr("y1", -h.height / 2 - m + d.height + m).attr("y2", -h.height / 2 - m + d.height + m), Ie(e, i), e.intersect = function(_) {
    return Ee.rect(e, _);
  }, n;
}, WN = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = n.height + e.padding, s = n.width + i / 4 + e.padding, a = r.insert("rect", ":first-child").attr("style", e.style).attr("rx", i / 2).attr("ry", i / 2).attr("x", -s / 2).attr("y", -i / 2).attr("width", s).attr("height", i);
  return Ie(e, a), e.intersect = function(o) {
    return Ee.rect(e, o);
  }, r;
}, HN = (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = cr(t, e, void 0, !0), s = r.insert("circle", ":first-child");
  return s.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", n.width / 2 + i).attr("width", n.width + e.padding).attr("height", n.height + e.padding), B.info("Circle main"), Ie(e, s), e.intersect = function(a) {
    return B.info("Circle intersect", e, n.width / 2 + i, a), Ee.circle(e, n.width / 2 + i, a);
  }, r;
}, GN = (t, e) => {
  const { shapeSvg: r, bbox: n, halfPadding: i } = cr(t, e, void 0, !0), s = 5, a = r.insert("g", ":first-child"), o = a.insert("circle"), l = a.insert("circle");
  return o.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", n.width / 2 + i + s).attr("width", n.width + e.padding + s * 2).attr("height", n.height + e.padding + s * 2), l.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("r", n.width / 2 + i).attr("width", n.width + e.padding).attr("height", n.height + e.padding), B.info("DoubleCircle main"), Ie(e, o), e.intersect = function(u) {
    return B.info("DoubleCircle intersect", e, n.width / 2 + i + s, u), Ee.circle(e, n.width / 2 + i + s, u);
  }, r;
}, qN = (t, e) => {
  const { shapeSvg: r, bbox: n } = cr(t, e, void 0, !0), i = n.width + e.padding, s = n.height + e.padding, a = [
    { x: 0, y: 0 },
    { x: i, y: 0 },
    { x: i, y: -s },
    { x: 0, y: -s },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: i + 8, y: 0 },
    { x: i + 8, y: -s },
    { x: -8, y: -s },
    { x: -8, y: 0 }
  ], o = ri(r, i, s, a);
  return o.attr("style", e.style), Ie(e, o), e.intersect = function(l) {
    return Ee.polygon(e, a, l);
  }, r;
}, $N = (t, e) => {
  const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), n = r.insert("circle", ":first-child");
  return n.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), Ie(e, n), e.intersect = function(i) {
    return Ee.circle(e, 7, i);
  }, r;
}, m2 = (t, e, r) => {
  const n = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id);
  let i = 70, s = 10;
  r === "LR" && (i = 10, s = 70);
  const a = n.append("rect").attr("x", -1 * i / 2).attr("y", -1 * s / 2).attr("width", i).attr("height", s).attr("class", "fork-join");
  return Ie(e, a), e.height = e.height + e.padding / 2, e.width = e.width + e.padding / 2, e.intersect = function(o) {
    return Ee.rect(e, o);
  }, n;
}, jN = (t, e) => {
  const r = t.insert("g").attr("class", "node default").attr("id", e.domId || e.id), n = r.insert("circle", ":first-child"), i = r.insert("circle", ":first-child");
  return i.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), n.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10), Ie(e, i), e.intersect = function(s) {
    return Ee.circle(e, 7, s);
  }, r;
}, XN = (t, e) => {
  const r = e.padding / 2, n = 4, i = 8;
  let s;
  e.classes ? s = "node " + e.classes : s = "node default";
  const a = t.insert("g").attr("class", s).attr("id", e.domId || e.id), o = a.insert("rect", ":first-child"), l = a.insert("line"), u = a.insert("line");
  let h = 0, f = n;
  const d = a.insert("g").attr("class", "label");
  let p = 0;
  const m = e.classData.annotations && e.classData.annotations[0], _ = e.classData.annotations[0] ? "" + e.classData.annotations[0] + "" : "", v = d.node().appendChild(xr(_, e.labelStyle, !0, !0));
  let k = v.getBBox();
  if (Ke(q().flowchart.htmlLabels)) {
    const O = v.children[0], C = _t(v);
    k = O.getBoundingClientRect(), C.attr("width", k.width), C.attr("height", k.height);
  }
  e.classData.annotations[0] && (f += k.height + n, h += k.width);
  let x = e.classData.id;
  e.classData.type !== void 0 && e.classData.type !== "" && (q().flowchart.htmlLabels ? x += "&lt;" + e.classData.type + "&gt;" : x += "<" + e.classData.type + ">");
  const D = d.node().appendChild(xr(x, e.labelStyle, !0, !0));
  _t(D).attr("class", "classTitle");
  let F = D.getBBox();
  if (Ke(q().flowchart.htmlLabels)) {
    const O = D.children[0], C = _t(D);
    F = O.getBoundingClientRect(), C.attr("width", F.width), C.attr("height", F.height);
  }
  f += F.height + n, F.width > h && (h = F.width);
  const P = [];
  e.classData.members.forEach((O) => {
    const C = sc(O);
    let S = C.displayText;
    q().flowchart.htmlLabels && (S = S.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    const T = d.node().appendChild(
      xr(
        S,
        C.cssStyle ? C.cssStyle : e.labelStyle,
        !0,
        !0
      )
    );
    let b = T.getBBox();
    if (Ke(q().flowchart.htmlLabels)) {
      const w = T.children[0], g = _t(T);
      b = w.getBoundingClientRect(), g.attr("width", b.width), g.attr("height", b.height);
    }
    b.width > h && (h = b.width), f += b.height + n, P.push(T);
  }), f += i;
  const V = [];
  if (e.classData.methods.forEach((O) => {
    const C = sc(O);
    let S = C.displayText;
    q().flowchart.htmlLabels && (S = S.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    const T = d.node().appendChild(
      xr(
        S,
        C.cssStyle ? C.cssStyle : e.labelStyle,
        !0,
        !0
      )
    );
    let b = T.getBBox();
    if (Ke(q().flowchart.htmlLabels)) {
      const w = T.children[0], g = _t(T);
      b = w.getBoundingClientRect(), g.attr("width", b.width), g.attr("height", b.height);
    }
    b.width > h && (h = b.width), f += b.height + n, V.push(T);
  }), f += i, m) {
    let O = (h - k.width) / 2;
    _t(v).attr(
      "transform",
      "translate( " + (-1 * h / 2 + O) + ", " + -1 * f / 2 + ")"
    ), p = k.height + n;
  }
  let R = (h - F.width) / 2;
  return _t(D).attr(
    "transform",
    "translate( " + (-1 * h / 2 + R) + ", " + (-1 * f / 2 + p) + ")"
  ), p += F.height + n, l.attr("class", "divider").attr("x1", -h / 2 - r).attr("x2", h / 2 + r).attr("y1", -f / 2 - r + i + p).attr("y2", -f / 2 - r + i + p), p += i, P.forEach((O) => {
    _t(O).attr(
      "transform",
      "translate( " + -h / 2 + ", " + (-1 * f / 2 + p + i / 2) + ")"
    ), p += F.height + n;
  }), p += i, u.attr("class", "divider").attr("x1", -h / 2 - r).attr("x2", h / 2 + r).attr("y1", -f / 2 - r + i + p).attr("y2", -f / 2 - r + i + p), p += i, V.forEach((O) => {
    _t(O).attr(
      "transform",
      "translate( " + -h / 2 + ", " + (-1 * f / 2 + p) + ")"
    ), p += F.height + n;
  }), o.attr("class", "outer title-state").attr("x", -h / 2 - r).attr("y", -(f / 2) - r).attr("width", h + e.padding).attr("height", f + e.padding), Ie(e, o), e.intersect = function(O) {
    return Ee.rect(e, O);
  }, a;
}, b2 = {
  rhombus: y2,
  question: y2,
  rect: YN,
  labelRect: zN,
  rectWithTitle: UN,
  choice: DN,
  circle: HN,
  doublecircle: GN,
  stadium: WN,
  hexagon: IN,
  rect_left_inv_arrow: MN,
  lean_right: NN,
  lean_left: RN,
  trapezoid: FN,
  inv_trapezoid: ON,
  rect_right_inv_arrow: PN,
  cylinder: VN,
  start: $N,
  end: jN,
  note: BN,
  subroutine: qN,
  fork: m2,
  join: m2,
  class_box: XN
};
let ks = {};
const KN = (t, e, r) => {
  let n, i;
  if (e.link) {
    let s;
    q().securityLevel === "sandbox" ? s = "_top" : e.linkTarget && (s = e.linkTarget || "_blank"), n = t.insert("svg:a").attr("xlink:href", e.link).attr("target", s), i = b2[e.shape](n, e, r);
  } else
    i = b2[e.shape](t, e, r), n = i;
  return e.tooltip && i.attr("title", e.tooltip), e.class && i.attr("class", "node default " + e.class), ks[e.id] = n, e.haveCallback && ks[e.id].attr("class", ks[e.id].attr("class") + " clickable"), n;
}, ZN = (t, e) => {
  ks[e.id] = t;
}, QN = () => {
  ks = {};
}, _2 = (t) => {
  const e = ks[t.id];
  B.trace(
    "Transforming node",
    t.diff,
    t,
    "translate(" + (t.x - t.width / 2 - 5) + ", " + t.width / 2 + ")"
  );
  const r = 8, n = t.diff || 0;
  return t.clusterNode ? e.attr(
    "transform",
    "translate(" + (t.x + n - t.width / 2) + ", " + (t.y - t.height / 2 - r) + ")"
  ) : e.attr("transform", "translate(" + t.x + ", " + t.y + ")"), n;
}, JN = (t, e) => {
  B.trace("Creating subgraph rect for ", e.id, e);
  const r = t.insert("g").attr("class", "cluster" + (e.class ? " " + e.class : "")).attr("id", e.id), n = r.insert("rect", ":first-child"), i = r.insert("g").attr("class", "cluster-label"), s = i.node().appendChild(xr(e.labelText, e.labelStyle, void 0, !0));
  let a = s.getBBox();
  if (Ke(q().flowchart.htmlLabels)) {
    const f = s.children[0], d = _t(s);
    a = f.getBoundingClientRect(), d.attr("width", a.width), d.attr("height", a.height);
  }
  const o = 0 * e.padding, l = o / 2, u = e.width <= a.width + o ? a.width + o : e.width;
  e.width <= a.width + o ? e.diff = (a.width - e.width) / 2 - e.padding / 2 : e.diff = -e.padding / 2, B.trace("Data ", e, JSON.stringify(e)), n.attr("style", e.style).attr("rx", e.rx).attr("ry", e.ry).attr("x", e.x - u / 2).attr("y", e.y - e.height / 2 - l).attr("width", u).attr("height", e.height + o), i.attr(
    "transform",
    // This puts the labal on top of the box instead of inside it
    // 'translate(' + (node.x - bbox.width / 2) + ', ' + (node.y - node.height / 2 - bbox.height) + ')'
    "translate(" + (e.x - a.width / 2) + ", " + (e.y - e.height / 2) + ")"
  );
  const h = n.node().getBBox();
  return e.width = h.width, e.height = h.height, e.intersect = function(f) {
    return bo(e, f);
  }, r;
}, tR = (t, e) => {
  const r = t.insert("g").attr("class", "note-cluster").attr("id", e.id), n = r.insert("rect", ":first-child"), i = 0 * e.padding, s = i / 2;
  n.attr("rx", e.rx).attr("ry", e.ry).attr("x", e.x - e.width / 2 - s).attr("y", e.y - e.height / 2 - s).attr("width", e.width + i).attr("height", e.height + i).attr("fill", "none");
  const a = n.node().getBBox();
  return e.width = a.width, e.height = a.height, e.intersect = function(o) {
    return bo(e, o);
  }, r;
}, eR = (t, e) => {
  const r = t.insert("g").attr("class", e.classes).attr("id", e.id), n = r.insert("rect", ":first-child"), i = r.insert("g").attr("class", "cluster-label"), s = r.append("rect"), a = i.node().appendChild(xr(e.labelText, e.labelStyle, void 0, !0));
  let o = a.getBBox();
  if (Ke(q().flowchart.htmlLabels)) {
    const d = a.children[0], p = _t(a);
    o = d.getBoundingClientRect(), p.attr("width", o.width), p.attr("height", o.height);
  }
  o = a.getBBox();
  const l = 0 * e.padding, u = l / 2, h = e.width <= o.width + e.padding ? o.width + e.padding : e.width;
  e.width <= o.width + e.padding ? e.diff = (o.width + e.padding * 0 - e.width) / 2 : e.diff = -e.padding / 2, n.attr("class", "outer").attr("x", e.x - h / 2 - u).attr("y", e.y - e.height / 2 - u).attr("width", h + l).attr("height", e.height + l), s.attr("class", "inner").attr("x", e.x - h / 2 - u).attr("y", e.y - e.height / 2 - u + o.height - 1).attr("width", h + l).attr("height", e.height + l - o.height - 3), i.attr(
    "transform",
    "translate(" + (e.x - o.width / 2) + ", " + (e.y - e.height / 2 - e.padding / 3 + (Ke(q().flowchart.htmlLabels) ? 5 : 3)) + ")"
  );
  const f = n.node().getBBox();
  return e.height = f.height, e.intersect = function(d) {
    return bo(e, d);
  }, r;
}, rR = (t, e) => {
  const r = t.insert("g").attr("class", e.classes).attr("id", e.id), n = r.insert("rect", ":first-child"), i = 0 * e.padding, s = i / 2;
  n.attr("class", "divider").attr("x", e.x - e.width / 2 - s).attr("y", e.y - e.height / 2).attr("width", e.width + i).attr("height", e.height + i);
  const a = n.node().getBBox();
  return e.width = a.width, e.height = a.height, e.diff = -e.padding / 2, e.intersect = function(o) {
    return bo(e, o);
  }, r;
}, nR = { rect: JN, roundedWithTitle: eR, noteGroup: tR, divider: rR };
let Fm = {};
const iR = (t, e) => {
  B.trace("Inserting cluster");
  const r = e.shape || "rect";
  Fm[e.id] = nR[r](t, e);
}, sR = () => {
  Fm = {};
};
let oc = {}, er = {};
const aR = () => {
  oc = {}, er = {};
}, oR = (t, e) => {
  const r = xr(e.label, e.labelStyle), n = t.insert("g").attr("class", "edgeLabel"), i = n.insert("g").attr("class", "label");
  i.node().appendChild(r);
  let s = r.getBBox();
  if (Ke(q().flowchart.htmlLabels)) {
    const o = r.children[0], l = _t(r);
    s = o.getBoundingClientRect(), l.attr("width", s.width), l.attr("height", s.height);
  }
  i.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), oc[e.id] = n, e.width = s.width, e.height = s.height;
  let a;
  if (e.startLabelLeft) {
    const o = xr(e.startLabelLeft, e.labelStyle), l = t.insert("g").attr("class", "edgeTerminals"), u = l.insert("g").attr("class", "inner");
    a = u.node().appendChild(o);
    const h = o.getBBox();
    u.attr("transform", "translate(" + -h.width / 2 + ", " + -h.height / 2 + ")"), er[e.id] || (er[e.id] = {}), er[e.id].startLeft = l, Wo(a, e.startLabelLeft);
  }
  if (e.startLabelRight) {
    const o = xr(e.startLabelRight, e.labelStyle), l = t.insert("g").attr("class", "edgeTerminals"), u = l.insert("g").attr("class", "inner");
    a = l.node().appendChild(o), u.node().appendChild(o);
    const h = o.getBBox();
    u.attr("transform", "translate(" + -h.width / 2 + ", " + -h.height / 2 + ")"), er[e.id] || (er[e.id] = {}), er[e.id].startRight = l, Wo(a, e.startLabelRight);
  }
  if (e.endLabelLeft) {
    const o = xr(e.endLabelLeft, e.labelStyle), l = t.insert("g").attr("class", "edgeTerminals"), u = l.insert("g").attr("class", "inner");
    a = u.node().appendChild(o);
    const h = o.getBBox();
    u.attr("transform", "translate(" + -h.width / 2 + ", " + -h.height / 2 + ")"), l.node().appendChild(o), er[e.id] || (er[e.id] = {}), er[e.id].endLeft = l, Wo(a, e.endLabelLeft);
  }
  if (e.endLabelRight) {
    const o = xr(e.endLabelRight, e.labelStyle), l = t.insert("g").attr("class", "edgeTerminals"), u = l.insert("g").attr("class", "inner");
    a = u.node().appendChild(o);
    const h = o.getBBox();
    u.attr("transform", "translate(" + -h.width / 2 + ", " + -h.height / 2 + ")"), l.node().appendChild(o), er[e.id] || (er[e.id] = {}), er[e.id].endRight = l, Wo(a, e.endLabelRight);
  }
  return r;
};
function Wo(t, e) {
  q().flowchart.htmlLabels && t && (t.style.width = e.length * 9 + "px", t.style.height = "12px");
}
const lR = (t, e) => {
  B.info("Moving label abc78 ", t.id, t.label, oc[t.id]);
  let r = e.updatedPath ? e.updatedPath : e.originalPath;
  if (t.label) {
    const n = oc[t.id];
    let i = t.x, s = t.y;
    if (r) {
      const a = jt.calcLabelPosition(r);
      B.info(
        "Moving label " + t.label + " from (",
        i,
        ",",
        s,
        ") to (",
        a.x,
        ",",
        a.y,
        ") abc78"
      ), e.updatedPath && (i = a.x, s = a.y);
    }
    n.attr("transform", "translate(" + i + ", " + s + ")");
  }
  if (t.startLabelLeft) {
    const n = er[t.id].startLeft;
    let i = t.x, s = t.y;
    if (r) {
      const a = jt.calcTerminalLabelPosition(t.arrowTypeStart ? 10 : 0, "start_left", r);
      i = a.x, s = a.y;
    }
    n.attr("transform", "translate(" + i + ", " + s + ")");
  }
  if (t.startLabelRight) {
    const n = er[t.id].startRight;
    let i = t.x, s = t.y;
    if (r) {
      const a = jt.calcTerminalLabelPosition(
        t.arrowTypeStart ? 10 : 0,
        "start_right",
        r
      );
      i = a.x, s = a.y;
    }
    n.attr("transform", "translate(" + i + ", " + s + ")");
  }
  if (t.endLabelLeft) {
    const n = er[t.id].endLeft;
    let i = t.x, s = t.y;
    if (r) {
      const a = jt.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_left", r);
      i = a.x, s = a.y;
    }
    n.attr("transform", "translate(" + i + ", " + s + ")");
  }
  if (t.endLabelRight) {
    const n = er[t.id].endRight;
    let i = t.x, s = t.y;
    if (r) {
      const a = jt.calcTerminalLabelPosition(t.arrowTypeEnd ? 10 : 0, "end_right", r);
      i = a.x, s = a.y;
    }
    n.attr("transform", "translate(" + i + ", " + s + ")");
  }
}, cR = (t, e) => {
  const r = t.x, n = t.y, i = Math.abs(e.x - r), s = Math.abs(e.y - n), a = t.width / 2, o = t.height / 2;
  return i >= a || s >= o;
}, uR = (t, e, r) => {
  B.warn(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(e)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${t.x} y:${t.y} w:${t.width} h:${t.height}`);
  const n = t.x, i = t.y, s = Math.abs(n - r.x), a = t.width / 2;
  let o = r.x < e.x ? a - s : a + s;
  const l = t.height / 2, u = Math.abs(e.y - r.y), h = Math.abs(e.x - r.x);
  if (Math.abs(i - e.y) * a > Math.abs(n - e.x) * l) {
    let f = r.y < e.y ? e.y - l - i : i - l - e.y;
    o = h * f / u;
    const d = {
      x: r.x < e.x ? r.x + o : r.x - h + o,
      y: r.y < e.y ? r.y + u - f : r.y - u + f
    };
    return o === 0 && (d.x = e.x, d.y = e.y), h === 0 && (d.x = e.x), u === 0 && (d.y = e.y), B.warn(`abc89 topp/bott calc, Q ${u}, q ${f}, R ${h}, r ${o}`, d), d;
  } else {
    r.x < e.x ? o = e.x - a - n : o = n - a - e.x;
    let f = u * o / h, d = r.x < e.x ? r.x + h - o : r.x - h + o, p = r.y < e.y ? r.y + f : r.y - f;
    return B.warn(`sides calc abc89, Q ${u}, q ${f}, R ${h}, r ${o}`, { _x: d, _y: p }), o === 0 && (d = e.x, p = e.y), h === 0 && (d = e.x), u === 0 && (p = e.y), { x: d, y: p };
  }
}, x2 = (t, e) => {
  B.warn("abc88 cutPathAtIntersect", t, e);
  let r = [], n = t[0], i = !1;
  return t.forEach((s) => {
    if (B.info("abc88 checking point", s, e), !cR(e, s) && !i) {
      const a = uR(e, n, s);
      B.warn("abc88 inside", s, n, a), B.warn("abc88 intersection", a);
      let o = !1;
      r.forEach((l) => {
        o = o || l.x === a.x && l.y === a.y;
      }), r.some((l) => l.x === a.x && l.y === a.y) ? B.warn("abc88 no intersect", a, r) : r.push(a), i = !0;
    } else
      B.warn("abc88 outside", s, n), n = s, i || r.push(s);
  }), B.warn("abc88 returning points", r), r;
}, hR = function(t, e, r, n, i, s) {
  let a = r.points, o = !1;
  const l = s.node(e.v);
  var u = s.node(e.w);
  B.info("abc88 InsertEdge: ", r), u.intersect && l.intersect && (a = a.slice(1, r.points.length - 1), a.unshift(l.intersect(a[0])), B.info(
    "Last point",
    a[a.length - 1],
    u,
    u.intersect(a[a.length - 1])
  ), a.push(u.intersect(a[a.length - 1]))), r.toCluster && (B.info("to cluster abc88", n[r.toCluster]), a = x2(r.points, n[r.toCluster].node), o = !0), r.fromCluster && (B.info("from cluster abc88", n[r.fromCluster]), a = x2(a.reverse(), n[r.fromCluster].node).reverse(), o = !0);
  const h = a.filter((k) => !Number.isNaN(k.y));
  let f;
  i === "graph" || i === "flowchart" ? f = r.curve || Is : f = Is;
  const d = js().x(function(k) {
    return k.x;
  }).y(function(k) {
    return k.y;
  }).curve(f);
  let p;
  switch (r.thickness) {
    case "normal":
      p = "edge-thickness-normal";
      break;
    case "thick":
      p = "edge-thickness-thick";
      break;
    default:
      p = "";
  }
  switch (r.pattern) {
    case "solid":
      p += " edge-pattern-solid";
      break;
    case "dotted":
      p += " edge-pattern-dotted";
      break;
    case "dashed":
      p += " edge-pattern-dashed";
      break;
  }
  const m = t.append("path").attr("d", d(h)).attr("id", r.id).attr("class", " " + p + (r.classes ? " " + r.classes : "")).attr("style", r.style);
  let _ = "";
  switch ((q().flowchart.arrowMarkerAbsolute || q().state.arrowMarkerAbsolute) && (_ = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, _ = _.replace(/\(/g, "\\("), _ = _.replace(/\)/g, "\\)")), B.info("arrowTypeStart", r.arrowTypeStart), B.info("arrowTypeEnd", r.arrowTypeEnd), r.arrowTypeStart) {
    case "arrow_cross":
      m.attr("marker-start", "url(" + _ + "#" + i + "-crossStart)");
      break;
    case "arrow_point":
      m.attr("marker-start", "url(" + _ + "#" + i + "-pointStart)");
      break;
    case "arrow_barb":
      m.attr("marker-start", "url(" + _ + "#" + i + "-barbStart)");
      break;
    case "arrow_circle":
      m.attr("marker-start", "url(" + _ + "#" + i + "-circleStart)");
      break;
    case "aggregation":
      m.attr("marker-start", "url(" + _ + "#" + i + "-aggregationStart)");
      break;
    case "extension":
      m.attr("marker-start", "url(" + _ + "#" + i + "-extensionStart)");
      break;
    case "composition":
      m.attr("marker-start", "url(" + _ + "#" + i + "-compositionStart)");
      break;
    case "dependency":
      m.attr("marker-start", "url(" + _ + "#" + i + "-dependencyStart)");
      break;
    case "lollipop":
      m.attr("marker-start", "url(" + _ + "#" + i + "-lollipopStart)");
      break;
  }
  switch (r.arrowTypeEnd) {
    case "arrow_cross":
      m.attr("marker-end", "url(" + _ + "#" + i + "-crossEnd)");
      break;
    case "arrow_point":
      m.attr("marker-end", "url(" + _ + "#" + i + "-pointEnd)");
      break;
    case "arrow_barb":
      m.attr("marker-end", "url(" + _ + "#" + i + "-barbEnd)");
      break;
    case "arrow_circle":
      m.attr("marker-end", "url(" + _ + "#" + i + "-circleEnd)");
      break;
    case "aggregation":
      m.attr("marker-end", "url(" + _ + "#" + i + "-aggregationEnd)");
      break;
    case "extension":
      m.attr("marker-end", "url(" + _ + "#" + i + "-extensionEnd)");
      break;
    case "composition":
      m.attr("marker-end", "url(" + _ + "#" + i + "-compositionEnd)");
      break;
    case "dependency":
      m.attr("marker-end", "url(" + _ + "#" + i + "-dependencyEnd)");
      break;
    case "lollipop":
      m.attr("marker-end", "url(" + _ + "#" + i + "-lollipopEnd)");
      break;
  }
  let v = {};
  return o && (v.updatedPath = a), v.originalPath = r.points, v;
}, Om = (t, e, r, n) => {
  B.info("Graph in recursive render: XXX", qn(e), n);
  const i = e.graph().rankdir;
  B.trace("Dir in recursive render - dir:", i);
  const s = t.insert("g").attr("class", "root");
  e.nodes() ? B.info("Recursive render XXX", e.nodes()) : B.info("No nodes found for", e), e.edges().length > 0 && B.trace("Recursive edges", e.edge(e.edges()[0]));
  const a = s.insert("g").attr("class", "clusters"), o = s.insert("g").attr("class", "edgePaths"), l = s.insert("g").attr("class", "edgeLabels"), u = s.insert("g").attr("class", "nodes");
  e.nodes().forEach(function(f) {
    const d = e.node(f);
    if (n !== void 0) {
      const p = JSON.parse(JSON.stringify(n.clusterData));
      B.info("Setting data for cluster XXX (", f, ") ", p, n), e.setNode(n.id, p), e.parent(f) || (B.trace("Setting parent", f, n.id), e.setParent(f, n.id, p));
    }
    if (B.info("(Insert) Node XXX" + f + ": " + JSON.stringify(e.node(f))), d && d.clusterNode) {
      B.info("Cluster identified", f, d.width, e.node(f));
      const p = Om(u, d.graph, r, e.node(f)), m = p.elem;
      Ie(d, m), d.diff = p.diff || 0, B.info("Node bounds (abc123)", f, d, d.width, d.x, d.y), ZN(m, d), B.warn("Recursive render complete ", m, d);
    } else
      e.children(f).length > 0 ? (B.info("Cluster - the non recursive path XXX", f, d.id, d, e), B.info(eo(d.id, e)), ce[d.id] = { id: eo(d.id, e), node: d }) : (B.info("Node - the non recursive path", f, d.id, d), KN(u, e.node(f), i));
  }), e.edges().forEach(function(f) {
    const d = e.edge(f.v, f.w, f.name);
    B.info("Edge " + f.v + " -> " + f.w + ": " + JSON.stringify(f)), B.info("Edge " + f.v + " -> " + f.w + ": ", f, " ", JSON.stringify(e.edge(f))), B.info("Fix", ce, "ids:", f.v, f.w, "Translateing: ", ce[f.v], ce[f.w]), oR(l, d);
  }), e.edges().forEach(function(f) {
    B.info("Edge " + f.v + " -> " + f.w + ": " + JSON.stringify(f));
  }), B.info("#############################################"), B.info("###                Layout                 ###"), B.info("#############################################"), B.info(e), ta(e), B.info("Graph after layout:", qn(e));
  let h = 0;
  return wN(e).forEach(function(f) {
    const d = e.node(f);
    B.info("Position " + f + ": " + JSON.stringify(e.node(f))), B.info(
      "Position " + f + ": (" + d.x,
      "," + d.y,
      ") width: ",
      d.width,
      " height: ",
      d.height
    ), d && d.clusterNode ? _2(d) : e.children(f).length > 0 ? (iR(a, d), ce[d.id].node = d) : _2(d);
  }), e.edges().forEach(function(f) {
    const d = e.edge(f);
    B.info("Edge " + f.v + " -> " + f.w + ": " + JSON.stringify(d), d);
    const p = hR(o, f, d, ce, r, e);
    lR(d, p);
  }), e.nodes().forEach(function(f) {
    const d = e.node(f);
    B.info(f, d.type, d.diff), d.type === "group" && (h = d.diff);
  }), { elem: s, diff: h };
}, B0 = (t, e, r, n, i) => {
  yN(t, r, n, i), QN(), aR(), sR(), xN(), B.warn("Graph at first:", qn(e)), kN(e), B.warn("Graph after:", qn(e)), Om(t, e, n);
}, Pm = (t) => Xt.sanitizeText(t, q());
let Vm = {
  dividerMargin: 10,
  padding: 5,
  textHeight: 10
};
const fR = function(t, e, r, n) {
  const i = Object.keys(t);
  B.info("keys:", i), B.info(t), i.forEach(function(s) {
    const a = t[s];
    let o = "";
    a.cssClasses.length > 0 && (o = o + " " + a.cssClasses.join(" "));
    const l = { labelStyle: "" };
    let u = a.text !== void 0 ? a.text : a.id, h = 0, f = "";
    switch (a.type) {
      case "class":
        f = "class_box";
        break;
      default:
        f = "class_box";
    }
    e.setNode(a.id, {
      labelStyle: l.labelStyle,
      shape: f,
      labelText: Pm(u),
      classData: a,
      rx: h,
      ry: h,
      class: o,
      style: l.style,
      id: a.id,
      domId: a.domId,
      tooltip: n.db.getTooltip(a.id) || "",
      haveCallback: a.haveCallback,
      link: a.link,
      width: a.type === "group" ? 500 : void 0,
      type: a.type,
      padding: q().flowchart.padding
    }), B.info("setNode", {
      labelStyle: l.labelStyle,
      shape: f,
      labelText: u,
      rx: h,
      ry: h,
      class: o,
      style: l.style,
      id: a.id,
      width: a.type === "group" ? 500 : void 0,
      type: a.type,
      padding: q().flowchart.padding
    });
  });
}, dR = function(t, e, r, n) {
  B.info(t), t.forEach(function(i, s) {
    const a = i;
    let o = "";
    const l = { labelStyle: "", style: "" };
    let u = a.text, h = 0, f = "note";
    if (e.setNode(a.id, {
      labelStyle: l.labelStyle,
      shape: f,
      labelText: Pm(u),
      noteData: a,
      rx: h,
      ry: h,
      class: o,
      style: l.style,
      id: a.id,
      domId: a.id,
      tooltip: "",
      type: "note",
      padding: q().flowchart.padding
    }), B.info("setNode", {
      labelStyle: l.labelStyle,
      shape: f,
      labelText: u,
      rx: h,
      ry: h,
      style: l.style,
      id: a.id,
      type: "note",
      padding: q().flowchart.padding
    }), !a.class || !(a.class in n))
      return;
    const d = r + s, p = {};
    p.classes = "relation", p.pattern = "dotted", p.id = `edgeNote${d}`, p.arrowhead = "none", B.info(`Note edge: ${JSON.stringify(p)}, ${JSON.stringify(a)}`), p.startLabelRight = "", p.endLabelLeft = "", p.arrowTypeStart = "none", p.arrowTypeEnd = "none";
    let m = "fill:none", _ = "";
    p.style = m, p.labelStyle = _, p.curve = Qr(Vm.curve, Ar), e.setEdge(a.id, a.class, p, d);
  });
}, pR = function(t, e) {
  const r = q().flowchart;
  let n = 0;
  t.forEach(function(i) {
    n++;
    const s = {};
    s.classes = "relation", s.pattern = i.relation.lineType == 1 ? "dashed" : "solid", s.id = "id" + n, i.type === "arrow_open" ? s.arrowhead = "none" : s.arrowhead = "normal", B.info(s, i), s.startLabelRight = i.relationTitle1 === "none" ? "" : i.relationTitle1, s.endLabelLeft = i.relationTitle2 === "none" ? "" : i.relationTitle2, s.arrowTypeStart = v2(i.relation.type1), s.arrowTypeEnd = v2(i.relation.type2);
    let a = "", o = "";
    if (i.style !== void 0) {
      const l = yi(i.style);
      a = l.style, o = l.labelStyle;
    } else
      a = "fill:none";
    s.style = a, s.labelStyle = o, i.interpolate !== void 0 ? s.curve = Qr(i.interpolate, Ar) : t.defaultInterpolate !== void 0 ? s.curve = Qr(t.defaultInterpolate, Ar) : s.curve = Qr(r.curve, Ar), i.text = i.title, i.text === void 0 ? i.style !== void 0 && (s.arrowheadStyle = "fill: #333") : (s.arrowheadStyle = "fill: #333", s.labelpos = "c", q().flowchart.htmlLabels ? (s.labelType = "html", s.label = '<span class="edgeLabel">' + i.text + "</span>") : (s.labelType = "text", s.label = i.text.replace(Xt.lineBreakRegex, `
`), i.style === void 0 && (s.style = s.style || "stroke: #333; stroke-width: 1.5px;fill:none"), s.labelStyle = s.labelStyle.replace("color:", "fill:"))), e.setEdge(i.id1, i.id2, s, n);
  });
}, gR = function(t) {
  Object.keys(t).forEach(function(r) {
    Vm[r] = t[r];
  });
}, yR = function(t, e, r, n) {
  B.info("Drawing class - ", e);
  const i = q().flowchart, s = q().securityLevel;
  B.info("config:", i);
  const a = i.nodeSpacing || 50, o = i.rankSpacing || 50, l = new Ve({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: n.db.getDirection(),
    nodesep: a,
    ranksep: o,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  }), u = n.db.getClasses(), h = n.db.getRelations(), f = n.db.getNotes();
  B.info(h), fR(u, l, e, n), pR(h, l), dR(f, l, h.length + 1, u);
  let d;
  s === "sandbox" && (d = _t("#i" + e));
  const p = _t(s === "sandbox" ? d.nodes()[0].contentDocument.body : "body"), m = p.select(`[id="${e}"]`), _ = p.select("#" + e + " g");
  if (B0(
    _,
    l,
    ["aggregation", "extension", "composition", "dependency", "lollipop"],
    "classDiagram",
    e
  ), jt.insertTitle(m, "classTitleText", i.titleTopMargin, n.db.getDiagramTitle()), Oc(l, m, i.diagramPadding, i.useMaxWidth), !i.htmlLabels) {
    const v = s === "sandbox" ? d.nodes()[0].contentDocument : document, k = v.querySelectorAll('[id="' + e + '"] .edgeLabel .label');
    for (const x of k) {
      const D = x.getBBox(), F = v.createElementNS("http://www.w3.org/2000/svg", "rect");
      F.setAttribute("rx", 0), F.setAttribute("ry", 0), F.setAttribute("width", D.width), F.setAttribute("height", D.height), x.insertBefore(F, x.firstChild);
    }
  }
};
function v2(t) {
  let e;
  switch (t) {
    case 0:
      e = "aggregation";
      break;
    case 1:
      e = "extension";
      break;
    case 2:
      e = "composition";
      break;
    case 3:
      e = "dependency";
      break;
    case 4:
      e = "lollipop";
      break;
    default:
      e = "none";
  }
  return e;
}
const mR = {
  setConf: gR,
  draw: yR
};
var qh = function() {
  var t = function(T, b, w, g) {
    for (w = w || {}, g = T.length; g--; w[T[g]] = b)
      ;
    return w;
  }, e = [1, 2], r = [1, 5], n = [6, 9, 11, 23, 25, 27, 29, 30, 31, 51], i = [1, 17], s = [1, 18], a = [1, 19], o = [1, 20], l = [1, 21], u = [1, 22], h = [1, 25], f = [1, 30], d = [1, 31], p = [1, 32], m = [1, 33], _ = [6, 9, 11, 15, 20, 23, 25, 27, 29, 30, 31, 44, 45, 46, 47, 51], v = [1, 45], k = [30, 31, 48, 49], x = [4, 6, 9, 11, 23, 25, 27, 29, 30, 31, 51], D = [44, 45, 46, 47], F = [22, 37], P = [1, 65], V = [1, 64], R = [22, 37, 39, 41], O = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, ER_DIAGRAM: 4, document: 5, EOF: 6, directive: 7, line: 8, SPACE: 9, statement: 10, NEWLINE: 11, openDirective: 12, typeDirective: 13, closeDirective: 14, ":": 15, argDirective: 16, entityName: 17, relSpec: 18, role: 19, BLOCK_START: 20, attributes: 21, BLOCK_STOP: 22, title: 23, title_value: 24, acc_title: 25, acc_title_value: 26, acc_descr: 27, acc_descr_value: 28, acc_descr_multiline_value: 29, ALPHANUM: 30, ENTITY_NAME: 31, attribute: 32, attributeType: 33, attributeName: 34, attributeKeyTypeList: 35, attributeComment: 36, ATTRIBUTE_WORD: 37, attributeKeyType: 38, COMMA: 39, ATTRIBUTE_KEY: 40, COMMENT: 41, cardinality: 42, relType: 43, ZERO_OR_ONE: 44, ZERO_OR_MORE: 45, ONE_OR_MORE: 46, ONLY_ONE: 47, NON_IDENTIFYING: 48, IDENTIFYING: 49, WORD: 50, open_directive: 51, type_directive: 52, arg_directive: 53, close_directive: 54, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "ER_DIAGRAM", 6: "EOF", 9: "SPACE", 11: "NEWLINE", 15: ":", 20: "BLOCK_START", 22: "BLOCK_STOP", 23: "title", 24: "title_value", 25: "acc_title", 26: "acc_title_value", 27: "acc_descr", 28: "acc_descr_value", 29: "acc_descr_multiline_value", 30: "ALPHANUM", 31: "ENTITY_NAME", 37: "ATTRIBUTE_WORD", 39: "COMMA", 40: "ATTRIBUTE_KEY", 41: "COMMENT", 44: "ZERO_OR_ONE", 45: "ZERO_OR_MORE", 46: "ONE_OR_MORE", 47: "ONLY_ONE", 48: "NON_IDENTIFYING", 49: "IDENTIFYING", 50: "WORD", 51: "open_directive", 52: "type_directive", 53: "arg_directive", 54: "close_directive" },
    productions_: [0, [3, 3], [3, 2], [5, 0], [5, 2], [8, 2], [8, 1], [8, 1], [8, 1], [7, 4], [7, 6], [10, 1], [10, 5], [10, 4], [10, 3], [10, 1], [10, 2], [10, 2], [10, 2], [10, 1], [17, 1], [17, 1], [21, 1], [21, 2], [32, 2], [32, 3], [32, 3], [32, 4], [33, 1], [34, 1], [35, 1], [35, 3], [38, 1], [36, 1], [18, 3], [42, 1], [42, 1], [42, 1], [42, 1], [43, 1], [43, 1], [19, 1], [19, 1], [19, 1], [12, 1], [13, 1], [16, 1], [14, 1]],
    performAction: function(b, w, g, M, y, N, it) {
      var Y = N.length - 1;
      switch (y) {
        case 1:
          break;
        case 3:
          this.$ = [];
          break;
        case 4:
          N[Y - 1].push(N[Y]), this.$ = N[Y - 1];
          break;
        case 5:
        case 6:
          this.$ = N[Y];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 12:
          M.addEntity(N[Y - 4]), M.addEntity(N[Y - 2]), M.addRelationship(N[Y - 4], N[Y], N[Y - 2], N[Y - 3]);
          break;
        case 13:
          M.addEntity(N[Y - 3]), M.addAttributes(N[Y - 3], N[Y - 1]);
          break;
        case 14:
          M.addEntity(N[Y - 2]);
          break;
        case 15:
          M.addEntity(N[Y]);
          break;
        case 16:
        case 17:
          this.$ = N[Y].trim(), M.setAccTitle(this.$);
          break;
        case 18:
        case 19:
          this.$ = N[Y].trim(), M.setAccDescription(this.$);
          break;
        case 20:
        case 43:
          this.$ = N[Y];
          break;
        case 21:
        case 41:
        case 42:
          this.$ = N[Y].replace(/"/g, "");
          break;
        case 22:
        case 30:
          this.$ = [N[Y]];
          break;
        case 23:
          N[Y].push(N[Y - 1]), this.$ = N[Y];
          break;
        case 24:
          this.$ = { attributeType: N[Y - 1], attributeName: N[Y] };
          break;
        case 25:
          this.$ = { attributeType: N[Y - 2], attributeName: N[Y - 1], attributeKeyTypeList: N[Y] };
          break;
        case 26:
          this.$ = { attributeType: N[Y - 2], attributeName: N[Y - 1], attributeComment: N[Y] };
          break;
        case 27:
          this.$ = { attributeType: N[Y - 3], attributeName: N[Y - 2], attributeKeyTypeList: N[Y - 1], attributeComment: N[Y] };
          break;
        case 28:
        case 29:
        case 32:
          this.$ = N[Y];
          break;
        case 31:
          N[Y - 2].push(N[Y]), this.$ = N[Y - 2];
          break;
        case 33:
          this.$ = N[Y].replace(/"/g, "");
          break;
        case 34:
          this.$ = { cardA: N[Y], relType: N[Y - 1], cardB: N[Y - 2] };
          break;
        case 35:
          this.$ = M.Cardinality.ZERO_OR_ONE;
          break;
        case 36:
          this.$ = M.Cardinality.ZERO_OR_MORE;
          break;
        case 37:
          this.$ = M.Cardinality.ONE_OR_MORE;
          break;
        case 38:
          this.$ = M.Cardinality.ONLY_ONE;
          break;
        case 39:
          this.$ = M.Identification.NON_IDENTIFYING;
          break;
        case 40:
          this.$ = M.Identification.IDENTIFYING;
          break;
        case 44:
          M.parseDirective("%%{", "open_directive");
          break;
        case 45:
          M.parseDirective(N[Y], "type_directive");
          break;
        case 46:
          N[Y] = N[Y].trim().replace(/'/g, '"'), M.parseDirective(N[Y], "arg_directive");
          break;
        case 47:
          M.parseDirective("}%%", "close_directive", "er");
          break;
      }
    },
    table: [{ 3: 1, 4: e, 7: 3, 12: 4, 51: r }, { 1: [3] }, t(n, [2, 3], { 5: 6 }), { 3: 7, 4: e, 7: 3, 12: 4, 51: r }, { 13: 8, 52: [1, 9] }, { 52: [2, 44] }, { 6: [1, 10], 7: 15, 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: 4, 17: 16, 23: i, 25: s, 27: a, 29: o, 30: l, 31: u, 51: r }, { 1: [2, 2] }, { 14: 23, 15: [1, 24], 54: h }, t([15, 54], [2, 45]), t(n, [2, 8], { 1: [2, 1] }), t(n, [2, 4]), { 7: 15, 10: 26, 12: 4, 17: 16, 23: i, 25: s, 27: a, 29: o, 30: l, 31: u, 51: r }, t(n, [2, 6]), t(n, [2, 7]), t(n, [2, 11]), t(n, [2, 15], { 18: 27, 42: 29, 20: [1, 28], 44: f, 45: d, 46: p, 47: m }), { 24: [1, 34] }, { 26: [1, 35] }, { 28: [1, 36] }, t(n, [2, 19]), t(_, [2, 20]), t(_, [2, 21]), { 11: [1, 37] }, { 16: 38, 53: [1, 39] }, { 11: [2, 47] }, t(n, [2, 5]), { 17: 40, 30: l, 31: u }, { 21: 41, 22: [1, 42], 32: 43, 33: 44, 37: v }, { 43: 46, 48: [1, 47], 49: [1, 48] }, t(k, [2, 35]), t(k, [2, 36]), t(k, [2, 37]), t(k, [2, 38]), t(n, [2, 16]), t(n, [2, 17]), t(n, [2, 18]), t(x, [2, 9]), { 14: 49, 54: h }, { 54: [2, 46] }, { 15: [1, 50] }, { 22: [1, 51] }, t(n, [2, 14]), { 21: 52, 22: [2, 22], 32: 43, 33: 44, 37: v }, { 34: 53, 37: [1, 54] }, { 37: [2, 28] }, { 42: 55, 44: f, 45: d, 46: p, 47: m }, t(D, [2, 39]), t(D, [2, 40]), { 11: [1, 56] }, { 19: 57, 30: [1, 60], 31: [1, 59], 50: [1, 58] }, t(n, [2, 13]), { 22: [2, 23] }, t(F, [2, 24], { 35: 61, 36: 62, 38: 63, 40: P, 41: V }), t([22, 37, 40, 41], [2, 29]), t([30, 31], [2, 34]), t(x, [2, 10]), t(n, [2, 12]), t(n, [2, 41]), t(n, [2, 42]), t(n, [2, 43]), t(F, [2, 25], { 36: 66, 39: [1, 67], 41: V }), t(F, [2, 26]), t(R, [2, 30]), t(F, [2, 33]), t(R, [2, 32]), t(F, [2, 27]), { 38: 68, 40: P }, t(R, [2, 31])],
    defaultActions: { 5: [2, 44], 7: [2, 2], 25: [2, 47], 39: [2, 46], 45: [2, 28], 52: [2, 23] },
    parseError: function(b, w) {
      if (w.recoverable)
        this.trace(b);
      else {
        var g = new Error(b);
        throw g.hash = w, g;
      }
    },
    parse: function(b) {
      var w = this, g = [0], M = [], y = [null], N = [], it = this.table, Y = "", Z = 0, J = 0, X = 2, tt = 1, st = N.slice.call(arguments, 1), lt = Object.create(this.lexer), U = { yy: {} };
      for (var Tt in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, Tt) && (U.yy[Tt] = this.yy[Tt]);
      lt.setInput(b, U.yy), U.yy.lexer = lt, U.yy.parser = this, typeof lt.yylloc > "u" && (lt.yylloc = {});
      var $ = lt.yylloc;
      N.push($);
      var j = lt.options && lt.options.ranges;
      typeof U.yy.parseError == "function" ? this.parseError = U.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function W() {
        var vt;
        return vt = M.pop() || lt.lex() || tt, typeof vt != "number" && (vt instanceof Array && (M = vt, vt = M.pop()), vt = w.symbols_[vt] || vt), vt;
      }
      for (var z, A, I, G, L = {}, at, E, Dt, et; ; ) {
        if (A = g[g.length - 1], this.defaultActions[A] ? I = this.defaultActions[A] : ((z === null || typeof z > "u") && (z = W()), I = it[A] && it[A][z]), typeof I > "u" || !I.length || !I[0]) {
          var Et = "";
          et = [];
          for (at in it[A])
            this.terminals_[at] && at > X && et.push("'" + this.terminals_[at] + "'");
          lt.showPosition ? Et = "Parse error on line " + (Z + 1) + `:
` + lt.showPosition() + `
Expecting ` + et.join(", ") + ", got '" + (this.terminals_[z] || z) + "'" : Et = "Parse error on line " + (Z + 1) + ": Unexpected " + (z == tt ? "end of input" : "'" + (this.terminals_[z] || z) + "'"), this.parseError(Et, {
            text: lt.match,
            token: this.terminals_[z] || z,
            line: lt.yylineno,
            loc: $,
            expected: et
          });
        }
        if (I[0] instanceof Array && I.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + A + ", token: " + z);
        switch (I[0]) {
          case 1:
            g.push(z), y.push(lt.yytext), N.push(lt.yylloc), g.push(I[1]), z = null, J = lt.yyleng, Y = lt.yytext, Z = lt.yylineno, $ = lt.yylloc;
            break;
          case 2:
            if (E = this.productions_[I[1]][1], L.$ = y[y.length - E], L._$ = {
              first_line: N[N.length - (E || 1)].first_line,
              last_line: N[N.length - 1].last_line,
              first_column: N[N.length - (E || 1)].first_column,
              last_column: N[N.length - 1].last_column
            }, j && (L._$.range = [
              N[N.length - (E || 1)].range[0],
              N[N.length - 1].range[1]
            ]), G = this.performAction.apply(L, [
              Y,
              J,
              Z,
              U.yy,
              I[1],
              y,
              N
            ].concat(st)), typeof G < "u")
              return G;
            E && (g = g.slice(0, -1 * E * 2), y = y.slice(0, -1 * E), N = N.slice(0, -1 * E)), g.push(this.productions_[I[1]][0]), y.push(L.$), N.push(L._$), Dt = it[g[g.length - 2]][g[g.length - 1]], g.push(Dt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, C = function() {
    var T = {
      EOF: 1,
      parseError: function(w, g) {
        if (this.yy.parser)
          this.yy.parser.parseError(w, g);
        else
          throw new Error(w);
      },
      // resets the lexer, sets new input
      setInput: function(b, w) {
        return this.yy = w || this.yy || {}, this._input = b, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var b = this._input[0];
        this.yytext += b, this.yyleng++, this.offset++, this.match += b, this.matched += b;
        var w = b.match(/(?:\r\n?|\n).*/g);
        return w ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), b;
      },
      // unshifts one char (or a string) into the input
      unput: function(b) {
        var w = b.length, g = b.split(/(?:\r\n?|\n)/g);
        this._input = b + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - w), this.offset -= w;
        var M = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), g.length - 1 && (this.yylineno -= g.length - 1);
        var y = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: g ? (g.length === M.length ? this.yylloc.first_column : 0) + M[M.length - g.length].length - g[0].length : this.yylloc.first_column - w
        }, this.options.ranges && (this.yylloc.range = [y[0], y[0] + this.yyleng - w]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(b) {
        this.unput(this.match.slice(b));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var b = this.matched.substr(0, this.matched.length - this.match.length);
        return (b.length > 20 ? "..." : "") + b.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var b = this.match;
        return b.length < 20 && (b += this._input.substr(0, 20 - b.length)), (b.substr(0, 20) + (b.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var b = this.pastInput(), w = new Array(b.length + 1).join("-");
        return b + this.upcomingInput() + `
` + w + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(b, w) {
        var g, M, y;
        if (this.options.backtrack_lexer && (y = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (y.yylloc.range = this.yylloc.range.slice(0))), M = b[0].match(/(?:\r\n?|\n).*/g), M && (this.yylineno += M.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: M ? M[M.length - 1].length - M[M.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + b[0].length
        }, this.yytext += b[0], this.match += b[0], this.matches = b, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(b[0].length), this.matched += b[0], g = this.performAction.call(this, this.yy, this, w, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), g)
          return g;
        if (this._backtrack) {
          for (var N in y)
            this[N] = y[N];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var b, w, g, M;
        this._more || (this.yytext = "", this.match = "");
        for (var y = this._currentRules(), N = 0; N < y.length; N++)
          if (g = this._input.match(this.rules[y[N]]), g && (!w || g[0].length > w[0].length)) {
            if (w = g, M = N, this.options.backtrack_lexer) {
              if (b = this.test_match(g, y[N]), b !== !1)
                return b;
              if (this._backtrack) {
                w = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return w ? (b = this.test_match(w, y[M]), b !== !1 ? b : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var w = this.next();
        return w || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(w) {
        this.conditionStack.push(w);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var w = this.conditionStack.length - 1;
        return w > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(w) {
        return w = this.conditionStack.length - 1 - Math.abs(w || 0), w >= 0 ? this.conditionStack[w] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(w) {
        this.begin(w);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(w, g, M, y) {
        switch (M) {
          case 0:
            return this.begin("acc_title"), 25;
          case 1:
            return this.popState(), "acc_title_value";
          case 2:
            return this.begin("acc_descr"), 27;
          case 3:
            return this.popState(), "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            return this.begin("open_directive"), 51;
          case 8:
            return this.begin("type_directive"), 52;
          case 9:
            return this.popState(), this.begin("arg_directive"), 15;
          case 10:
            return this.popState(), this.popState(), 54;
          case 11:
            return 53;
          case 12:
            break;
          case 13:
            break;
          case 14:
            return 11;
          case 15:
            break;
          case 16:
            return 9;
          case 17:
            return 31;
          case 18:
            return 50;
          case 19:
            return 4;
          case 20:
            return this.begin("block"), 20;
          case 21:
            return 39;
          case 22:
            break;
          case 23:
            return 40;
          case 24:
            return 37;
          case 25:
            return 37;
          case 26:
            return 41;
          case 27:
            break;
          case 28:
            return this.popState(), 22;
          case 29:
            return g.yytext[0];
          case 30:
            return 44;
          case 31:
            return 46;
          case 32:
            return 46;
          case 33:
            return 46;
          case 34:
            return 44;
          case 35:
            return 44;
          case 36:
            return 45;
          case 37:
            return 45;
          case 38:
            return 45;
          case 39:
            return 45;
          case 40:
            return 45;
          case 41:
            return 46;
          case 42:
            return 45;
          case 43:
            return 46;
          case 44:
            return 47;
          case 45:
            return 47;
          case 46:
            return 47;
          case 47:
            return 47;
          case 48:
            return 44;
          case 49:
            return 45;
          case 50:
            return 46;
          case 51:
            return 48;
          case 52:
            return 49;
          case 53:
            return 49;
          case 54:
            return 48;
          case 55:
            return 48;
          case 56:
            return 48;
          case 57:
            return 30;
          case 58:
            return g.yytext[0];
          case 59:
            return 6;
        }
      },
      rules: [/^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:[\s]+)/i, /^(?:"[^"%\r\n\v\b\\]+")/i, /^(?:"[^"]*")/i, /^(?:erDiagram\b)/i, /^(?:\{)/i, /^(?:,)/i, /^(?:\s+)/i, /^(?:\b((?:PK)|(?:FK)|(?:UK))\b)/i, /^(?:(.*?)[~](.*?)*[~])/i, /^(?:[A-Za-z_][A-Za-z0-9\-_\[\]\(\)]*)/i, /^(?:"[^"]*")/i, /^(?:[\n]+)/i, /^(?:\})/i, /^(?:.)/i, /^(?:one or zero\b)/i, /^(?:one or more\b)/i, /^(?:one or many\b)/i, /^(?:1\+)/i, /^(?:\|o\b)/i, /^(?:zero or one\b)/i, /^(?:zero or more\b)/i, /^(?:zero or many\b)/i, /^(?:0\+)/i, /^(?:\}o\b)/i, /^(?:many\(0\))/i, /^(?:many\(1\))/i, /^(?:many\b)/i, /^(?:\}\|)/i, /^(?:one\b)/i, /^(?:only one\b)/i, /^(?:1\b)/i, /^(?:\|\|)/i, /^(?:o\|)/i, /^(?:o\{)/i, /^(?:\|\{)/i, /^(?:\.\.)/i, /^(?:--)/i, /^(?:to\b)/i, /^(?:optionally to\b)/i, /^(?:\.-)/i, /^(?:-\.)/i, /^(?:[A-Za-z][A-Za-z0-9\-_]*)/i, /^(?:.)/i, /^(?:$)/i],
      conditions: { acc_descr_multiline: { rules: [5, 6], inclusive: !1 }, acc_descr: { rules: [3], inclusive: !1 }, acc_title: { rules: [1], inclusive: !1 }, open_directive: { rules: [8], inclusive: !1 }, type_directive: { rules: [9, 10], inclusive: !1 }, arg_directive: { rules: [10, 11], inclusive: !1 }, block: { rules: [21, 22, 23, 24, 25, 26, 27, 28, 29], inclusive: !1 }, INITIAL: { rules: [0, 2, 4, 7, 12, 13, 14, 15, 16, 17, 18, 19, 20, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59], inclusive: !0 } }
    };
    return T;
  }();
  O.lexer = C;
  function S() {
    this.yy = {};
  }
  return S.prototype = O, O.Parser = S, new S();
}();
qh.parser = qh;
const bR = qh, _R = (t) => t.match(/^\s*erDiagram/) !== null;
let Da = {}, D0 = [];
const xR = {
  ZERO_OR_ONE: "ZERO_OR_ONE",
  ZERO_OR_MORE: "ZERO_OR_MORE",
  ONE_OR_MORE: "ONE_OR_MORE",
  ONLY_ONE: "ONLY_ONE"
}, vR = {
  NON_IDENTIFYING: "NON_IDENTIFYING",
  IDENTIFYING: "IDENTIFYING"
}, kR = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
}, Ym = function(t) {
  return Da[t] === void 0 && (Da[t] = { attributes: [] }, B.info("Added new entity :", t)), Da[t];
}, wR = () => Da, TR = function(t, e) {
  let r = Ym(t), n;
  for (n = e.length - 1; n >= 0; n--)
    r.attributes.push(e[n]), B.debug("Added attribute ", e[n].attributeName);
}, ER = function(t, e, r, n) {
  let i = {
    entityA: t,
    roleA: e,
    entityB: r,
    relSpec: n
  };
  D0.push(i), B.debug("Added new relationship :", i);
}, CR = () => D0, SR = function() {
  Da = {}, D0 = [], Br();
}, AR = {
  Cardinality: xR,
  Identification: vR,
  parseDirective: kR,
  getConfig: () => q().er,
  addEntity: Ym,
  addAttributes: TR,
  getEntities: wR,
  addRelationship: ER,
  getRelationships: CR,
  clear: SR,
  setAccTitle: Tr,
  getAccTitle: Dr,
  setAccDescription: Ir,
  getAccDescription: Mr,
  setDiagramTitle: un,
  getDiagramTitle: hn
}, Fn = {
  ONLY_ONE_START: "ONLY_ONE_START",
  ONLY_ONE_END: "ONLY_ONE_END",
  ZERO_OR_ONE_START: "ZERO_OR_ONE_START",
  ZERO_OR_ONE_END: "ZERO_OR_ONE_END",
  ONE_OR_MORE_START: "ONE_OR_MORE_START",
  ONE_OR_MORE_END: "ONE_OR_MORE_END",
  ZERO_OR_MORE_START: "ZERO_OR_MORE_START",
  ZERO_OR_MORE_END: "ZERO_OR_MORE_END"
}, LR = function(t, e) {
  let r;
  t.append("defs").append("marker").attr("id", Fn.ONLY_ONE_START).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("stroke", e.stroke).attr("fill", "none").attr("d", "M9,0 L9,18 M15,0 L15,18"), t.append("defs").append("marker").attr("id", Fn.ONLY_ONE_END).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("stroke", e.stroke).attr("fill", "none").attr("d", "M3,0 L3,18 M9,0 L9,18"), r = t.append("defs").append("marker").attr("id", Fn.ZERO_OR_ONE_START).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto"), r.append("circle").attr("stroke", e.stroke).attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6), r.append("path").attr("stroke", e.stroke).attr("fill", "none").attr("d", "M9,0 L9,18"), r = t.append("defs").append("marker").attr("id", Fn.ZERO_OR_ONE_END).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto"), r.append("circle").attr("stroke", e.stroke).attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6), r.append("path").attr("stroke", e.stroke).attr("fill", "none").attr("d", "M21,0 L21,18"), t.append("defs").append("marker").attr("id", Fn.ONE_OR_MORE_START).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("stroke", e.stroke).attr("fill", "none").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"), t.append("defs").append("marker").attr("id", Fn.ONE_OR_MORE_END).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("stroke", e.stroke).attr("fill", "none").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18"), r = t.append("defs").append("marker").attr("id", Fn.ZERO_OR_MORE_START).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto"), r.append("circle").attr("stroke", e.stroke).attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6), r.append("path").attr("stroke", e.stroke).attr("fill", "none").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18"), r = t.append("defs").append("marker").attr("id", Fn.ZERO_OR_MORE_END).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto"), r.append("circle").attr("stroke", e.stroke).attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6), r.append("path").attr("stroke", e.stroke).attr("fill", "none").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
}, On = {
  ERMarkers: Fn,
  insertMarkers: LR
}, BR = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function DR(t) {
  return typeof t == "string" && BR.test(t);
}
const tr = [];
for (let t = 0; t < 256; ++t)
  tr.push((t + 256).toString(16).slice(1));
function IR(t, e = 0) {
  return (tr[t[e + 0]] + tr[t[e + 1]] + tr[t[e + 2]] + tr[t[e + 3]] + "-" + tr[t[e + 4]] + tr[t[e + 5]] + "-" + tr[t[e + 6]] + tr[t[e + 7]] + "-" + tr[t[e + 8]] + tr[t[e + 9]] + "-" + tr[t[e + 10]] + tr[t[e + 11]] + tr[t[e + 12]] + tr[t[e + 13]] + tr[t[e + 14]] + tr[t[e + 15]]).toLowerCase();
}
function MR(t) {
  if (!DR(t))
    throw TypeError("Invalid UUID");
  let e;
  const r = new Uint8Array(16);
  return r[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24, r[1] = e >>> 16 & 255, r[2] = e >>> 8 & 255, r[3] = e & 255, r[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8, r[5] = e & 255, r[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8, r[7] = e & 255, r[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8, r[9] = e & 255, r[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, r[11] = e / 4294967296 & 255, r[12] = e >>> 24 & 255, r[13] = e >>> 16 & 255, r[14] = e >>> 8 & 255, r[15] = e & 255, r;
}
function NR(t) {
  t = unescape(encodeURIComponent(t));
  const e = [];
  for (let r = 0; r < t.length; ++r)
    e.push(t.charCodeAt(r));
  return e;
}
const RR = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", FR = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function OR(t, e, r) {
  function n(i, s, a, o) {
    var l;
    if (typeof i == "string" && (i = NR(i)), typeof s == "string" && (s = MR(s)), ((l = s) === null || l === void 0 ? void 0 : l.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let u = new Uint8Array(16 + i.length);
    if (u.set(s), u.set(i, s.length), u = r(u), u[6] = u[6] & 15 | e, u[8] = u[8] & 63 | 128, a) {
      o = o || 0;
      for (let h = 0; h < 16; ++h)
        a[o + h] = u[h];
      return a;
    }
    return IR(u);
  }
  try {
    n.name = t;
  } catch {
  }
  return n.DNS = RR, n.URL = FR, n;
}
function PR(t, e, r, n) {
  switch (t) {
    case 0:
      return e & r ^ ~e & n;
    case 1:
      return e ^ r ^ n;
    case 2:
      return e & r ^ e & n ^ r & n;
    case 3:
      return e ^ r ^ n;
  }
}
function ju(t, e) {
  return t << e | t >>> 32 - e;
}
function VR(t) {
  const e = [1518500249, 1859775393, 2400959708, 3395469782], r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof t == "string") {
    const a = unescape(encodeURIComponent(t));
    t = [];
    for (let o = 0; o < a.length; ++o)
      t.push(a.charCodeAt(o));
  } else
    Array.isArray(t) || (t = Array.prototype.slice.call(t));
  t.push(128);
  const n = t.length / 4 + 2, i = Math.ceil(n / 16), s = new Array(i);
  for (let a = 0; a < i; ++a) {
    const o = new Uint32Array(16);
    for (let l = 0; l < 16; ++l)
      o[l] = t[a * 64 + l * 4] << 24 | t[a * 64 + l * 4 + 1] << 16 | t[a * 64 + l * 4 + 2] << 8 | t[a * 64 + l * 4 + 3];
    s[a] = o;
  }
  s[i - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32), s[i - 1][14] = Math.floor(s[i - 1][14]), s[i - 1][15] = (t.length - 1) * 8 & 4294967295;
  for (let a = 0; a < i; ++a) {
    const o = new Uint32Array(80);
    for (let p = 0; p < 16; ++p)
      o[p] = s[a][p];
    for (let p = 16; p < 80; ++p)
      o[p] = ju(o[p - 3] ^ o[p - 8] ^ o[p - 14] ^ o[p - 16], 1);
    let l = r[0], u = r[1], h = r[2], f = r[3], d = r[4];
    for (let p = 0; p < 80; ++p) {
      const m = Math.floor(p / 20), _ = ju(l, 5) + PR(m, u, h, f) + d + e[m] + o[p] >>> 0;
      d = f, f = h, h = ju(u, 30) >>> 0, u = l, l = _;
    }
    r[0] = r[0] + l >>> 0, r[1] = r[1] + u >>> 0, r[2] = r[2] + h >>> 0, r[3] = r[3] + f >>> 0, r[4] = r[4] + d >>> 0;
  }
  return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, r[0] & 255, r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, r[1] & 255, r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, r[2] & 255, r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, r[3] & 255, r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, r[4] & 255];
}
const YR = OR("v5", 80, VR), zR = YR, UR = /[^\dA-Za-z](\W)*/g;
let We = {}, ro = /* @__PURE__ */ new Map();
const WR = function(t) {
  const e = Object.keys(t);
  for (const r of e)
    We[r] = t[r];
}, HR = (t, e, r) => {
  const n = We.entityPadding / 3, i = We.entityPadding / 3, s = We.fontSize * 0.85, a = e.node().getBBox(), o = [];
  let l = !1, u = !1, h = 0, f = 0, d = 0, p = 0, m = a.height + n * 2, _ = 1;
  r.forEach((D) => {
    D.attributeKeyTypeList !== void 0 && D.attributeKeyTypeList.length > 0 && (l = !0), D.attributeComment !== void 0 && (u = !0);
  }), r.forEach((D) => {
    const F = `${e.node().id}-attr-${_}`;
    let P = 0;
    const V = ci(D.attributeType), R = t.append("text").classed("er entityLabel", !0).attr("id", `${F}-type`).attr("x", 0).attr("y", 0).style("dominant-baseline", "middle").style("text-anchor", "left").style("font-family", q().fontFamily).style("font-size", s + "px").text(V), O = t.append("text").classed("er entityLabel", !0).attr("id", `${F}-name`).attr("x", 0).attr("y", 0).style("dominant-baseline", "middle").style("text-anchor", "left").style("font-family", q().fontFamily).style("font-size", s + "px").text(D.attributeName), C = {};
    C.tn = R, C.nn = O;
    const S = R.node().getBBox(), T = O.node().getBBox();
    if (h = Math.max(h, S.width), f = Math.max(f, T.width), P = Math.max(S.height, T.height), l) {
      const b = D.attributeKeyTypeList !== void 0 ? D.attributeKeyTypeList.join(",") : "", w = t.append("text").classed("er entityLabel", !0).attr("id", `${F}-key`).attr("x", 0).attr("y", 0).style("dominant-baseline", "middle").style("text-anchor", "left").style("font-family", q().fontFamily).style("font-size", s + "px").text(b);
      C.kn = w;
      const g = w.node().getBBox();
      d = Math.max(d, g.width), P = Math.max(P, g.height);
    }
    if (u) {
      const b = t.append("text").classed("er entityLabel", !0).attr("id", `${F}-comment`).attr("x", 0).attr("y", 0).style("dominant-baseline", "middle").style("text-anchor", "left").style("font-family", q().fontFamily).style("font-size", s + "px").text(D.attributeComment || "");
      C.cn = b;
      const w = b.node().getBBox();
      p = Math.max(p, w.width), P = Math.max(P, w.height);
    }
    C.height = P, o.push(C), m += P + n * 2, _ += 1;
  });
  let v = 4;
  l && (v += 2), u && (v += 2);
  const k = h + f + d + p, x = {
    width: Math.max(
      We.minEntityWidth,
      Math.max(
        a.width + We.entityPadding * 2,
        k + i * v
      )
    ),
    height: r.length > 0 ? m : Math.max(We.minEntityHeight, a.height + We.entityPadding * 2)
  };
  if (r.length > 0) {
    const D = Math.max(
      0,
      (x.width - k - i * v) / (v / 2)
    );
    e.attr(
      "transform",
      "translate(" + x.width / 2 + "," + (n + a.height / 2) + ")"
    );
    let F = a.height + n * 2, P = "attributeBoxOdd";
    o.forEach((V) => {
      const R = F + n + V.height / 2;
      V.tn.attr("transform", "translate(" + i + "," + R + ")");
      const O = t.insert("rect", "#" + V.tn.node().id).classed(`er ${P}`, !0).attr("x", 0).attr("y", F).attr("width", h + i * 2 + D).attr("height", V.height + n * 2), C = parseFloat(O.attr("x")) + parseFloat(O.attr("width"));
      V.nn.attr(
        "transform",
        "translate(" + (C + i) + "," + R + ")"
      );
      const S = t.insert("rect", "#" + V.nn.node().id).classed(`er ${P}`, !0).attr("x", C).attr("y", F).attr("width", f + i * 2 + D).attr("height", V.height + n * 2);
      let T = parseFloat(S.attr("x")) + parseFloat(S.attr("width"));
      if (l) {
        V.kn.attr(
          "transform",
          "translate(" + (T + i) + "," + R + ")"
        );
        const b = t.insert("rect", "#" + V.kn.node().id).classed(`er ${P}`, !0).attr("x", T).attr("y", F).attr("width", d + i * 2 + D).attr("height", V.height + n * 2);
        T = parseFloat(b.attr("x")) + parseFloat(b.attr("width"));
      }
      u && (V.cn.attr(
        "transform",
        "translate(" + (T + i) + "," + R + ")"
      ), t.insert("rect", "#" + V.cn.node().id).classed(`er ${P}`, "true").attr("x", T).attr("y", F).attr("width", p + i * 2 + D).attr("height", V.height + n * 2)), F += V.height + n * 2, P = P === "attributeBoxOdd" ? "attributeBoxEven" : "attributeBoxOdd";
    });
  } else
    x.height = Math.max(We.minEntityHeight, m), e.attr("transform", "translate(" + x.width / 2 + "," + x.height / 2 + ")");
  return x;
}, GR = function(t, e, r) {
  const n = Object.keys(e);
  let i;
  return n.forEach(function(s) {
    const a = ZR(s, "entity");
    ro.set(s, a);
    const o = t.append("g").attr("id", a);
    i = i === void 0 ? a : i;
    const l = "text-" + a, u = o.append("text").classed("er entityLabel", !0).attr("id", l).attr("x", 0).attr("y", 0).style("dominant-baseline", "middle").style("text-anchor", "middle").style("font-family", q().fontFamily).style("font-size", We.fontSize + "px").text(s), { width: h, height: f } = HR(
      o,
      u,
      e[s].attributes
    ), p = o.insert("rect", "#" + l).classed("er entityBox", !0).attr("x", 0).attr("y", 0).attr("width", h).attr("height", f).node().getBBox();
    r.setNode(a, {
      width: p.width,
      height: p.height,
      shape: "rect",
      id: a
    });
  }), i;
}, qR = function(t, e) {
  e.nodes().forEach(function(r) {
    r !== void 0 && e.node(r) !== void 0 && t.select("#" + r).attr(
      "transform",
      "translate(" + (e.node(r).x - e.node(r).width / 2) + "," + (e.node(r).y - e.node(r).height / 2) + " )"
    );
  });
}, zm = function(t) {
  return (t.entityA + t.roleA + t.entityB).replace(/\s/g, "");
}, $R = function(t, e) {
  return t.forEach(function(r) {
    e.setEdge(
      ro.get(r.entityA),
      ro.get(r.entityB),
      { relationship: r },
      zm(r)
    );
  }), t;
};
let k2 = 0;
const jR = function(t, e, r, n, i) {
  k2++;
  const s = r.edge(
    ro.get(e.entityA),
    ro.get(e.entityB),
    zm(e)
  ), a = js().x(function(m) {
    return m.x;
  }).y(function(m) {
    return m.y;
  }).curve(Is), o = t.insert("path", "#" + n).classed("er relationshipLine", !0).attr("d", a(s.points)).style("stroke", We.stroke).style("fill", "none");
  e.relSpec.relType === i.db.Identification.NON_IDENTIFYING && o.attr("stroke-dasharray", "8,8");
  let l = "";
  switch (We.arrowMarkerAbsolute && (l = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, l = l.replace(/\(/g, "\\("), l = l.replace(/\)/g, "\\)")), e.relSpec.cardA) {
    case i.db.Cardinality.ZERO_OR_ONE:
      o.attr("marker-end", "url(" + l + "#" + On.ERMarkers.ZERO_OR_ONE_END + ")");
      break;
    case i.db.Cardinality.ZERO_OR_MORE:
      o.attr("marker-end", "url(" + l + "#" + On.ERMarkers.ZERO_OR_MORE_END + ")");
      break;
    case i.db.Cardinality.ONE_OR_MORE:
      o.attr("marker-end", "url(" + l + "#" + On.ERMarkers.ONE_OR_MORE_END + ")");
      break;
    case i.db.Cardinality.ONLY_ONE:
      o.attr("marker-end", "url(" + l + "#" + On.ERMarkers.ONLY_ONE_END + ")");
      break;
  }
  switch (e.relSpec.cardB) {
    case i.db.Cardinality.ZERO_OR_ONE:
      o.attr(
        "marker-start",
        "url(" + l + "#" + On.ERMarkers.ZERO_OR_ONE_START + ")"
      );
      break;
    case i.db.Cardinality.ZERO_OR_MORE:
      o.attr(
        "marker-start",
        "url(" + l + "#" + On.ERMarkers.ZERO_OR_MORE_START + ")"
      );
      break;
    case i.db.Cardinality.ONE_OR_MORE:
      o.attr(
        "marker-start",
        "url(" + l + "#" + On.ERMarkers.ONE_OR_MORE_START + ")"
      );
      break;
    case i.db.Cardinality.ONLY_ONE:
      o.attr("marker-start", "url(" + l + "#" + On.ERMarkers.ONLY_ONE_START + ")");
      break;
  }
  const u = o.node().getTotalLength(), h = o.node().getPointAtLength(u * 0.5), f = "rel" + k2, p = t.append("text").classed("er relationshipLabel", !0).attr("id", f).attr("x", h.x).attr("y", h.y).style("text-anchor", "middle").style("dominant-baseline", "middle").style("font-family", q().fontFamily).style("font-size", We.fontSize + "px").text(e.roleA).node().getBBox();
  t.insert("rect", "#" + f).classed("er relationshipLabelBox", !0).attr("x", h.x - p.width / 2).attr("y", h.y - p.height / 2).attr("width", p.width).attr("height", p.height);
}, XR = function(t, e, r, n) {
  We = q().er, B.info("Drawing ER diagram");
  const i = q().securityLevel;
  let s;
  i === "sandbox" && (s = _t("#i" + e));
  const o = _t(i === "sandbox" ? s.nodes()[0].contentDocument.body : "body").select(`[id='${e}']`);
  On.insertMarkers(o, We);
  let l;
  l = new Ve({
    multigraph: !0,
    directed: !0,
    compound: !1
  }).setGraph({
    rankdir: We.layoutDirection,
    marginx: 20,
    marginy: 20,
    nodesep: 100,
    edgesep: 100,
    ranksep: 100
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  const u = GR(o, n.db.getEntities(), l), h = $R(n.db.getRelationships(), l);
  ta(l), qR(o, l), h.forEach(function(_) {
    jR(o, _, l, u, n);
  });
  const f = We.diagramPadding;
  jt.insertTitle(o, "entityTitleText", We.titleTopMargin, n.db.getDiagramTitle());
  const d = o.node().getBBox(), p = d.width + f * 2, m = d.height + f * 2;
  cn(o, m, p, We.useMaxWidth), o.attr("viewBox", `${d.x - f} ${d.y - f} ${p} ${m}`);
}, KR = "28e9f9db-3c8d-5aa5-9faf-44286ae5937c";
function ZR(t = "", e = "") {
  const r = t.replace(UR, "");
  return `${w2(e)}${w2(r)}${zR(
    t,
    KR
  )}`;
}
function w2(t = "") {
  return t.length > 0 ? `${t}-` : "";
}
const QR = {
  setConf: WR,
  draw: XR
};
var $h = function() {
  var t = function(An, Pt, Yt, oe) {
    for (Yt = Yt || {}, oe = An.length; oe--; Yt[An[oe]] = Pt)
      ;
    return Yt;
  }, e = [1, 9], r = [1, 7], n = [1, 6], i = [1, 8], s = [1, 20, 21, 22, 23, 38, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], a = [2, 10], o = [1, 20], l = [1, 21], u = [1, 22], h = [1, 23], f = [1, 30], d = [1, 32], p = [1, 33], m = [1, 34], _ = [1, 62], v = [1, 48], k = [1, 52], x = [1, 36], D = [1, 37], F = [1, 38], P = [1, 39], V = [1, 40], R = [1, 56], O = [1, 63], C = [1, 51], S = [1, 53], T = [1, 55], b = [1, 59], w = [1, 60], g = [1, 41], M = [1, 42], y = [1, 43], N = [1, 44], it = [1, 61], Y = [1, 50], Z = [1, 54], J = [1, 57], X = [1, 58], tt = [1, 49], st = [1, 66], lt = [1, 71], U = [1, 20, 21, 22, 23, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], Tt = [1, 75], $ = [1, 74], j = [1, 76], W = [20, 21, 23, 81, 82], z = [1, 99], A = [1, 104], I = [1, 107], G = [1, 108], L = [1, 101], at = [1, 106], E = [1, 109], Dt = [1, 102], et = [1, 114], Et = [1, 113], vt = [1, 103], pt = [1, 105], ht = [1, 110], gt = [1, 111], ut = [1, 112], yt = [1, 115], ue = [20, 21, 22, 23, 81, 82], re = [20, 21, 22, 23, 53, 81, 82], Mt = [20, 21, 22, 23, 40, 52, 53, 55, 57, 59, 61, 63, 65, 66, 67, 69, 71, 73, 74, 76, 81, 82, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], Nt = [20, 21, 23], Kt = [20, 21, 23, 52, 66, 67, 81, 82, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], fe = [1, 12, 20, 21, 22, 23, 24, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], Gt = [52, 66, 67, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], Ot = [1, 149], Bt = [1, 157], bt = [1, 158], mt = [1, 159], wt = [1, 160], ft = [1, 144], It = [1, 145], nt = [1, 141], Wt = [1, 152], ct = [1, 153], qt = [1, 154], Jt = [1, 155], se = [1, 156], ne = [1, 161], ae = [1, 162], Rt = [1, 147], Ht = [1, 150], ie = [1, 146], Ut = [1, 143], Sn = [20, 21, 22, 23, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], xi = [1, 165], me = [20, 21, 22, 23, 26, 52, 66, 67, 91, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $t = [20, 21, 22, 23, 24, 26, 38, 40, 41, 42, 52, 56, 58, 60, 62, 64, 66, 67, 68, 70, 72, 73, 75, 77, 81, 82, 86, 87, 88, 89, 90, 91, 92, 95, 105, 106, 109, 111, 112, 113, 114, 122, 123, 124, 125, 126, 127], Ce = [12, 21, 22, 24], rr = [22, 106], Se = [1, 250], Ye = [1, 245], be = [1, 246], Je = [1, 254], Ge = [1, 251], Lt = [1, 248], K = [1, 247], xt = [1, 249], Ct = [1, 252], te = [1, 253], de = [1, 255], ge = [1, 273], Me = [20, 21, 23, 106], qe = [20, 21, 22, 23, 66, 67, 86, 102, 105, 106, 109, 110, 111, 112, 113], we = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, mermaidDoc: 4, directive: 5, openDirective: 6, typeDirective: 7, closeDirective: 8, separator: 9, ":": 10, argDirective: 11, open_directive: 12, type_directive: 13, arg_directive: 14, close_directive: 15, graphConfig: 16, document: 17, line: 18, statement: 19, SEMI: 20, NEWLINE: 21, SPACE: 22, EOF: 23, GRAPH: 24, NODIR: 25, DIR: 26, FirstStmtSeperator: 27, ending: 28, endToken: 29, spaceList: 30, spaceListNewline: 31, verticeStatement: 32, styleStatement: 33, linkStyleStatement: 34, classDefStatement: 35, classStatement: 36, clickStatement: 37, subgraph: 38, text: 39, SQS: 40, SQE: 41, end: 42, direction: 43, acc_title: 44, acc_title_value: 45, acc_descr: 46, acc_descr_value: 47, acc_descr_multiline_value: 48, link: 49, node: 50, vertex: 51, AMP: 52, STYLE_SEPARATOR: 53, idString: 54, DOUBLECIRCLESTART: 55, DOUBLECIRCLEEND: 56, PS: 57, PE: 58, "(-": 59, "-)": 60, STADIUMSTART: 61, STADIUMEND: 62, SUBROUTINESTART: 63, SUBROUTINEEND: 64, VERTEX_WITH_PROPS_START: 65, ALPHA: 66, COLON: 67, PIPE: 68, CYLINDERSTART: 69, CYLINDEREND: 70, DIAMOND_START: 71, DIAMOND_STOP: 72, TAGEND: 73, TRAPSTART: 74, TRAPEND: 75, INVTRAPSTART: 76, INVTRAPEND: 77, linkStatement: 78, arrowText: 79, TESTSTR: 80, START_LINK: 81, LINK: 82, textToken: 83, STR: 84, keywords: 85, STYLE: 86, LINKSTYLE: 87, CLASSDEF: 88, CLASS: 89, CLICK: 90, DOWN: 91, UP: 92, textNoTags: 93, textNoTagsToken: 94, DEFAULT: 95, stylesOpt: 96, alphaNum: 97, CALLBACKNAME: 98, CALLBACKARGS: 99, HREF: 100, LINK_TARGET: 101, HEX: 102, numList: 103, INTERPOLATE: 104, NUM: 105, COMMA: 106, style: 107, styleComponent: 108, MINUS: 109, UNIT: 110, BRKT: 111, DOT: 112, PCT: 113, TAGSTART: 114, alphaNumToken: 115, idStringToken: 116, alphaNumStatement: 117, direction_tb: 118, direction_bt: 119, direction_rl: 120, direction_lr: 121, PUNCTUATION: 122, UNICODE_TEXT: 123, PLUS: 124, EQUALS: 125, MULT: 126, UNDERSCORE: 127, graphCodeTokens: 128, ARROW_CROSS: 129, ARROW_POINT: 130, ARROW_CIRCLE: 131, ARROW_OPEN: 132, QUOTE: 133, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 10: ":", 12: "open_directive", 13: "type_directive", 14: "arg_directive", 15: "close_directive", 20: "SEMI", 21: "NEWLINE", 22: "SPACE", 23: "EOF", 24: "GRAPH", 25: "NODIR", 26: "DIR", 38: "subgraph", 40: "SQS", 41: "SQE", 42: "end", 44: "acc_title", 45: "acc_title_value", 46: "acc_descr", 47: "acc_descr_value", 48: "acc_descr_multiline_value", 52: "AMP", 53: "STYLE_SEPARATOR", 55: "DOUBLECIRCLESTART", 56: "DOUBLECIRCLEEND", 57: "PS", 58: "PE", 59: "(-", 60: "-)", 61: "STADIUMSTART", 62: "STADIUMEND", 63: "SUBROUTINESTART", 64: "SUBROUTINEEND", 65: "VERTEX_WITH_PROPS_START", 66: "ALPHA", 67: "COLON", 68: "PIPE", 69: "CYLINDERSTART", 70: "CYLINDEREND", 71: "DIAMOND_START", 72: "DIAMOND_STOP", 73: "TAGEND", 74: "TRAPSTART", 75: "TRAPEND", 76: "INVTRAPSTART", 77: "INVTRAPEND", 80: "TESTSTR", 81: "START_LINK", 82: "LINK", 84: "STR", 86: "STYLE", 87: "LINKSTYLE", 88: "CLASSDEF", 89: "CLASS", 90: "CLICK", 91: "DOWN", 92: "UP", 95: "DEFAULT", 98: "CALLBACKNAME", 99: "CALLBACKARGS", 100: "HREF", 101: "LINK_TARGET", 102: "HEX", 104: "INTERPOLATE", 105: "NUM", 106: "COMMA", 109: "MINUS", 110: "UNIT", 111: "BRKT", 112: "DOT", 113: "PCT", 114: "TAGSTART", 118: "direction_tb", 119: "direction_bt", 120: "direction_rl", 121: "direction_lr", 122: "PUNCTUATION", 123: "UNICODE_TEXT", 124: "PLUS", 125: "EQUALS", 126: "MULT", 127: "UNDERSCORE", 129: "ARROW_CROSS", 130: "ARROW_POINT", 131: "ARROW_CIRCLE", 132: "ARROW_OPEN", 133: "QUOTE" },
    productions_: [0, [3, 1], [3, 2], [5, 4], [5, 6], [6, 1], [7, 1], [11, 1], [8, 1], [4, 2], [17, 0], [17, 2], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [16, 2], [16, 2], [16, 2], [16, 3], [28, 2], [28, 1], [29, 1], [29, 1], [29, 1], [27, 1], [27, 1], [27, 2], [31, 2], [31, 2], [31, 1], [31, 1], [30, 2], [30, 1], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 9], [19, 6], [19, 4], [19, 1], [19, 2], [19, 2], [19, 1], [9, 1], [9, 1], [9, 1], [32, 3], [32, 4], [32, 2], [32, 1], [50, 1], [50, 5], [50, 3], [51, 4], [51, 4], [51, 6], [51, 4], [51, 4], [51, 4], [51, 8], [51, 4], [51, 4], [51, 4], [51, 6], [51, 4], [51, 4], [51, 4], [51, 4], [51, 4], [51, 1], [49, 2], [49, 3], [49, 3], [49, 1], [49, 3], [78, 1], [79, 3], [39, 1], [39, 2], [39, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [93, 1], [93, 2], [35, 5], [35, 5], [36, 5], [37, 2], [37, 4], [37, 3], [37, 5], [37, 2], [37, 4], [37, 4], [37, 6], [37, 2], [37, 4], [37, 2], [37, 4], [37, 4], [37, 6], [33, 5], [33, 5], [34, 5], [34, 5], [34, 9], [34, 9], [34, 7], [34, 7], [103, 1], [103, 3], [96, 1], [96, 3], [107, 1], [107, 2], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [94, 1], [94, 1], [94, 1], [94, 1], [54, 1], [54, 2], [97, 1], [97, 2], [117, 1], [117, 1], [117, 1], [117, 1], [43, 1], [43, 1], [43, 1], [43, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1]],
    performAction: function(Pt, Yt, oe, St, ve, H, na) {
      var Q = H.length - 1;
      switch (ve) {
        case 5:
          St.parseDirective("%%{", "open_directive");
          break;
        case 6:
          St.parseDirective(H[Q], "type_directive");
          break;
        case 7:
          H[Q] = H[Q].trim().replace(/'/g, '"'), St.parseDirective(H[Q], "arg_directive");
          break;
        case 8:
          St.parseDirective("}%%", "close_directive", "flowchart");
          break;
        case 10:
          this.$ = [];
          break;
        case 11:
          (!Array.isArray(H[Q]) || H[Q].length > 0) && H[Q - 1].push(H[Q]), this.$ = H[Q - 1];
          break;
        case 12:
        case 82:
        case 84:
        case 96:
        case 152:
        case 154:
        case 155:
          this.$ = H[Q];
          break;
        case 19:
          St.setDirection("TB"), this.$ = "TB";
          break;
        case 20:
          St.setDirection(H[Q - 1]), this.$ = H[Q - 1];
          break;
        case 35:
          this.$ = H[Q - 1].nodes;
          break;
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
          this.$ = [];
          break;
        case 41:
          this.$ = St.addSubGraph(H[Q - 6], H[Q - 1], H[Q - 4]);
          break;
        case 42:
          this.$ = St.addSubGraph(H[Q - 3], H[Q - 1], H[Q - 3]);
          break;
        case 43:
          this.$ = St.addSubGraph(void 0, H[Q - 1], void 0);
          break;
        case 45:
          this.$ = H[Q].trim(), St.setAccTitle(this.$);
          break;
        case 46:
        case 47:
          this.$ = H[Q].trim(), St.setAccDescription(this.$);
          break;
        case 51:
          St.addLink(H[Q - 2].stmt, H[Q], H[Q - 1]), this.$ = { stmt: H[Q], nodes: H[Q].concat(H[Q - 2].nodes) };
          break;
        case 52:
          St.addLink(H[Q - 3].stmt, H[Q - 1], H[Q - 2]), this.$ = { stmt: H[Q - 1], nodes: H[Q - 1].concat(H[Q - 3].nodes) };
          break;
        case 53:
          this.$ = { stmt: H[Q - 1], nodes: H[Q - 1] };
          break;
        case 54:
          this.$ = { stmt: H[Q], nodes: H[Q] };
          break;
        case 55:
          this.$ = [H[Q]];
          break;
        case 56:
          this.$ = H[Q - 4].concat(H[Q]);
          break;
        case 57:
          this.$ = [H[Q - 2]], St.setClass(H[Q - 2], H[Q]);
          break;
        case 58:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "square");
          break;
        case 59:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "doublecircle");
          break;
        case 60:
          this.$ = H[Q - 5], St.addVertex(H[Q - 5], H[Q - 2], "circle");
          break;
        case 61:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "ellipse");
          break;
        case 62:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "stadium");
          break;
        case 63:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "subroutine");
          break;
        case 64:
          this.$ = H[Q - 7], St.addVertex(H[Q - 7], H[Q - 1], "rect", void 0, void 0, void 0, Object.fromEntries([[H[Q - 5], H[Q - 3]]]));
          break;
        case 65:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "cylinder");
          break;
        case 66:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "round");
          break;
        case 67:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "diamond");
          break;
        case 68:
          this.$ = H[Q - 5], St.addVertex(H[Q - 5], H[Q - 2], "hexagon");
          break;
        case 69:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "odd");
          break;
        case 70:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "trapezoid");
          break;
        case 71:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "inv_trapezoid");
          break;
        case 72:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "lean_right");
          break;
        case 73:
          this.$ = H[Q - 3], St.addVertex(H[Q - 3], H[Q - 1], "lean_left");
          break;
        case 74:
          this.$ = H[Q], St.addVertex(H[Q]);
          break;
        case 75:
          H[Q - 1].text = H[Q], this.$ = H[Q - 1];
          break;
        case 76:
        case 77:
          H[Q - 2].text = H[Q - 1], this.$ = H[Q - 2];
          break;
        case 78:
          this.$ = H[Q];
          break;
        case 79:
          var Nr = St.destructLink(H[Q], H[Q - 2]);
          this.$ = { type: Nr.type, stroke: Nr.stroke, length: Nr.length, text: H[Q - 1] };
          break;
        case 80:
          var Nr = St.destructLink(H[Q]);
          this.$ = { type: Nr.type, stroke: Nr.stroke, length: Nr.length };
          break;
        case 81:
          this.$ = H[Q - 1];
          break;
        case 83:
        case 97:
        case 153:
          this.$ = H[Q - 1] + "" + H[Q];
          break;
        case 98:
        case 99:
          this.$ = H[Q - 4], St.addClass(H[Q - 2], H[Q]);
          break;
        case 100:
          this.$ = H[Q - 4], St.setClass(H[Q - 2], H[Q]);
          break;
        case 101:
        case 109:
          this.$ = H[Q - 1], St.setClickEvent(H[Q - 1], H[Q]);
          break;
        case 102:
        case 110:
          this.$ = H[Q - 3], St.setClickEvent(H[Q - 3], H[Q - 2]), St.setTooltip(H[Q - 3], H[Q]);
          break;
        case 103:
          this.$ = H[Q - 2], St.setClickEvent(H[Q - 2], H[Q - 1], H[Q]);
          break;
        case 104:
          this.$ = H[Q - 4], St.setClickEvent(H[Q - 4], H[Q - 3], H[Q - 2]), St.setTooltip(H[Q - 4], H[Q]);
          break;
        case 105:
        case 111:
          this.$ = H[Q - 1], St.setLink(H[Q - 1], H[Q]);
          break;
        case 106:
        case 112:
          this.$ = H[Q - 3], St.setLink(H[Q - 3], H[Q - 2]), St.setTooltip(H[Q - 3], H[Q]);
          break;
        case 107:
        case 113:
          this.$ = H[Q - 3], St.setLink(H[Q - 3], H[Q - 2], H[Q]);
          break;
        case 108:
        case 114:
          this.$ = H[Q - 5], St.setLink(H[Q - 5], H[Q - 4], H[Q]), St.setTooltip(H[Q - 5], H[Q - 2]);
          break;
        case 115:
          this.$ = H[Q - 4], St.addVertex(H[Q - 2], void 0, void 0, H[Q]);
          break;
        case 116:
        case 118:
          this.$ = H[Q - 4], St.updateLink(H[Q - 2], H[Q]);
          break;
        case 117:
          this.$ = H[Q - 4], St.updateLink([H[Q - 2]], H[Q]);
          break;
        case 119:
          this.$ = H[Q - 8], St.updateLinkInterpolate([H[Q - 6]], H[Q - 2]), St.updateLink([H[Q - 6]], H[Q]);
          break;
        case 120:
          this.$ = H[Q - 8], St.updateLinkInterpolate(H[Q - 6], H[Q - 2]), St.updateLink(H[Q - 6], H[Q]);
          break;
        case 121:
          this.$ = H[Q - 6], St.updateLinkInterpolate([H[Q - 4]], H[Q]);
          break;
        case 122:
          this.$ = H[Q - 6], St.updateLinkInterpolate(H[Q - 4], H[Q]);
          break;
        case 123:
        case 125:
          this.$ = [H[Q]];
          break;
        case 124:
        case 126:
          H[Q - 2].push(H[Q]), this.$ = H[Q - 2];
          break;
        case 128:
          this.$ = H[Q - 1] + H[Q];
          break;
        case 150:
          this.$ = H[Q];
          break;
        case 151:
          this.$ = H[Q - 1] + "" + H[Q];
          break;
        case 156:
          this.$ = "v";
          break;
        case 157:
          this.$ = "-";
          break;
        case 158:
          this.$ = { stmt: "dir", value: "TB" };
          break;
        case 159:
          this.$ = { stmt: "dir", value: "BT" };
          break;
        case 160:
          this.$ = { stmt: "dir", value: "RL" };
          break;
        case 161:
          this.$ = { stmt: "dir", value: "LR" };
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: 5, 12: e, 16: 4, 21: r, 22: n, 24: i }, { 1: [3] }, { 1: [2, 1] }, { 3: 10, 4: 2, 5: 3, 6: 5, 12: e, 16: 4, 21: r, 22: n, 24: i }, t(s, a, { 17: 11 }), { 7: 12, 13: [1, 13] }, { 16: 14, 21: r, 22: n, 24: i }, { 16: 15, 21: r, 22: n, 24: i }, { 25: [1, 16], 26: [1, 17] }, { 13: [2, 5] }, { 1: [2, 2] }, { 1: [2, 9], 18: 18, 19: 19, 20: o, 21: l, 22: u, 23: h, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: f, 43: 31, 44: d, 46: p, 48: m, 50: 35, 51: 45, 52: _, 54: 46, 66: v, 67: k, 86: x, 87: D, 88: F, 89: P, 90: V, 91: R, 95: O, 105: C, 106: S, 109: T, 111: b, 112: w, 116: 47, 118: g, 119: M, 120: y, 121: N, 122: it, 123: Y, 124: Z, 125: J, 126: X, 127: tt }, { 8: 64, 10: [1, 65], 15: st }, t([10, 15], [2, 6]), t(s, [2, 17]), t(s, [2, 18]), t(s, [2, 19]), { 20: [1, 68], 21: [1, 69], 22: lt, 27: 67, 30: 70 }, t(U, [2, 11]), t(U, [2, 12]), t(U, [2, 13]), t(U, [2, 14]), t(U, [2, 15]), t(U, [2, 16]), { 9: 72, 20: Tt, 21: $, 23: j, 49: 73, 78: 77, 81: [1, 78], 82: [1, 79] }, { 9: 80, 20: Tt, 21: $, 23: j }, { 9: 81, 20: Tt, 21: $, 23: j }, { 9: 82, 20: Tt, 21: $, 23: j }, { 9: 83, 20: Tt, 21: $, 23: j }, { 9: 84, 20: Tt, 21: $, 23: j }, { 9: 86, 20: Tt, 21: $, 22: [1, 85], 23: j }, t(U, [2, 44]), { 45: [1, 87] }, { 47: [1, 88] }, t(U, [2, 47]), t(W, [2, 54], { 30: 89, 22: lt }), { 22: [1, 90] }, { 22: [1, 91] }, { 22: [1, 92] }, { 22: [1, 93] }, { 26: z, 52: A, 66: I, 67: G, 84: [1, 97], 91: L, 97: 96, 98: [1, 94], 100: [1, 95], 105: at, 106: E, 109: Dt, 111: et, 112: Et, 115: 100, 117: 98, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(U, [2, 158]), t(U, [2, 159]), t(U, [2, 160]), t(U, [2, 161]), t(ue, [2, 55], { 53: [1, 116] }), t(re, [2, 74], { 116: 129, 40: [1, 117], 52: _, 55: [1, 118], 57: [1, 119], 59: [1, 120], 61: [1, 121], 63: [1, 122], 65: [1, 123], 66: v, 67: k, 69: [1, 124], 71: [1, 125], 73: [1, 126], 74: [1, 127], 76: [1, 128], 91: R, 95: O, 105: C, 106: S, 109: T, 111: b, 112: w, 122: it, 123: Y, 124: Z, 125: J, 126: X, 127: tt }), t(Mt, [2, 150]), t(Mt, [2, 175]), t(Mt, [2, 176]), t(Mt, [2, 177]), t(Mt, [2, 178]), t(Mt, [2, 179]), t(Mt, [2, 180]), t(Mt, [2, 181]), t(Mt, [2, 182]), t(Mt, [2, 183]), t(Mt, [2, 184]), t(Mt, [2, 185]), t(Mt, [2, 186]), t(Mt, [2, 187]), t(Mt, [2, 188]), t(Mt, [2, 189]), t(Mt, [2, 190]), { 9: 130, 20: Tt, 21: $, 23: j }, { 11: 131, 14: [1, 132] }, t(Nt, [2, 8]), t(s, [2, 20]), t(s, [2, 26]), t(s, [2, 27]), { 21: [1, 133] }, t(Kt, [2, 34], { 30: 134, 22: lt }), t(U, [2, 35]), { 50: 135, 51: 45, 52: _, 54: 46, 66: v, 67: k, 91: R, 95: O, 105: C, 106: S, 109: T, 111: b, 112: w, 116: 47, 122: it, 123: Y, 124: Z, 125: J, 126: X, 127: tt }, t(fe, [2, 48]), t(fe, [2, 49]), t(fe, [2, 50]), t(Gt, [2, 78], { 79: 136, 68: [1, 138], 80: [1, 137] }), { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 139, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t([52, 66, 67, 68, 80, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], [2, 80]), t(U, [2, 36]), t(U, [2, 37]), t(U, [2, 38]), t(U, [2, 39]), t(U, [2, 40]), { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 163, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(Sn, a, { 17: 164 }), t(U, [2, 45]), t(U, [2, 46]), t(W, [2, 53], { 52: xi }), { 26: z, 52: A, 66: I, 67: G, 91: L, 97: 166, 102: [1, 167], 105: at, 106: E, 109: Dt, 111: et, 112: Et, 115: 100, 117: 98, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 95: [1, 168], 103: 169, 105: [1, 170] }, { 26: z, 52: A, 66: I, 67: G, 91: L, 95: [1, 171], 97: 172, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 115: 100, 117: 98, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 26: z, 52: A, 66: I, 67: G, 91: L, 97: 173, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 115: 100, 117: 98, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(Nt, [2, 101], { 22: [1, 174], 99: [1, 175] }), t(Nt, [2, 105], { 22: [1, 176] }), t(Nt, [2, 109], { 115: 100, 117: 178, 22: [1, 177], 26: z, 52: A, 66: I, 67: G, 91: L, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }), t(Nt, [2, 111], { 22: [1, 179] }), t(me, [2, 152]), t(me, [2, 154]), t(me, [2, 155]), t(me, [2, 156]), t(me, [2, 157]), t($t, [2, 162]), t($t, [2, 163]), t($t, [2, 164]), t($t, [2, 165]), t($t, [2, 166]), t($t, [2, 167]), t($t, [2, 168]), t($t, [2, 169]), t($t, [2, 170]), t($t, [2, 171]), t($t, [2, 172]), t($t, [2, 173]), t($t, [2, 174]), { 52: _, 54: 180, 66: v, 67: k, 91: R, 95: O, 105: C, 106: S, 109: T, 111: b, 112: w, 116: 47, 122: it, 123: Y, 124: Z, 125: J, 126: X, 127: tt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 181, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 182, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 184, 42: wt, 52: A, 57: [1, 183], 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 185, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 186, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 187, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 66: [1, 188] }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 189, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 190, 42: wt, 52: A, 66: I, 67: G, 71: [1, 191], 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 192, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 193, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 194, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(Mt, [2, 151]), t(Ce, [2, 3]), { 8: 195, 15: st }, { 15: [2, 7] }, t(s, [2, 28]), t(Kt, [2, 33]), t(W, [2, 51], { 30: 196, 22: lt }), t(Gt, [2, 75], { 22: [1, 197] }), { 22: [1, 198] }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 199, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 82: [1, 200], 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t($t, [2, 82]), t($t, [2, 84]), t($t, [2, 140]), t($t, [2, 141]), t($t, [2, 142]), t($t, [2, 143]), t($t, [2, 144]), t($t, [2, 145]), t($t, [2, 146]), t($t, [2, 147]), t($t, [2, 148]), t($t, [2, 149]), t($t, [2, 85]), t($t, [2, 86]), t($t, [2, 87]), t($t, [2, 88]), t($t, [2, 89]), t($t, [2, 90]), t($t, [2, 91]), t($t, [2, 92]), t($t, [2, 93]), t($t, [2, 94]), t($t, [2, 95]), { 9: 203, 20: Tt, 21: $, 22: Ot, 23: j, 24: Bt, 26: bt, 38: mt, 40: [1, 202], 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 18: 18, 19: 19, 20: o, 21: l, 22: u, 23: h, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: f, 42: [1, 204], 43: 31, 44: d, 46: p, 48: m, 50: 35, 51: 45, 52: _, 54: 46, 66: v, 67: k, 86: x, 87: D, 88: F, 89: P, 90: V, 91: R, 95: O, 105: C, 106: S, 109: T, 111: b, 112: w, 116: 47, 118: g, 119: M, 120: y, 121: N, 122: it, 123: Y, 124: Z, 125: J, 126: X, 127: tt }, { 22: lt, 30: 205 }, { 22: [1, 206], 26: z, 52: A, 66: I, 67: G, 91: L, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 115: 100, 117: 178, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: [1, 207] }, { 22: [1, 208] }, { 22: [1, 209], 106: [1, 210] }, t(rr, [2, 123]), { 22: [1, 211] }, { 22: [1, 212], 26: z, 52: A, 66: I, 67: G, 91: L, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 115: 100, 117: 178, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: [1, 213], 26: z, 52: A, 66: I, 67: G, 91: L, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 115: 100, 117: 178, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 84: [1, 214] }, t(Nt, [2, 103], { 22: [1, 215] }), { 84: [1, 216], 101: [1, 217] }, { 84: [1, 218] }, t(me, [2, 153]), { 84: [1, 219], 101: [1, 220] }, t(ue, [2, 57], { 116: 129, 52: _, 66: v, 67: k, 91: R, 95: O, 105: C, 106: S, 109: T, 111: b, 112: w, 122: it, 123: Y, 124: Z, 125: J, 126: X, 127: tt }), { 22: Ot, 24: Bt, 26: bt, 38: mt, 41: [1, 221], 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 56: [1, 222], 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 223, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 58: [1, 224], 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 60: [1, 225], 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 62: [1, 226], 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 64: [1, 227], 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 67: [1, 228] }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 66: I, 67: G, 70: [1, 229], 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 66: I, 67: G, 72: [1, 230], 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 231, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 41: [1, 232], 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 66: I, 67: G, 73: ft, 75: [1, 233], 77: [1, 234], 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 66: I, 67: G, 73: ft, 75: [1, 236], 77: [1, 235], 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 9: 237, 20: Tt, 21: $, 23: j }, t(W, [2, 52], { 52: xi }), t(Gt, [2, 77]), t(Gt, [2, 76]), { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 66: I, 67: G, 68: [1, 238], 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(Gt, [2, 79]), t($t, [2, 83]), { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 239, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(Sn, a, { 17: 240 }), t(U, [2, 43]), { 51: 241, 52: _, 54: 46, 66: v, 67: k, 91: R, 95: O, 105: C, 106: S, 109: T, 111: b, 112: w, 116: 47, 122: it, 123: Y, 124: Z, 125: J, 126: X, 127: tt }, { 22: Se, 66: Ye, 67: be, 86: Je, 96: 242, 102: Ge, 105: Lt, 107: 243, 108: 244, 109: K, 110: xt, 111: Ct, 112: te, 113: de }, { 22: Se, 66: Ye, 67: be, 86: Je, 96: 256, 102: Ge, 105: Lt, 107: 243, 108: 244, 109: K, 110: xt, 111: Ct, 112: te, 113: de }, { 22: Se, 66: Ye, 67: be, 86: Je, 96: 257, 102: Ge, 104: [1, 258], 105: Lt, 107: 243, 108: 244, 109: K, 110: xt, 111: Ct, 112: te, 113: de }, { 22: Se, 66: Ye, 67: be, 86: Je, 96: 259, 102: Ge, 104: [1, 260], 105: Lt, 107: 243, 108: 244, 109: K, 110: xt, 111: Ct, 112: te, 113: de }, { 105: [1, 261] }, { 22: Se, 66: Ye, 67: be, 86: Je, 96: 262, 102: Ge, 105: Lt, 107: 243, 108: 244, 109: K, 110: xt, 111: Ct, 112: te, 113: de }, { 22: Se, 66: Ye, 67: be, 86: Je, 96: 263, 102: Ge, 105: Lt, 107: 243, 108: 244, 109: K, 110: xt, 111: Ct, 112: te, 113: de }, { 26: z, 52: A, 66: I, 67: G, 91: L, 97: 264, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 115: 100, 117: 98, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(Nt, [2, 102]), { 84: [1, 265] }, t(Nt, [2, 106], { 22: [1, 266] }), t(Nt, [2, 107]), t(Nt, [2, 110]), t(Nt, [2, 112], { 22: [1, 267] }), t(Nt, [2, 113]), t(re, [2, 58]), t(re, [2, 59]), { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 58: [1, 268], 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(re, [2, 66]), t(re, [2, 61]), t(re, [2, 62]), t(re, [2, 63]), { 66: [1, 269] }, t(re, [2, 65]), t(re, [2, 67]), { 22: Ot, 24: Bt, 26: bt, 38: mt, 42: wt, 52: A, 66: I, 67: G, 72: [1, 270], 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(re, [2, 69]), t(re, [2, 70]), t(re, [2, 72]), t(re, [2, 71]), t(re, [2, 73]), t(Ce, [2, 4]), t([22, 52, 66, 67, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], [2, 81]), { 22: Ot, 24: Bt, 26: bt, 38: mt, 41: [1, 271], 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 18: 18, 19: 19, 20: o, 21: l, 22: u, 23: h, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: f, 42: [1, 272], 43: 31, 44: d, 46: p, 48: m, 50: 35, 51: 45, 52: _, 54: 46, 66: v, 67: k, 86: x, 87: D, 88: F, 89: P, 90: V, 91: R, 95: O, 105: C, 106: S, 109: T, 111: b, 112: w, 116: 47, 118: g, 119: M, 120: y, 121: N, 122: it, 123: Y, 124: Z, 125: J, 126: X, 127: tt }, t(ue, [2, 56]), t(Nt, [2, 115], { 106: ge }), t(Me, [2, 125], { 108: 274, 22: Se, 66: Ye, 67: be, 86: Je, 102: Ge, 105: Lt, 109: K, 110: xt, 111: Ct, 112: te, 113: de }), t(qe, [2, 127]), t(qe, [2, 129]), t(qe, [2, 130]), t(qe, [2, 131]), t(qe, [2, 132]), t(qe, [2, 133]), t(qe, [2, 134]), t(qe, [2, 135]), t(qe, [2, 136]), t(qe, [2, 137]), t(qe, [2, 138]), t(qe, [2, 139]), t(Nt, [2, 116], { 106: ge }), t(Nt, [2, 117], { 106: ge }), { 22: [1, 275] }, t(Nt, [2, 118], { 106: ge }), { 22: [1, 276] }, t(rr, [2, 124]), t(Nt, [2, 98], { 106: ge }), t(Nt, [2, 99], { 106: ge }), t(Nt, [2, 100], { 115: 100, 117: 178, 26: z, 52: A, 66: I, 67: G, 91: L, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }), t(Nt, [2, 104]), { 101: [1, 277] }, { 101: [1, 278] }, { 58: [1, 279] }, { 68: [1, 280] }, { 72: [1, 281] }, { 9: 282, 20: Tt, 21: $, 23: j }, t(U, [2, 42]), { 22: Se, 66: Ye, 67: be, 86: Je, 102: Ge, 105: Lt, 107: 283, 108: 244, 109: K, 110: xt, 111: Ct, 112: te, 113: de }, t(qe, [2, 128]), { 26: z, 52: A, 66: I, 67: G, 91: L, 97: 284, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 115: 100, 117: 98, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 26: z, 52: A, 66: I, 67: G, 91: L, 97: 285, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 115: 100, 117: 98, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(Nt, [2, 108]), t(Nt, [2, 114]), t(re, [2, 60]), { 22: Ot, 24: Bt, 26: bt, 38: mt, 39: 286, 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 140, 84: nt, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, t(re, [2, 68]), t(Sn, a, { 17: 287 }), t(Me, [2, 126], { 108: 274, 22: Se, 66: Ye, 67: be, 86: Je, 102: Ge, 105: Lt, 109: K, 110: xt, 111: Ct, 112: te, 113: de }), t(Nt, [2, 121], { 115: 100, 117: 178, 22: [1, 288], 26: z, 52: A, 66: I, 67: G, 91: L, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }), t(Nt, [2, 122], { 115: 100, 117: 178, 22: [1, 289], 26: z, 52: A, 66: I, 67: G, 91: L, 105: at, 106: E, 109: Dt, 111: et, 112: Et, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }), { 22: Ot, 24: Bt, 26: bt, 38: mt, 41: [1, 290], 42: wt, 52: A, 66: I, 67: G, 73: ft, 81: It, 83: 201, 85: 151, 86: Wt, 87: ct, 88: qt, 89: Jt, 90: se, 91: ne, 92: ae, 94: 142, 95: Rt, 105: at, 106: E, 109: Ht, 111: et, 112: Et, 113: ie, 114: Ut, 115: 148, 122: vt, 123: pt, 124: ht, 125: gt, 126: ut, 127: yt }, { 18: 18, 19: 19, 20: o, 21: l, 22: u, 23: h, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: f, 42: [1, 291], 43: 31, 44: d, 46: p, 48: m, 50: 35, 51: 45, 52: _, 54: 46, 66: v, 67: k, 86: x, 87: D, 88: F, 89: P, 90: V, 91: R, 95: O, 105: C, 106: S, 109: T, 111: b, 112: w, 116: 47, 118: g, 119: M, 120: y, 121: N, 122: it, 123: Y, 124: Z, 125: J, 126: X, 127: tt }, { 22: Se, 66: Ye, 67: be, 86: Je, 96: 292, 102: Ge, 105: Lt, 107: 243, 108: 244, 109: K, 110: xt, 111: Ct, 112: te, 113: de }, { 22: Se, 66: Ye, 67: be, 86: Je, 96: 293, 102: Ge, 105: Lt, 107: 243, 108: 244, 109: K, 110: xt, 111: Ct, 112: te, 113: de }, t(re, [2, 64]), t(U, [2, 41]), t(Nt, [2, 119], { 106: ge }), t(Nt, [2, 120], { 106: ge })],
    defaultActions: { 2: [2, 1], 9: [2, 5], 10: [2, 2], 132: [2, 7] },
    parseError: function(Pt, Yt) {
      if (Yt.recoverable)
        this.trace(Pt);
      else {
        var oe = new Error(Pt);
        throw oe.hash = Yt, oe;
      }
    },
    parse: function(Pt) {
      var Yt = this, oe = [0], St = [], ve = [null], H = [], na = this.table, Q = "", Nr = 0, of = 0, o5 = 2, lf = 1, l5 = H.slice.call(arguments, 1), $e = Object.create(this.lexer), vi = { yy: {} };
      for (var cu in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, cu) && (vi.yy[cu] = this.yy[cu]);
      $e.setInput(Pt, vi.yy), vi.yy.lexer = $e, vi.yy.parser = this, typeof $e.yylloc > "u" && ($e.yylloc = {});
      var uu = $e.yylloc;
      H.push(uu);
      var c5 = $e.options && $e.options.ranges;
      typeof vi.yy.parseError == "function" ? this.parseError = vi.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function u5() {
        var Bn;
        return Bn = St.pop() || $e.lex() || lf, typeof Bn != "number" && (Bn instanceof Array && (St = Bn, Bn = St.pop()), Bn = Yt.symbols_[Bn] || Bn), Bn;
      }
      for (var mr, ki, Rr, hu, ss = {}, Co, Ln, cf, So; ; ) {
        if (ki = oe[oe.length - 1], this.defaultActions[ki] ? Rr = this.defaultActions[ki] : ((mr === null || typeof mr > "u") && (mr = u5()), Rr = na[ki] && na[ki][mr]), typeof Rr > "u" || !Rr.length || !Rr[0]) {
          var fu = "";
          So = [];
          for (Co in na[ki])
            this.terminals_[Co] && Co > o5 && So.push("'" + this.terminals_[Co] + "'");
          $e.showPosition ? fu = "Parse error on line " + (Nr + 1) + `:
` + $e.showPosition() + `
Expecting ` + So.join(", ") + ", got '" + (this.terminals_[mr] || mr) + "'" : fu = "Parse error on line " + (Nr + 1) + ": Unexpected " + (mr == lf ? "end of input" : "'" + (this.terminals_[mr] || mr) + "'"), this.parseError(fu, {
            text: $e.match,
            token: this.terminals_[mr] || mr,
            line: $e.yylineno,
            loc: uu,
            expected: So
          });
        }
        if (Rr[0] instanceof Array && Rr.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + ki + ", token: " + mr);
        switch (Rr[0]) {
          case 1:
            oe.push(mr), ve.push($e.yytext), H.push($e.yylloc), oe.push(Rr[1]), mr = null, of = $e.yyleng, Q = $e.yytext, Nr = $e.yylineno, uu = $e.yylloc;
            break;
          case 2:
            if (Ln = this.productions_[Rr[1]][1], ss.$ = ve[ve.length - Ln], ss._$ = {
              first_line: H[H.length - (Ln || 1)].first_line,
              last_line: H[H.length - 1].last_line,
              first_column: H[H.length - (Ln || 1)].first_column,
              last_column: H[H.length - 1].last_column
            }, c5 && (ss._$.range = [
              H[H.length - (Ln || 1)].range[0],
              H[H.length - 1].range[1]
            ]), hu = this.performAction.apply(ss, [
              Q,
              of,
              Nr,
              vi.yy,
              Rr[1],
              ve,
              H
            ].concat(l5)), typeof hu < "u")
              return hu;
            Ln && (oe = oe.slice(0, -1 * Ln * 2), ve = ve.slice(0, -1 * Ln), H = H.slice(0, -1 * Ln)), oe.push(this.productions_[Rr[1]][0]), ve.push(ss.$), H.push(ss._$), cf = na[oe[oe.length - 2]][oe[oe.length - 1]], oe.push(cf);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, ra = function() {
    var An = {
      EOF: 1,
      parseError: function(Yt, oe) {
        if (this.yy.parser)
          this.yy.parser.parseError(Yt, oe);
        else
          throw new Error(Yt);
      },
      // resets the lexer, sets new input
      setInput: function(Pt, Yt) {
        return this.yy = Yt || this.yy || {}, this._input = Pt, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var Pt = this._input[0];
        this.yytext += Pt, this.yyleng++, this.offset++, this.match += Pt, this.matched += Pt;
        var Yt = Pt.match(/(?:\r\n?|\n).*/g);
        return Yt ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), Pt;
      },
      // unshifts one char (or a string) into the input
      unput: function(Pt) {
        var Yt = Pt.length, oe = Pt.split(/(?:\r\n?|\n)/g);
        this._input = Pt + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - Yt), this.offset -= Yt;
        var St = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), oe.length - 1 && (this.yylineno -= oe.length - 1);
        var ve = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: oe ? (oe.length === St.length ? this.yylloc.first_column : 0) + St[St.length - oe.length].length - oe[0].length : this.yylloc.first_column - Yt
        }, this.options.ranges && (this.yylloc.range = [ve[0], ve[0] + this.yyleng - Yt]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(Pt) {
        this.unput(this.match.slice(Pt));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var Pt = this.matched.substr(0, this.matched.length - this.match.length);
        return (Pt.length > 20 ? "..." : "") + Pt.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var Pt = this.match;
        return Pt.length < 20 && (Pt += this._input.substr(0, 20 - Pt.length)), (Pt.substr(0, 20) + (Pt.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var Pt = this.pastInput(), Yt = new Array(Pt.length + 1).join("-");
        return Pt + this.upcomingInput() + `
` + Yt + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(Pt, Yt) {
        var oe, St, ve;
        if (this.options.backtrack_lexer && (ve = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (ve.yylloc.range = this.yylloc.range.slice(0))), St = Pt[0].match(/(?:\r\n?|\n).*/g), St && (this.yylineno += St.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: St ? St[St.length - 1].length - St[St.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + Pt[0].length
        }, this.yytext += Pt[0], this.match += Pt[0], this.matches = Pt, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(Pt[0].length), this.matched += Pt[0], oe = this.performAction.call(this, this.yy, this, Yt, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), oe)
          return oe;
        if (this._backtrack) {
          for (var H in ve)
            this[H] = ve[H];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var Pt, Yt, oe, St;
        this._more || (this.yytext = "", this.match = "");
        for (var ve = this._currentRules(), H = 0; H < ve.length; H++)
          if (oe = this._input.match(this.rules[ve[H]]), oe && (!Yt || oe[0].length > Yt[0].length)) {
            if (Yt = oe, St = H, this.options.backtrack_lexer) {
              if (Pt = this.test_match(oe, ve[H]), Pt !== !1)
                return Pt;
              if (this._backtrack) {
                Yt = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return Yt ? (Pt = this.test_match(Yt, ve[St]), Pt !== !1 ? Pt : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var Yt = this.next();
        return Yt || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(Yt) {
        this.conditionStack.push(Yt);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var Yt = this.conditionStack.length - 1;
        return Yt > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(Yt) {
        return Yt = this.conditionStack.length - 1 - Math.abs(Yt || 0), Yt >= 0 ? this.conditionStack[Yt] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(Yt) {
        this.begin(Yt);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function(Yt, oe, St, ve) {
        switch (St) {
          case 0:
            return this.begin("open_directive"), 12;
          case 1:
            return this.begin("type_directive"), 13;
          case 2:
            return this.popState(), this.begin("arg_directive"), 10;
          case 3:
            return this.popState(), this.popState(), 15;
          case 4:
            return 14;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return this.begin("acc_title"), 44;
          case 8:
            return this.popState(), "acc_title_value";
          case 9:
            return this.begin("acc_descr"), 46;
          case 10:
            return this.popState(), "acc_descr_value";
          case 11:
            this.begin("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            this.begin("string");
            break;
          case 15:
            this.popState();
            break;
          case 16:
            return "STR";
          case 17:
            return 86;
          case 18:
            return 95;
          case 19:
            return 87;
          case 20:
            return 104;
          case 21:
            return 88;
          case 22:
            return 89;
          case 23:
            this.begin("href");
            break;
          case 24:
            this.popState();
            break;
          case 25:
            return 100;
          case 26:
            this.begin("callbackname");
            break;
          case 27:
            this.popState();
            break;
          case 28:
            this.popState(), this.begin("callbackargs");
            break;
          case 29:
            return 98;
          case 30:
            this.popState();
            break;
          case 31:
            return 99;
          case 32:
            this.begin("click");
            break;
          case 33:
            this.popState();
            break;
          case 34:
            return 90;
          case 35:
            return Yt.lex.firstGraph() && this.begin("dir"), 24;
          case 36:
            return Yt.lex.firstGraph() && this.begin("dir"), 24;
          case 37:
            return Yt.lex.firstGraph() && this.begin("dir"), 24;
          case 38:
            return 38;
          case 39:
            return 42;
          case 40:
            return 101;
          case 41:
            return 101;
          case 42:
            return 101;
          case 43:
            return 101;
          case 44:
            return this.popState(), 25;
          case 45:
            return this.popState(), 26;
          case 46:
            return this.popState(), 26;
          case 47:
            return this.popState(), 26;
          case 48:
            return this.popState(), 26;
          case 49:
            return this.popState(), 26;
          case 50:
            return this.popState(), 26;
          case 51:
            return this.popState(), 26;
          case 52:
            return this.popState(), 26;
          case 53:
            return this.popState(), 26;
          case 54:
            return this.popState(), 26;
          case 55:
            return 118;
          case 56:
            return 119;
          case 57:
            return 120;
          case 58:
            return 121;
          case 59:
            return 105;
          case 60:
            return 111;
          case 61:
            return 53;
          case 62:
            return 67;
          case 63:
            return 52;
          case 64:
            return 20;
          case 65:
            return 106;
          case 66:
            return 126;
          case 67:
            return 82;
          case 68:
            return 82;
          case 69:
            return 82;
          case 70:
            return 81;
          case 71:
            return 81;
          case 72:
            return 81;
          case 73:
            return 59;
          case 74:
            return 60;
          case 75:
            return 61;
          case 76:
            return 62;
          case 77:
            return 63;
          case 78:
            return 64;
          case 79:
            return 65;
          case 80:
            return 69;
          case 81:
            return 70;
          case 82:
            return 55;
          case 83:
            return 56;
          case 84:
            return 109;
          case 85:
            return 112;
          case 86:
            return 127;
          case 87:
            return 124;
          case 88:
            return 113;
          case 89:
            return 125;
          case 90:
            return 125;
          case 91:
            return 114;
          case 92:
            return 73;
          case 93:
            return 92;
          case 94:
            return "SEP";
          case 95:
            return 91;
          case 96:
            return 66;
          case 97:
            return 75;
          case 98:
            return 74;
          case 99:
            return 77;
          case 100:
            return 76;
          case 101:
            return 122;
          case 102:
            return 123;
          case 103:
            return 68;
          case 104:
            return 57;
          case 105:
            return 58;
          case 106:
            return 40;
          case 107:
            return 41;
          case 108:
            return 71;
          case 109:
            return 72;
          case 110:
            return 133;
          case 111:
            return 21;
          case 112:
            return 22;
          case 113:
            return 23;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:%%(?!\{)[^\n]*)/, /^(?:[^\}]%%[^\n]*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:style\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\b)/, /^(?:class\b)/, /^(?:href[\s]+["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:click[\s]+)/, /^(?:[\s\n])/, /^(?:[^\s\n]*)/, /^(?:flowchart-elk\b)/, /^(?:graph\b)/, /^(?:flowchart\b)/, /^(?:subgraph\b)/, /^(?:end\b\s*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:(\r?\n)*\s*\n)/, /^(?:\s*LR\b)/, /^(?:\s*RL\b)/, /^(?:\s*TB\b)/, /^(?:\s*BT\b)/, /^(?:\s*TD\b)/, /^(?:\s*BR\b)/, /^(?:\s*<)/, /^(?:\s*>)/, /^(?:\s*\^)/, /^(?:\s*v\b)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:[0-9]+)/, /^(?:#)/, /^(?::::)/, /^(?::)/, /^(?:&)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:\(-)/, /^(?:-\))/, /^(?:\(\[)/, /^(?:\]\))/, /^(?:\[\[)/, /^(?:\]\])/, /^(?:\[\|)/, /^(?:\[\()/, /^(?:\)\])/, /^(?:\(\(\()/, /^(?:\)\)\))/, /^(?:-)/, /^(?:\.)/, /^(?:[\_])/, /^(?:\+)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:<)/, /^(?:>)/, /^(?:\^)/, /^(?:\\\|)/, /^(?:v\b)/, /^(?:[A-Za-z]+)/, /^(?:\\\])/, /^(?:\[\/)/, /^(?:\/\])/, /^(?:\[\\)/, /^(?:[!"#$%&'*+,-.`?\\_/])/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\|)/, /^(?:\()/, /^(?:\))/, /^(?:\[)/, /^(?:\])/, /^(?:\{)/, /^(?:\})/, /^(?:")/, /^(?:(\r?\n)+)/, /^(?:\s)/, /^(?:$)/],
      conditions: { close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, open_directive: { rules: [1], inclusive: !1 }, callbackargs: { rules: [30, 31], inclusive: !1 }, callbackname: { rules: [27, 28, 29], inclusive: !1 }, href: { rules: [24, 25], inclusive: !1 }, click: { rules: [33, 34], inclusive: !1 }, vertex: { rules: [], inclusive: !1 }, dir: { rules: [44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54], inclusive: !1 }, acc_descr_multiline: { rules: [12, 13], inclusive: !1 }, acc_descr: { rules: [10], inclusive: !1 }, acc_title: { rules: [8], inclusive: !1 }, string: { rules: [15, 16], inclusive: !1 }, INITIAL: { rules: [0, 5, 6, 7, 9, 11, 14, 17, 18, 19, 20, 21, 22, 23, 26, 32, 35, 36, 37, 38, 39, 40, 41, 42, 43, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113], inclusive: !0 } }
    };
    return An;
  }();
  we.lexer = ra;
  function is() {
    this.yy = {};
  }
  return is.prototype = we, we.Parser = is, new is();
}();
$h.parser = $h;
const T2 = $h, JR = (t, e) => {
  var r, n;
  return ((r = e == null ? void 0 : e.flowchart) == null ? void 0 : r.defaultRenderer) === "dagre-wrapper" || ((n = e == null ? void 0 : e.flowchart) == null ? void 0 : n.defaultRenderer) === "elk" ? !1 : t.match(/^\s*graph/) !== null;
}, tF = (t, e) => {
  var r, n;
  return ((r = e == null ? void 0 : e.flowchart) == null ? void 0 : r.defaultRenderer) === "dagre-d3" || ((n = e == null ? void 0 : e.flowchart) == null ? void 0 : n.defaultRenderer) === "elk" ? !1 : t.match(/^\s*graph/) !== null ? !0 : t.match(/^\s*flowchart/) !== null;
}, eF = "flowchart-";
let E2 = 0, I0 = q(), _e = {}, Gi = [], ys = {}, Qn = [], lc = {}, M0 = {}, cl = 0, jh = !0, Pr, Jc, tu = [];
const eu = (t) => Xt.sanitizeText(t, I0), Um = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
}, _o = function(t) {
  const e = Object.keys(_e);
  for (const r of e)
    if (_e[r].id === t)
      return _e[r].domId;
  return t;
}, Wm = function(t, e, r, n, i, s, a = {}) {
  let o, l = t;
  l !== void 0 && l.trim().length !== 0 && (_e[l] === void 0 && (_e[l] = {
    id: l,
    domId: eF + l + "-" + E2,
    styles: [],
    classes: []
  }), E2++, e !== void 0 ? (I0 = q(), o = eu(e.trim()), o[0] === '"' && o[o.length - 1] === '"' && (o = o.substring(1, o.length - 1)), _e[l].text = o) : _e[l].text === void 0 && (_e[l].text = t), r !== void 0 && (_e[l].type = r), n != null && n.forEach(function(u) {
    _e[l].styles.push(u);
  }), i != null && i.forEach(function(u) {
    _e[l].classes.push(u);
  }), s !== void 0 && (_e[l].dir = s), _e[l].props === void 0 ? _e[l].props = a : a !== void 0 && Object.assign(_e[l].props, a));
}, Hm = function(t, e, r, n) {
  const a = { start: t, end: e, type: void 0, text: "" };
  n = r.text, n !== void 0 && (a.text = eu(n.trim()), a.text[0] === '"' && a.text[a.text.length - 1] === '"' && (a.text = a.text.substring(1, a.text.length - 1))), r !== void 0 && (a.type = r.type, a.stroke = r.stroke, a.length = r.length), Gi.push(a);
}, Gm = function(t, e, r, n) {
  let i, s;
  for (i = 0; i < t.length; i++)
    for (s = 0; s < e.length; s++)
      Hm(t[i], e[s], r, n);
}, qm = function(t, e) {
  t.forEach(function(r) {
    r === "default" ? Gi.defaultInterpolate = e : Gi[r].interpolate = e;
  });
}, $m = function(t, e) {
  t.forEach(function(r) {
    r === "default" ? Gi.defaultStyle = e : (jt.isSubstringInArray("fill", e) === -1 && e.push("fill:none"), Gi[r].style = e);
  });
}, jm = function(t, e) {
  ys[t] === void 0 && (ys[t] = { id: t, styles: [], textStyles: [] }), e != null && e.forEach(function(r) {
    if (r.match("color")) {
      const i = r.replace("fill", "bgFill").replace("color", "fill");
      ys[t].textStyles.push(i);
    }
    ys[t].styles.push(r);
  });
}, Xm = function(t) {
  Pr = t, Pr.match(/.*</) && (Pr = "RL"), Pr.match(/.*\^/) && (Pr = "BT"), Pr.match(/.*>/) && (Pr = "LR"), Pr.match(/.*v/) && (Pr = "TB"), Pr === "TD" && (Pr = "TB");
}, ru = function(t, e) {
  t.split(",").forEach(function(r) {
    let n = r;
    _e[n] !== void 0 && _e[n].classes.push(e), lc[n] !== void 0 && lc[n].classes.push(e);
  });
}, rF = function(t, e) {
  t.split(",").forEach(function(r) {
    e !== void 0 && (M0[Jc === "gen-1" ? _o(r) : r] = eu(e));
  });
}, nF = function(t, e, r) {
  let n = _o(t);
  if (q().securityLevel !== "loose" || e === void 0)
    return;
  let i = [];
  if (typeof r == "string") {
    i = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let s = 0; s < i.length; s++) {
      let a = i[s].trim();
      a.charAt(0) === '"' && a.charAt(a.length - 1) === '"' && (a = a.substr(1, a.length - 2)), i[s] = a;
    }
  }
  i.length === 0 && i.push(t), _e[t] !== void 0 && (_e[t].haveCallback = !0, tu.push(function() {
    const s = document.querySelector(`[id="${n}"]`);
    s !== null && s.addEventListener(
      "click",
      function() {
        jt.runFunc(e, ...i);
      },
      !1
    );
  }));
}, Km = function(t, e, r) {
  t.split(",").forEach(function(n) {
    _e[n] !== void 0 && (_e[n].link = jt.formatUrl(e, I0), _e[n].linkTarget = r);
  }), ru(t, "clickable");
}, Zm = function(t) {
  return M0[t];
}, Qm = function(t, e, r) {
  t.split(",").forEach(function(n) {
    nF(n, e, r);
  }), ru(t, "clickable");
}, Jm = function(t) {
  tu.forEach(function(e) {
    e(t);
  });
}, t3 = function() {
  return Pr.trim();
}, e3 = function() {
  return _e;
}, r3 = function() {
  return Gi;
}, n3 = function() {
  return ys;
}, i3 = function(t) {
  let e = _t(".mermaidTooltip");
  (e._groups || e)[0][0] === null && (e = _t("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), _t(t).select("svg").selectAll("g.node").on("mouseover", function() {
    const i = _t(this);
    if (i.attr("title") === null)
      return;
    const a = this.getBoundingClientRect();
    e.transition().duration(200).style("opacity", ".9"), e.text(i.attr("title")).style("left", window.scrollX + a.left + (a.right - a.left) / 2 + "px").style("top", window.scrollY + a.top - 14 + document.body.scrollTop + "px"), e.html(e.html().replace(/&lt;br\/&gt;/g, "<br/>")), i.classed("hover", !0);
  }).on("mouseout", function() {
    e.transition().duration(500).style("opacity", 0), _t(this).classed("hover", !1);
  });
};
tu.push(i3);
const s3 = function(t = "gen-1") {
  _e = {}, ys = {}, Gi = [], tu = [i3], Qn = [], lc = {}, cl = 0, M0 = [], jh = !0, Jc = t, Br();
}, a3 = (t) => {
  Jc = t || "gen-2";
}, o3 = function() {
  return "fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;";
}, l3 = function(t, e, r) {
  let n = t.trim(), i = r;
  t === r && r.match(/\s/) && (n = void 0);
  function s(h) {
    const f = { boolean: {}, number: {}, string: {} }, d = [];
    let p;
    return { nodeList: h.filter(function(_) {
      const v = typeof _;
      return _.stmt && _.stmt === "dir" ? (p = _.value, !1) : _.trim() === "" ? !1 : v in f ? f[v].hasOwnProperty(_) ? !1 : f[v][_] = !0 : d.includes(_) ? !1 : d.push(_);
    }), dir: p };
  }
  let a = [];
  const { nodeList: o, dir: l } = s(a.concat.apply(a, e));
  if (a = o, Jc === "gen-1")
    for (let h = 0; h < a.length; h++)
      a[h] = _o(a[h]);
  n = n || "subGraph" + cl, i = i || "", i = eu(i), cl = cl + 1;
  const u = { id: n, nodes: a, title: i.trim(), classes: [], dir: l };
  return B.info("Adding", u.id, u.nodes, u.dir), u.nodes = m3(u, Qn).nodes, Qn.push(u), lc[n] = u, n;
}, iF = function(t) {
  for (const [e, r] of Qn.entries())
    if (r.id === t)
      return e;
  return -1;
};
let va = -1;
const c3 = [], u3 = function(t, e) {
  const r = Qn[e].nodes;
  if (va = va + 1, va > 2e3)
    return;
  if (c3[va] = e, Qn[e].id === t)
    return {
      result: !0,
      count: 0
    };
  let n = 0, i = 1;
  for (; n < r.length; ) {
    const s = iF(r[n]);
    if (s >= 0) {
      const a = u3(t, s);
      if (a.result)
        return {
          result: !0,
          count: i + a.count
        };
      i = i + a.count;
    }
    n = n + 1;
  }
  return {
    result: !1,
    count: i
  };
}, h3 = function(t) {
  return c3[t];
}, f3 = function() {
  va = -1, Qn.length > 0 && u3("none", Qn.length - 1);
}, d3 = function() {
  return Qn;
}, p3 = () => jh ? (jh = !1, !0) : !1, sF = (t) => {
  let e = t.trim(), r = "arrow_open";
  switch (e[0]) {
    case "<":
      r = "arrow_point", e = e.slice(1);
      break;
    case "x":
      r = "arrow_cross", e = e.slice(1);
      break;
    case "o":
      r = "arrow_circle", e = e.slice(1);
      break;
  }
  let n = "normal";
  return e.includes("=") && (n = "thick"), e.includes(".") && (n = "dotted"), { type: r, stroke: n };
}, aF = (t, e) => {
  const r = e.length;
  let n = 0;
  for (let i = 0; i < r; ++i)
    e[i] === t && ++n;
  return n;
}, oF = (t) => {
  const e = t.trim();
  let r = e.slice(0, -1), n = "arrow_open";
  switch (e.slice(-1)) {
    case "x":
      n = "arrow_cross", e[0] === "x" && (n = "double_" + n, r = r.slice(1));
      break;
    case ">":
      n = "arrow_point", e[0] === "<" && (n = "double_" + n, r = r.slice(1));
      break;
    case "o":
      n = "arrow_circle", e[0] === "o" && (n = "double_" + n, r = r.slice(1));
      break;
  }
  let i = "normal", s = r.length - 1;
  r[0] === "=" && (i = "thick");
  let a = aF(".", r);
  return a && (i = "dotted", s = a), { type: n, stroke: i, length: s };
}, g3 = (t, e) => {
  const r = oF(t);
  let n;
  if (e) {
    if (n = sF(e), n.stroke !== r.stroke)
      return { type: "INVALID", stroke: "INVALID" };
    if (n.type === "arrow_open")
      n.type = r.type;
    else {
      if (n.type !== r.type)
        return { type: "INVALID", stroke: "INVALID" };
      n.type = "double_" + n.type;
    }
    return n.type === "double_arrow" && (n.type = "double_arrow_point"), n.length = r.length, n;
  }
  return r;
}, y3 = (t, e) => {
  let r = !1;
  return t.forEach((n) => {
    n.nodes.indexOf(e) >= 0 && (r = !0);
  }), r;
}, m3 = (t, e) => {
  const r = [];
  return t.nodes.forEach((n, i) => {
    y3(e, n) || r.push(t.nodes[i]);
  }), { nodes: r };
}, b3 = {
  firstGraph: p3
}, gn = {
  parseDirective: Um,
  defaultConfig: () => Fs.flowchart,
  setAccTitle: Tr,
  getAccTitle: Dr,
  getAccDescription: Mr,
  setAccDescription: Ir,
  addVertex: Wm,
  lookUpDomId: _o,
  addLink: Gm,
  updateLinkInterpolate: qm,
  updateLink: $m,
  addClass: jm,
  setDirection: Xm,
  setClass: ru,
  setTooltip: rF,
  getTooltip: Zm,
  setClickEvent: Qm,
  setLink: Km,
  bindFunctions: Jm,
  getDirection: t3,
  getVertices: e3,
  getEdges: r3,
  getClasses: n3,
  clear: s3,
  setGen: a3,
  defaultStyle: o3,
  addSubGraph: l3,
  getDepthFirstPos: h3,
  indexNodes: f3,
  getSubGraphs: d3,
  destructLink: g3,
  lex: b3,
  exists: y3,
  makeUniq: m3,
  setDiagramTitle: un,
  getDiagramTitle: hn
}, fU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addClass: jm,
  addLink: Gm,
  addSingleLink: Hm,
  addSubGraph: l3,
  addVertex: Wm,
  bindFunctions: Jm,
  clear: s3,
  default: gn,
  defaultStyle: o3,
  destructLink: g3,
  firstGraph: p3,
  getClasses: n3,
  getDepthFirstPos: h3,
  getDirection: t3,
  getEdges: r3,
  getSubGraphs: d3,
  getTooltip: Zm,
  getVertices: e3,
  indexNodes: f3,
  lex: b3,
  lookUpDomId: _o,
  parseDirective: Um,
  setClass: ru,
  setClickEvent: Qm,
  setDirection: Xm,
  setGen: a3,
  setLink: Km,
  updateLink: $m,
  updateLinkInterpolate: qm
}, Symbol.toStringTag, { value: "Module" }));
function _3(t, e) {
  return !!t.children(e).length;
}
function x3(t) {
  return Xu(t.v) + ":" + Xu(t.w) + ":" + Xu(t.name);
}
var lF = /:/g;
function Xu(t) {
  return t ? String(t).replace(lF, "\\:") : "";
}
function En(t, e) {
  e && t.attr("style", e);
}
function v3(t, e, r) {
  e && t.attr("class", e).attr("class", r + " " + t.attr("class"));
}
function sn(t, e) {
  var r = e.graph();
  if (Hy(r)) {
    var n = r.transition;
    if (Ns(n))
      return n(t);
  }
  return t;
}
var Xh = {
  normal: uF,
  vee: hF,
  undirected: fF
};
function cF(t) {
  Xh = t;
}
function uF(t, e, r, n) {
  var i = t.append("marker").attr("id", e).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto"), s = i.append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  En(s, r[n + "Style"]), r[n + "Class"] && s.attr("class", r[n + "Class"]);
}
function hF(t, e, r, n) {
  var i = t.append("marker").attr("id", e).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto"), s = i.append("path").attr("d", "M 0 0 L 10 5 L 0 10 L 4 5 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  En(s, r[n + "Style"]), r[n + "Class"] && s.attr("class", r[n + "Class"]);
}
function fF(t, e, r, n) {
  var i = t.append("marker").attr("id", e).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto"), s = i.append("path").attr("d", "M 0 5 L 10 5").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  En(s, r[n + "Style"]), r[n + "Class"] && s.attr("class", r[n + "Class"]);
}
function N0(t, e) {
  var r = t.append("foreignObject").attr("width", "100000"), n = r.append("xhtml:div");
  n.attr("xmlns", "http://www.w3.org/1999/xhtml");
  var i = e.label;
  switch (typeof i) {
    case "function":
      n.insert(i);
      break;
    case "object":
      n.insert(function() {
        return i;
      });
      break;
    default:
      n.html(i);
  }
  En(n, e.labelStyle), n.style("display", "inline-block"), n.style("white-space", "nowrap");
  var s = n.node().getBoundingClientRect();
  return r.attr("width", s.width).attr("height", s.height), r;
}
function dF(t, e) {
  var r = t;
  return r.node().appendChild(e.label), En(r, e.labelStyle), r;
}
function pF(t, e) {
  for (var r = t.append("text"), n = gF(e.label).split(`
`), i = 0; i < n.length; i++)
    r.append("tspan").attr("xml:space", "preserve").attr("dy", "1em").attr("x", "1").text(n[i]);
  return En(r, e.labelStyle), r;
}
function gF(t) {
  for (var e = "", r = !1, n, i = 0; i < t.length; ++i)
    if (n = t[i], r) {
      switch (n) {
        case "n":
          e += `
`;
          break;
        default:
          e += n;
      }
      r = !1;
    } else
      n === "\\" ? r = !0 : e += n;
  return e;
}
function R0(t, e, r) {
  var n = e.label, i = t.append("g");
  e.labelType === "svg" ? dF(i, e) : typeof n != "string" || e.labelType === "html" ? N0(i, e) : pF(i, e);
  var s = i.node().getBBox(), a;
  switch (r) {
    case "top":
      a = -e.height / 2;
      break;
    case "bottom":
      a = e.height / 2 - s.height;
      break;
    default:
      a = -s.height / 2;
  }
  return i.attr("transform", "translate(" + -s.width / 2 + "," + a + ")"), i;
}
var Kh = function(t, e) {
  var r = e.nodes().filter(function(s) {
    return _3(e, s);
  }), n = t.selectAll("g.cluster").data(r, function(s) {
    return s;
  });
  sn(n.exit(), e).style("opacity", 0).remove();
  var i = n.enter().append("g").attr("class", "cluster").attr("id", function(s) {
    var a = e.node(s);
    return a.id;
  }).style("opacity", 0).each(function(s) {
    var a = e.node(s), o = _t(this);
    _t(this).append("rect");
    var l = o.append("g").attr("class", "label");
    R0(l, a, a.clusterLabelPos);
  });
  return n = n.merge(i), n = sn(n, e).style("opacity", 1), n.selectAll("rect").each(function(s) {
    var a = e.node(s), o = _t(this);
    En(o, a.style);
  }), n;
};
function yF(t) {
  Kh = t;
}
let Zh = function(t, e) {
  var r = t.selectAll("g.edgeLabel").data(e.edges(), function(i) {
    return x3(i);
  }).classed("update", !0);
  r.exit().remove(), r.enter().append("g").classed("edgeLabel", !0).style("opacity", 0), r = t.selectAll("g.edgeLabel"), r.each(function(i) {
    var s = _t(this);
    s.select(".label").remove();
    var a = e.edge(i), o = R0(s, e.edge(i), 0).classed("label", !0), l = o.node().getBBox();
    a.labelId && o.attr("id", a.labelId), Qt(a, "width") || (a.width = l.width), Qt(a, "height") || (a.height = l.height);
  });
  var n;
  return r.exit ? n = r.exit() : n = r.selectAll(null), sn(n, e).style("opacity", 0).remove(), r;
};
function mF(t) {
  Zh = t;
}
function C2(t, e) {
  return t.intersect(e);
}
var Qh = function(t, e, r) {
  var n = t.selectAll("g.edgePath").data(e.edges(), function(a) {
    return x3(a);
  }).classed("update", !0), i = kF(n, e);
  wF(n, e);
  var s = n.merge !== void 0 ? n.merge(i) : n;
  return sn(s, e).style("opacity", 1), s.each(function(a) {
    var o = _t(this), l = e.edge(a);
    l.elem = this, l.id && o.attr("id", l.id), v3(
      o,
      l.class,
      (o.classed("update") ? "update " : "") + "edgePath"
    );
  }), s.selectAll("path.path").each(function(a) {
    var o = e.edge(a);
    o.arrowheadId = Zc("arrowhead");
    var l = _t(this).attr("marker-end", function() {
      return "url(" + _F(location.href, o.arrowheadId) + ")";
    }).style("fill", "none");
    sn(l, e).attr("d", function(u) {
      return xF(e, u);
    }), En(l, o.style);
  }), s.selectAll("defs *").remove(), s.selectAll("defs").each(function(a) {
    var o = e.edge(a), l = r[o.arrowhead];
    l(_t(this), o.arrowheadId, o, "arrowhead");
  }), s;
};
function bF(t) {
  Qh = t;
}
function _F(t, e) {
  var r = t.split("#")[0];
  return r + "#" + e;
}
function xF(t, e) {
  var r = t.edge(e), n = t.node(e.v), i = t.node(e.w), s = r.points.slice(1, r.points.length - 1);
  return s.unshift(C2(n, s[0])), s.push(C2(i, s[s.length - 1])), k3(r, s);
}
function k3(t, e) {
  var r = (js || g6.line)().x(function(n) {
    return n.x;
  }).y(function(n) {
    return n.y;
  });
  return (r.curve || r.interpolate)(t.curve), r(e);
}
function vF(t) {
  var e = t.getBBox(), r = t.ownerSVGElement.getScreenCTM().inverse().multiply(t.getScreenCTM()).translate(e.width / 2, e.height / 2);
  return { x: r.e, y: r.f };
}
function kF(t, e) {
  var r = t.enter().append("g").attr("class", "edgePath").style("opacity", 0);
  return r.append("path").attr("class", "path").attr("d", function(n) {
    var i = e.edge(n), s = e.node(n.v).elem, a = Hi(i.points.length).map(function() {
      return vF(s);
    });
    return k3(i, a);
  }), r.append("defs"), r;
}
function wF(t, e) {
  var r = t.exit();
  sn(r, e).style("opacity", 0).remove();
}
var Jh = function(t, e, r) {
  var n = e.nodes().filter(function(a) {
    return !_3(e, a);
  }), i = t.selectAll("g.node").data(n, function(a) {
    return a;
  }).classed("update", !0);
  i.exit().remove(), i.enter().append("g").attr("class", "node").style("opacity", 0), i = t.selectAll("g.node"), i.each(function(a) {
    var o = e.node(a), l = _t(this);
    v3(
      l,
      o.class,
      (l.classed("update") ? "update " : "") + "node"
    ), l.select("g.label").remove();
    var u = l.append("g").attr("class", "label"), h = R0(u, o), f = r[o.shape], d = Ja(h.node().getBBox(), "width", "height");
    o.elem = this, o.id && l.attr("id", o.id), o.labelId && u.attr("id", o.labelId), Qt(o, "width") && (d.width = o.width), Qt(o, "height") && (d.height = o.height), d.width += o.paddingLeft + o.paddingRight, d.height += o.paddingTop + o.paddingBottom, u.attr(
      "transform",
      "translate(" + (o.paddingLeft - o.paddingRight) / 2 + "," + (o.paddingTop - o.paddingBottom) / 2 + ")"
    );
    var p = _t(this);
    p.select(".label-container").remove();
    var m = f(p, d, o).classed("label-container", !0);
    En(m, o.style);
    var _ = m.node().getBBox();
    o.width = _.width, o.height = _.height;
  });
  var s;
  return i.exit ? s = i.exit() : s = i.selectAll(null), sn(s, e).style("opacity", 0).remove(), i;
};
function TF(t) {
  Jh = t;
}
function EF(t, e) {
  var r = t.filter(function() {
    return !_t(this).classed("update");
  });
  function n(i) {
    var s = e.node(i);
    return "translate(" + s.x + "," + s.y + ")";
  }
  r.attr("transform", n), sn(t, e).style("opacity", 1).attr("transform", n), sn(r.selectAll("rect"), e).attr("width", function(i) {
    return e.node(i).width;
  }).attr("height", function(i) {
    return e.node(i).height;
  }).attr("x", function(i) {
    var s = e.node(i);
    return -s.width / 2;
  }).attr("y", function(i) {
    var s = e.node(i);
    return -s.height / 2;
  });
}
function CF(t, e) {
  var r = t.filter(function() {
    return !_t(this).classed("update");
  });
  function n(i) {
    var s = e.edge(i);
    return Qt(s, "x") ? "translate(" + s.x + "," + s.y + ")" : "";
  }
  r.attr("transform", n), sn(t, e).style("opacity", 1).attr("transform", n);
}
function SF(t, e) {
  var r = t.filter(function() {
    return !_t(this).classed("update");
  });
  function n(i) {
    var s = e.node(i);
    return "translate(" + s.x + "," + s.y + ")";
  }
  r.attr("transform", n), sn(t, e).style("opacity", 1).attr("transform", n);
}
function w3(t, e, r, n) {
  var i = t.x, s = t.y, a = i - n.x, o = s - n.y, l = Math.sqrt(e * e * o * o + r * r * a * a), u = Math.abs(e * r * a / l);
  n.x < i && (u = -u);
  var h = Math.abs(e * r * o / l);
  return n.y < s && (h = -h), { x: i + u, y: s + h };
}
function AF(t, e, r) {
  return w3(t, e, e, r);
}
function LF(t, e, r, n) {
  var i, s, a, o, l, u, h, f, d, p, m, _, v, k, x;
  if (i = e.y - t.y, a = t.x - e.x, l = e.x * t.y - t.x * e.y, d = i * r.x + a * r.y + l, p = i * n.x + a * n.y + l, !(d !== 0 && p !== 0 && S2(d, p)) && (s = n.y - r.y, o = r.x - n.x, u = n.x * r.y - r.x * n.y, h = s * t.x + o * t.y + u, f = s * e.x + o * e.y + u, !(h !== 0 && f !== 0 && S2(h, f)) && (m = i * o - s * a, m !== 0)))
    return _ = Math.abs(m / 2), v = a * u - o * l, k = v < 0 ? (v - _) / m : (v + _) / m, v = s * l - i * u, x = v < 0 ? (v - _) / m : (v + _) / m, { x: k, y: x };
}
function S2(t, e) {
  return t * e > 0;
}
function Cn(t, e, r) {
  var n = t.x, i = t.y, s = [], a = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;
  e.forEach(function(m) {
    a = Math.min(a, m.x), o = Math.min(o, m.y);
  });
  for (var l = n - t.width / 2 - a, u = i - t.height / 2 - o, h = 0; h < e.length; h++) {
    var f = e[h], d = e[h < e.length - 1 ? h + 1 : 0], p = LF(
      t,
      r,
      { x: l + f.x, y: u + f.y },
      { x: l + d.x, y: u + d.y }
    );
    p && s.push(p);
  }
  return s.length ? (s.length > 1 && s.sort(function(m, _) {
    var v = m.x - r.x, k = m.y - r.y, x = Math.sqrt(v * v + k * k), D = _.x - r.x, F = _.y - r.y, P = Math.sqrt(D * D + F * F);
    return x < P ? -1 : x === P ? 0 : 1;
  }), s[0]) : (console.log("NO INTERSECTION FOUND, RETURN NODE CENTER", t), t);
}
function F0(t, e) {
  var r = t.x, n = t.y, i = e.x - r, s = e.y - n, a = t.width / 2, o = t.height / 2, l, u;
  return Math.abs(s) * a > Math.abs(i) * o ? (s < 0 && (o = -o), l = s === 0 ? 0 : o * i / s, u = o) : (i < 0 && (a = -a), l = a, u = i === 0 ? 0 : a * s / i), { x: r + l, y: n + u };
}
var t1 = {
  rect: DF,
  ellipse: IF,
  circle: MF,
  diamond: NF
};
function BF(t) {
  t1 = t;
}
function DF(t, e, r) {
  var n = t.insert("rect", ":first-child").attr("rx", r.rx).attr("ry", r.ry).attr("x", -e.width / 2).attr("y", -e.height / 2).attr("width", e.width).attr("height", e.height);
  return r.intersect = function(i) {
    return F0(r, i);
  }, n;
}
function IF(t, e, r) {
  var n = e.width / 2, i = e.height / 2, s = t.insert("ellipse", ":first-child").attr("x", -e.width / 2).attr("y", -e.height / 2).attr("rx", n).attr("ry", i);
  return r.intersect = function(a) {
    return w3(r, n, i, a);
  }, s;
}
function MF(t, e, r) {
  var n = Math.max(e.width, e.height) / 2, i = t.insert("circle", ":first-child").attr("x", -e.width / 2).attr("y", -e.height / 2).attr("r", n);
  return r.intersect = function(s) {
    return AF(r, n, s);
  }, i;
}
function NF(t, e, r) {
  var n = e.width * Math.SQRT2 / 2, i = e.height * Math.SQRT2 / 2, s = [
    { x: 0, y: -i },
    { x: -n, y: 0 },
    { x: 0, y: i },
    { x: n, y: 0 }
  ], a = t.insert("polygon", ":first-child").attr(
    "points",
    s.map(function(o) {
      return o.x + "," + o.y;
    }).join(" ")
  );
  return r.intersect = function(o) {
    return Cn(r, s, o);
  }, a;
}
function RF() {
  var t = function(e, r) {
    PF(r);
    var n = fa(e, "output"), i = fa(n, "clusters"), s = fa(n, "edgePaths"), a = Zh(fa(n, "edgeLabels"), r), o = Jh(fa(n, "nodes"), r, t1);
    ta(r), SF(o, r), CF(a, r), Qh(s, r, Xh);
    var l = Kh(i, r);
    EF(l, r), VF(r);
  };
  return t.createNodes = function(e) {
    return arguments.length ? (TF(e), t) : Jh;
  }, t.createClusters = function(e) {
    return arguments.length ? (yF(e), t) : Kh;
  }, t.createEdgeLabels = function(e) {
    return arguments.length ? (mF(e), t) : Zh;
  }, t.createEdgePaths = function(e) {
    return arguments.length ? (bF(e), t) : Qh;
  }, t.shapes = function(e) {
    return arguments.length ? (BF(e), t) : t1;
  }, t.arrows = function(e) {
    return arguments.length ? (cF(e), t) : Xh;
  }, t;
}
var FF = {
  paddingLeft: 10,
  paddingRight: 10,
  paddingTop: 10,
  paddingBottom: 10,
  rx: 0,
  ry: 0,
  shape: "rect"
}, OF = {
  arrowhead: "normal",
  curve: Ar
};
function PF(t) {
  t.nodes().forEach(function(e) {
    var r = t.node(e);
    !Qt(r, "label") && !t.children(e).length && (r.label = e), Qt(r, "paddingX") && ls(r, {
      paddingLeft: r.paddingX,
      paddingRight: r.paddingX
    }), Qt(r, "paddingY") && ls(r, {
      paddingTop: r.paddingY,
      paddingBottom: r.paddingY
    }), Qt(r, "padding") && ls(r, {
      paddingLeft: r.padding,
      paddingRight: r.padding,
      paddingTop: r.padding,
      paddingBottom: r.padding
    }), ls(r, FF), dt(["paddingLeft", "paddingRight", "paddingTop", "paddingBottom"], function(n) {
      r[n] = Number(r[n]);
    }), Qt(r, "width") && (r._prevWidth = r.width), Qt(r, "height") && (r._prevHeight = r.height);
  }), t.edges().forEach(function(e) {
    var r = t.edge(e);
    Qt(r, "label") || (r.label = ""), ls(r, OF);
  });
}
function VF(t) {
  dt(t.nodes(), function(e) {
    var r = t.node(e);
    Qt(r, "_prevWidth") ? r.width = r._prevWidth : delete r.width, Qt(r, "_prevHeight") ? r.height = r._prevHeight : delete r.height, delete r._prevWidth, delete r._prevHeight;
  });
}
function fa(t, e) {
  var r = t.select("g." + e);
  return r.empty() && (r = t.append("g").attr("class", e)), r;
}
function T3(t, e, r) {
  const n = e.width, i = e.height, s = (n + i) * 0.9, a = [
    { x: s / 2, y: 0 },
    { x: s, y: -s / 2 },
    { x: s / 2, y: -s },
    { x: 0, y: -s / 2 }
  ], o = ni(t, s, s, a);
  return r.intersect = function(l) {
    return Cn(r, a, l);
  }, o;
}
function E3(t, e, r) {
  const i = e.height, s = i / 4, a = e.width + 2 * s, o = [
    { x: s, y: 0 },
    { x: a - s, y: 0 },
    { x: a, y: -i / 2 },
    { x: a - s, y: -i },
    { x: s, y: -i },
    { x: 0, y: -i / 2 }
  ], l = ni(t, a, i, o);
  return r.intersect = function(u) {
    return Cn(r, o, u);
  }, l;
}
function C3(t, e, r) {
  const n = e.width, i = e.height, s = [
    { x: -i / 2, y: 0 },
    { x: n, y: 0 },
    { x: n, y: -i },
    { x: -i / 2, y: -i },
    { x: 0, y: -i / 2 }
  ], a = ni(t, n, i, s);
  return r.intersect = function(o) {
    return Cn(r, s, o);
  }, a;
}
function S3(t, e, r) {
  const n = e.width, i = e.height, s = [
    { x: -2 * i / 6, y: 0 },
    { x: n - i / 6, y: 0 },
    { x: n + 2 * i / 6, y: -i },
    { x: i / 6, y: -i }
  ], a = ni(t, n, i, s);
  return r.intersect = function(o) {
    return Cn(r, s, o);
  }, a;
}
function A3(t, e, r) {
  const n = e.width, i = e.height, s = [
    { x: 2 * i / 6, y: 0 },
    { x: n + i / 6, y: 0 },
    { x: n - 2 * i / 6, y: -i },
    { x: -i / 6, y: -i }
  ], a = ni(t, n, i, s);
  return r.intersect = function(o) {
    return Cn(r, s, o);
  }, a;
}
function L3(t, e, r) {
  const n = e.width, i = e.height, s = [
    { x: -2 * i / 6, y: 0 },
    { x: n + 2 * i / 6, y: 0 },
    { x: n - i / 6, y: -i },
    { x: i / 6, y: -i }
  ], a = ni(t, n, i, s);
  return r.intersect = function(o) {
    return Cn(r, s, o);
  }, a;
}
function B3(t, e, r) {
  const n = e.width, i = e.height, s = [
    { x: i / 6, y: 0 },
    { x: n - i / 6, y: 0 },
    { x: n + 2 * i / 6, y: -i },
    { x: -2 * i / 6, y: -i }
  ], a = ni(t, n, i, s);
  return r.intersect = function(o) {
    return Cn(r, s, o);
  }, a;
}
function D3(t, e, r) {
  const n = e.width, i = e.height, s = [
    { x: 0, y: 0 },
    { x: n + i / 2, y: 0 },
    { x: n, y: -i / 2 },
    { x: n + i / 2, y: -i },
    { x: 0, y: -i }
  ], a = ni(t, n, i, s);
  return r.intersect = function(o) {
    return Cn(r, s, o);
  }, a;
}
function I3(t, e, r) {
  const n = e.height, i = e.width + n / 4, s = t.insert("rect", ":first-child").attr("rx", n / 2).attr("ry", n / 2).attr("x", -i / 2).attr("y", -n / 2).attr("width", i).attr("height", n);
  return r.intersect = function(a) {
    return F0(r, a);
  }, s;
}
function M3(t, e, r) {
  const n = e.width, i = e.height, s = [
    { x: 0, y: 0 },
    { x: n, y: 0 },
    { x: n, y: -i },
    { x: 0, y: -i },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: n + 8, y: 0 },
    { x: n + 8, y: -i },
    { x: -8, y: -i },
    { x: -8, y: 0 }
  ], a = ni(t, n, i, s);
  return r.intersect = function(o) {
    return Cn(r, s, o);
  }, a;
}
function N3(t, e, r) {
  const n = e.width, i = n / 2, s = i / (2.5 + n / 50), a = e.height + s, o = "M 0," + s + " a " + i + "," + s + " 0,0,0 " + n + " 0 a " + i + "," + s + " 0,0,0 " + -n + " 0 l 0," + a + " a " + i + "," + s + " 0,0,0 " + n + " 0 l 0," + -a, l = t.attr("label-offset-y", s).insert("path", ":first-child").attr("d", o).attr("transform", "translate(" + -n / 2 + "," + -(a / 2 + s) + ")");
  return r.intersect = function(u) {
    const h = F0(r, u), f = h.x - r.x;
    if (i != 0 && (Math.abs(f) < r.width / 2 || Math.abs(f) == r.width / 2 && Math.abs(h.y - r.y) > r.height / 2 - s)) {
      let d = s * s * (1 - f * f / (i * i));
      d != 0 && (d = Math.sqrt(d)), d = s - d, u.y - r.y > 0 && (d = -d), h.y += d;
    }
    return h;
  }, l;
}
function YF(t) {
  t.shapes().question = T3, t.shapes().hexagon = E3, t.shapes().stadium = I3, t.shapes().subroutine = M3, t.shapes().cylinder = N3, t.shapes().rect_left_inv_arrow = C3, t.shapes().lean_right = S3, t.shapes().lean_left = A3, t.shapes().trapezoid = L3, t.shapes().inv_trapezoid = B3, t.shapes().rect_right_inv_arrow = D3;
}
function zF(t) {
  t({ question: T3 }), t({ hexagon: E3 }), t({ stadium: I3 }), t({ subroutine: M3 }), t({ cylinder: N3 }), t({ rect_left_inv_arrow: C3 }), t({ lean_right: S3 }), t({ lean_left: A3 }), t({ trapezoid: L3 }), t({ inv_trapezoid: B3 }), t({ rect_right_inv_arrow: D3 });
}
function ni(t, e, r, n) {
  return t.insert("polygon", ":first-child").attr(
    "points",
    n.map(function(i) {
      return i.x + "," + i.y;
    }).join(" ")
  ).attr("transform", "translate(" + -e / 2 + "," + r / 2 + ")");
}
const UF = {
  addToRender: YF,
  addToRenderV2: zF
}, R3 = {}, WF = function(t) {
  const e = Object.keys(t);
  for (const r of e)
    R3[r] = t[r];
}, F3 = function(t, e, r, n, i, s) {
  const a = n ? n.select(`[id="${r}"]`) : _t(`[id="${r}"]`), o = i || document;
  Object.keys(t).forEach(function(u) {
    const h = t[u];
    let f = "default";
    h.classes.length > 0 && (f = h.classes.join(" "));
    const d = yi(h.styles);
    let p = h.text !== void 0 ? h.text : h.id, m;
    if (Ke(q().flowchart.htmlLabels)) {
      const k = {
        label: p.replace(
          /fa[blrs]?:fa-[\w-]+/g,
          (x) => `<i class='${x.replace(":", " ")}'></i>`
        )
      };
      m = N0(a, k).node(), m.parentNode.removeChild(m);
    } else {
      const k = o.createElementNS("http://www.w3.org/2000/svg", "text");
      k.setAttribute("style", d.labelStyle.replace("color:", "fill:"));
      const x = p.split(Xt.lineBreakRegex);
      for (const D of x) {
        const F = o.createElementNS("http://www.w3.org/2000/svg", "tspan");
        F.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), F.setAttribute("dy", "1em"), F.setAttribute("x", "1"), F.textContent = D, k.appendChild(F);
      }
      m = k;
    }
    let _ = 0, v = "";
    switch (h.type) {
      case "round":
        _ = 5, v = "rect";
        break;
      case "square":
        v = "rect";
        break;
      case "diamond":
        v = "question";
        break;
      case "hexagon":
        v = "hexagon";
        break;
      case "odd":
        v = "rect_left_inv_arrow";
        break;
      case "lean_right":
        v = "lean_right";
        break;
      case "lean_left":
        v = "lean_left";
        break;
      case "trapezoid":
        v = "trapezoid";
        break;
      case "inv_trapezoid":
        v = "inv_trapezoid";
        break;
      case "odd_right":
        v = "rect_left_inv_arrow";
        break;
      case "circle":
        v = "circle";
        break;
      case "ellipse":
        v = "ellipse";
        break;
      case "stadium":
        v = "stadium";
        break;
      case "subroutine":
        v = "subroutine";
        break;
      case "cylinder":
        v = "cylinder";
        break;
      case "group":
        v = "rect";
        break;
      default:
        v = "rect";
    }
    B.warn("Adding node", h.id, h.domId), e.setNode(s.db.lookUpDomId(h.id), {
      labelType: "svg",
      labelStyle: d.labelStyle,
      shape: v,
      label: m,
      rx: _,
      ry: _,
      class: f,
      style: d.style,
      id: s.db.lookUpDomId(h.id)
    });
  });
}, O3 = function(t, e, r) {
  let n = 0, i, s;
  if (t.defaultStyle !== void 0) {
    const a = yi(t.defaultStyle);
    i = a.style, s = a.labelStyle;
  }
  t.forEach(function(a) {
    n++;
    var o = "L-" + a.start + "-" + a.end, l = "LS-" + a.start, u = "LE-" + a.end;
    const h = {};
    a.type === "arrow_open" ? h.arrowhead = "none" : h.arrowhead = "normal";
    let f = "", d = "";
    if (a.style !== void 0) {
      const p = yi(a.style);
      f = p.style, d = p.labelStyle;
    } else
      switch (a.stroke) {
        case "normal":
          f = "fill:none", i !== void 0 && (f = i), s !== void 0 && (d = s);
          break;
        case "dotted":
          f = "fill:none;stroke-width:2px;stroke-dasharray:3;";
          break;
        case "thick":
          f = " stroke-width: 3.5px;fill:none";
          break;
      }
    h.style = f, h.labelStyle = d, a.interpolate !== void 0 ? h.curve = Qr(a.interpolate, Ar) : t.defaultInterpolate !== void 0 ? h.curve = Qr(t.defaultInterpolate, Ar) : h.curve = Qr(R3.curve, Ar), a.text === void 0 ? a.style !== void 0 && (h.arrowheadStyle = "fill: #333") : (h.arrowheadStyle = "fill: #333", h.labelpos = "c", Ke(q().flowchart.htmlLabels) ? (h.labelType = "html", h.label = `<span id="L-${o}" class="edgeLabel L-${l}' L-${u}" style="${h.labelStyle}">${a.text.replace(
      /fa[blrs]?:fa-[\w-]+/g,
      (p) => `<i class='${p.replace(":", " ")}'></i>`
    )}</span>`) : (h.labelType = "text", h.label = a.text.replace(Xt.lineBreakRegex, `
`), a.style === void 0 && (h.style = h.style || "stroke: #333; stroke-width: 1.5px;fill:none"), h.labelStyle = h.labelStyle.replace("color:", "fill:"))), h.id = o, h.class = l + " " + u, h.minlen = a.length || 1, e.setEdge(r.db.lookUpDomId(a.start), r.db.lookUpDomId(a.end), h, n);
  });
}, HF = function(t, e) {
  B.info("Extracting classes"), e.db.clear();
  try {
    return e.parse(t), e.db.getClasses();
  } catch (r) {
    return B.error(r), {};
  }
}, GF = function(t, e, r, n) {
  B.info("Drawing flowchart"), n.db.clear();
  const { securityLevel: i, flowchart: s } = q();
  let a;
  i === "sandbox" && (a = _t("#i" + e));
  const o = _t(i === "sandbox" ? a.nodes()[0].contentDocument.body : "body"), l = i === "sandbox" ? a.nodes()[0].contentDocument : document;
  try {
    n.parser.parse(t);
  } catch {
    B.debug("Parsing failed");
  }
  let u = n.db.getDirection();
  u === void 0 && (u = "TD");
  const h = s.nodeSpacing || 50, f = s.rankSpacing || 50, d = new Ve({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: u,
    nodesep: h,
    ranksep: f,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let p;
  const m = n.db.getSubGraphs();
  for (let V = m.length - 1; V >= 0; V--)
    p = m[V], n.db.addVertex(p.id, p.title, "group", void 0, p.classes);
  const _ = n.db.getVertices();
  B.warn("Get vertices", _);
  const v = n.db.getEdges();
  let k = 0;
  for (k = m.length - 1; k >= 0; k--) {
    p = m[k], I1("cluster").append("text");
    for (let V = 0; V < p.nodes.length; V++)
      B.warn(
        "Setting subgraph",
        p.nodes[V],
        n.db.lookUpDomId(p.nodes[V]),
        n.db.lookUpDomId(p.id)
      ), d.setParent(n.db.lookUpDomId(p.nodes[V]), n.db.lookUpDomId(p.id));
  }
  F3(_, d, e, o, l, n), O3(v, d, n);
  const x = new RF();
  UF.addToRender(x), x.arrows().none = function(R, O, C, S) {
    const b = R.append("marker").attr("id", O).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto").append("path").attr("d", "M 0 0 L 0 0 L 0 0 z");
    En(b, C[S + "Style"]);
  }, x.arrows().normal = function(R, O) {
    R.append("marker").attr("id", O).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowheadPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  };
  const D = o.select(`[id="${e}"]`), F = o.select("#" + e + " g");
  for (x(F, d), F.selectAll("g.node").attr("title", function() {
    return n.db.getTooltip(this.id);
  }), n.db.indexNodes("subGraph" + k), k = 0; k < m.length; k++)
    if (p = m[k], p.title !== "undefined") {
      const V = l.querySelectorAll(
        "#" + e + ' [id="' + n.db.lookUpDomId(p.id) + '"] rect'
      ), R = l.querySelectorAll(
        "#" + e + ' [id="' + n.db.lookUpDomId(p.id) + '"]'
      ), O = V[0].x.baseVal.value, C = V[0].y.baseVal.value, S = V[0].width.baseVal.value, b = _t(R[0]).select(".label");
      b.attr("transform", `translate(${O + S / 2}, ${C + 14})`), b.attr("id", e + "Text");
      for (let w = 0; w < p.classes.length; w++)
        R[0].classList.add(p.classes[w]);
    }
  if (!s.htmlLabels) {
    const V = l.querySelectorAll('[id="' + e + '"] .edgeLabel .label');
    for (const R of V) {
      const O = R.getBBox(), C = l.createElementNS("http://www.w3.org/2000/svg", "rect");
      C.setAttribute("rx", 0), C.setAttribute("ry", 0), C.setAttribute("width", O.width), C.setAttribute("height", O.height), R.insertBefore(C, R.firstChild);
    }
  }
  Oc(d, D, s.diagramPadding, s.useMaxWidth), Object.keys(_).forEach(function(V) {
    const R = _[V];
    if (R.link) {
      const O = o.select("#" + e + ' [id="' + n.db.lookUpDomId(V) + '"]');
      if (O) {
        const C = l.createElementNS("http://www.w3.org/2000/svg", "a");
        C.setAttributeNS("http://www.w3.org/2000/svg", "class", R.classes.join(" ")), C.setAttributeNS("http://www.w3.org/2000/svg", "href", R.link), C.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener"), i === "sandbox" ? C.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top") : R.linkTarget && C.setAttributeNS("http://www.w3.org/2000/svg", "target", R.linkTarget);
        const S = O.insert(function() {
          return C;
        }, ":first-child"), T = O.select(".label-container");
        T && S.append(function() {
          return T.node();
        });
        const b = O.select(".label");
        b && S.append(function() {
          return b.node();
        });
      }
    }
  });
}, qF = {
  setConf: WF,
  addVertices: F3,
  addEdges: O3,
  getClasses: HF,
  draw: GF
}, P3 = {}, $F = function(t) {
  const e = Object.keys(t);
  for (const r of e)
    P3[r] = t[r];
}, V3 = function(t, e, r, n, i, s) {
  const a = n.select(`[id="${r}"]`);
  Object.keys(t).forEach(function(l) {
    const u = t[l];
    let h = "default";
    u.classes.length > 0 && (h = u.classes.join(" "));
    const f = yi(u.styles);
    let d = u.text !== void 0 ? u.text : u.id, p;
    if (Ke(q().flowchart.htmlLabels)) {
      const v = {
        label: d.replace(
          /fa[blrs]?:fa-[\w-]+/g,
          (k) => `<i class='${k.replace(":", " ")}'></i>`
        )
      };
      p = N0(a, v).node(), p.parentNode.removeChild(p);
    } else {
      const v = i.createElementNS("http://www.w3.org/2000/svg", "text");
      v.setAttribute("style", f.labelStyle.replace("color:", "fill:"));
      const k = d.split(Xt.lineBreakRegex);
      for (const x of k) {
        const D = i.createElementNS("http://www.w3.org/2000/svg", "tspan");
        D.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), D.setAttribute("dy", "1em"), D.setAttribute("x", "1"), D.textContent = x, v.appendChild(D);
      }
      p = v;
    }
    let m = 0, _ = "";
    switch (u.type) {
      case "round":
        m = 5, _ = "rect";
        break;
      case "square":
        _ = "rect";
        break;
      case "diamond":
        _ = "question";
        break;
      case "hexagon":
        _ = "hexagon";
        break;
      case "odd":
        _ = "rect_left_inv_arrow";
        break;
      case "lean_right":
        _ = "lean_right";
        break;
      case "lean_left":
        _ = "lean_left";
        break;
      case "trapezoid":
        _ = "trapezoid";
        break;
      case "inv_trapezoid":
        _ = "inv_trapezoid";
        break;
      case "odd_right":
        _ = "rect_left_inv_arrow";
        break;
      case "circle":
        _ = "circle";
        break;
      case "ellipse":
        _ = "ellipse";
        break;
      case "stadium":
        _ = "stadium";
        break;
      case "subroutine":
        _ = "subroutine";
        break;
      case "cylinder":
        _ = "cylinder";
        break;
      case "group":
        _ = "rect";
        break;
      case "doublecircle":
        _ = "doublecircle";
        break;
      default:
        _ = "rect";
    }
    e.setNode(u.id, {
      labelStyle: f.labelStyle,
      shape: _,
      labelText: d,
      rx: m,
      ry: m,
      class: h,
      style: f.style,
      id: u.id,
      link: u.link,
      linkTarget: u.linkTarget,
      tooltip: s.db.getTooltip(u.id) || "",
      domId: s.db.lookUpDomId(u.id),
      haveCallback: u.haveCallback,
      width: u.type === "group" ? 500 : void 0,
      dir: u.dir,
      type: u.type,
      props: u.props,
      padding: q().flowchart.padding
    }), B.info("setNode", {
      labelStyle: f.labelStyle,
      shape: _,
      labelText: d,
      rx: m,
      ry: m,
      class: h,
      style: f.style,
      id: u.id,
      domId: s.db.lookUpDomId(u.id),
      width: u.type === "group" ? 500 : void 0,
      type: u.type,
      dir: u.dir,
      props: u.props,
      padding: q().flowchart.padding
    });
  });
}, Y3 = function(t, e, r) {
  B.info("abc78 edges = ", t);
  let n = 0, i = {}, s, a;
  if (t.defaultStyle !== void 0) {
    const o = yi(t.defaultStyle);
    s = o.style, a = o.labelStyle;
  }
  t.forEach(function(o) {
    n++;
    var l = "L-" + o.start + "-" + o.end;
    i[l] === void 0 ? (i[l] = 0, B.info("abc78 new entry", l, i[l])) : (i[l]++, B.info("abc78 new entry", l, i[l]));
    let u = l + "-" + i[l];
    B.info("abc78 new link id to be used is", l, u, i[l]);
    var h = "LS-" + o.start, f = "LE-" + o.end;
    const d = { style: "", labelStyle: "" };
    switch (d.minlen = o.length || 1, o.type === "arrow_open" ? d.arrowhead = "none" : d.arrowhead = "normal", d.arrowTypeStart = "arrow_open", d.arrowTypeEnd = "arrow_open", o.type) {
      case "double_arrow_cross":
        d.arrowTypeStart = "arrow_cross";
      case "arrow_cross":
        d.arrowTypeEnd = "arrow_cross";
        break;
      case "double_arrow_point":
        d.arrowTypeStart = "arrow_point";
      case "arrow_point":
        d.arrowTypeEnd = "arrow_point";
        break;
      case "double_arrow_circle":
        d.arrowTypeStart = "arrow_circle";
      case "arrow_circle":
        d.arrowTypeEnd = "arrow_circle";
        break;
    }
    let p = "", m = "";
    switch (o.stroke) {
      case "normal":
        p = "fill:none;", s !== void 0 && (p = s), a !== void 0 && (m = a), d.thickness = "normal", d.pattern = "solid";
        break;
      case "dotted":
        d.thickness = "normal", d.pattern = "dotted", d.style = "fill:none;stroke-width:2px;stroke-dasharray:3;";
        break;
      case "thick":
        d.thickness = "thick", d.pattern = "solid", d.style = "stroke-width: 3.5px;fill:none;";
        break;
    }
    if (o.style !== void 0) {
      const _ = yi(o.style);
      p = _.style, m = _.labelStyle;
    }
    d.style = d.style += p, d.labelStyle = d.labelStyle += m, o.interpolate !== void 0 ? d.curve = Qr(o.interpolate, Ar) : t.defaultInterpolate !== void 0 ? d.curve = Qr(t.defaultInterpolate, Ar) : d.curve = Qr(P3.curve, Ar), o.text === void 0 ? o.style !== void 0 && (d.arrowheadStyle = "fill: #333") : (d.arrowheadStyle = "fill: #333", d.labelpos = "c"), d.labelType = "text", d.label = o.text.replace(Xt.lineBreakRegex, `
`), o.style === void 0 && (d.style = d.style || "stroke: #333; stroke-width: 1.5px;fill:none;"), d.labelStyle = d.labelStyle.replace("color:", "fill:"), d.id = u, d.classes = "flowchart-link " + h + " " + f, e.setEdge(o.start, o.end, d, n);
  });
}, jF = function(t, e) {
  B.info("Extracting classes"), e.db.clear();
  try {
    return e.parse(t), e.db.getClasses();
  } catch {
    return;
  }
}, XF = function(t, e, r, n) {
  B.info("Drawing flowchart"), n.db.clear(), gn.setGen("gen-2"), n.parser.parse(t);
  let i = n.db.getDirection();
  i === void 0 && (i = "TD");
  const { securityLevel: s, flowchart: a } = q(), o = a.nodeSpacing || 50, l = a.rankSpacing || 50;
  let u;
  s === "sandbox" && (u = _t("#i" + e));
  const h = _t(s === "sandbox" ? u.nodes()[0].contentDocument.body : "body"), f = s === "sandbox" ? u.nodes()[0].contentDocument : document, d = new Ve({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: i,
    nodesep: o,
    ranksep: l,
    marginx: 0,
    marginy: 0
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let p;
  const m = n.db.getSubGraphs();
  B.info("Subgraphs - ", m);
  for (let P = m.length - 1; P >= 0; P--)
    p = m[P], B.info("Subgraph - ", p), n.db.addVertex(p.id, p.title, "group", void 0, p.classes, p.dir);
  const _ = n.db.getVertices(), v = n.db.getEdges();
  B.info("Edges", v);
  let k = 0;
  for (k = m.length - 1; k >= 0; k--) {
    p = m[k], I1("cluster").append("text");
    for (let P = 0; P < p.nodes.length; P++)
      B.info("Setting up subgraphs", p.nodes[P], p.id), d.setParent(p.nodes[P], p.id);
  }
  V3(_, d, e, h, f, n), Y3(v, d);
  const x = h.select(`[id="${e}"]`), D = h.select("#" + e + " g");
  if (B0(D, d, ["point", "circle", "cross"], "flowchart", e), jt.insertTitle(x, "flowchartTitleText", a.titleTopMargin, n.db.getDiagramTitle()), Oc(d, x, a.diagramPadding, a.useMaxWidth), n.db.indexNodes("subGraph" + k), !a.htmlLabels) {
    const P = f.querySelectorAll('[id="' + e + '"] .edgeLabel .label');
    for (const V of P) {
      const R = V.getBBox(), O = f.createElementNS("http://www.w3.org/2000/svg", "rect");
      O.setAttribute("rx", 0), O.setAttribute("ry", 0), O.setAttribute("width", R.width), O.setAttribute("height", R.height), V.insertBefore(O, V.firstChild);
    }
  }
  Object.keys(_).forEach(function(P) {
    const V = _[P];
    if (V.link) {
      const R = _t("#" + e + ' [id="' + P + '"]');
      if (R) {
        const O = f.createElementNS("http://www.w3.org/2000/svg", "a");
        O.setAttributeNS("http://www.w3.org/2000/svg", "class", V.classes.join(" ")), O.setAttributeNS("http://www.w3.org/2000/svg", "href", V.link), O.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener"), s === "sandbox" ? O.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top") : V.linkTarget && O.setAttributeNS("http://www.w3.org/2000/svg", "target", V.linkTarget);
        const C = R.insert(function() {
          return O;
        }, ":first-child"), S = R.select(".label-container");
        S && C.append(function() {
          return S.node();
        });
        const T = R.select(".label");
        T && C.append(function() {
          return T.node();
        });
      }
    }
  });
}, Ku = {
  setConf: $F,
  addVertices: V3,
  addEdges: Y3,
  getClasses: jF,
  draw: XF
};
var e1 = function() {
  var t = function(O, C, S, T) {
    for (S = S || {}, T = O.length; T--; S[O[T]] = C)
      ;
    return S;
  }, e = [1, 3], r = [1, 5], n = [7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 25, 26, 28, 35, 40], i = [1, 15], s = [1, 16], a = [1, 17], o = [1, 18], l = [1, 19], u = [1, 20], h = [1, 21], f = [1, 22], d = [1, 23], p = [1, 24], m = [1, 25], _ = [1, 26], v = [1, 27], k = [1, 29], x = [1, 31], D = [1, 34], F = [5, 7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 25, 26, 28, 35, 40], P = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, directive: 4, gantt: 5, document: 6, EOF: 7, line: 8, SPACE: 9, statement: 10, NL: 11, dateFormat: 12, inclusiveEndDates: 13, topAxis: 14, axisFormat: 15, tickInterval: 16, excludes: 17, includes: 18, todayMarker: 19, title: 20, acc_title: 21, acc_title_value: 22, acc_descr: 23, acc_descr_value: 24, acc_descr_multiline_value: 25, section: 26, clickStatement: 27, taskTxt: 28, taskData: 29, openDirective: 30, typeDirective: 31, closeDirective: 32, ":": 33, argDirective: 34, click: 35, callbackname: 36, callbackargs: 37, href: 38, clickStatementDebug: 39, open_directive: 40, type_directive: 41, arg_directive: 42, close_directive: 43, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "gantt", 7: "EOF", 9: "SPACE", 11: "NL", 12: "dateFormat", 13: "inclusiveEndDates", 14: "topAxis", 15: "axisFormat", 16: "tickInterval", 17: "excludes", 18: "includes", 19: "todayMarker", 20: "title", 21: "acc_title", 22: "acc_title_value", 23: "acc_descr", 24: "acc_descr_value", 25: "acc_descr_multiline_value", 26: "section", 28: "taskTxt", 29: "taskData", 33: ":", 35: "click", 36: "callbackname", 37: "callbackargs", 38: "href", 40: "open_directive", 41: "type_directive", 42: "arg_directive", 43: "close_directive" },
    productions_: [0, [3, 2], [3, 3], [6, 0], [6, 2], [8, 2], [8, 1], [8, 1], [8, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [10, 2], [10, 1], [4, 4], [4, 6], [27, 2], [27, 3], [27, 3], [27, 4], [27, 3], [27, 4], [27, 2], [39, 2], [39, 3], [39, 3], [39, 4], [39, 3], [39, 4], [39, 2], [30, 1], [31, 1], [34, 1], [32, 1]],
    performAction: function(C, S, T, b, w, g, M) {
      var y = g.length - 1;
      switch (w) {
        case 2:
          return g[y - 1];
        case 3:
          this.$ = [];
          break;
        case 4:
          g[y - 1].push(g[y]), this.$ = g[y - 1];
          break;
        case 5:
        case 6:
          this.$ = g[y];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 9:
          b.setDateFormat(g[y].substr(11)), this.$ = g[y].substr(11);
          break;
        case 10:
          b.enableInclusiveEndDates(), this.$ = g[y].substr(18);
          break;
        case 11:
          b.TopAxis(), this.$ = g[y].substr(8);
          break;
        case 12:
          b.setAxisFormat(g[y].substr(11)), this.$ = g[y].substr(11);
          break;
        case 13:
          b.setTickInterval(g[y].substr(13)), this.$ = g[y].substr(13);
          break;
        case 14:
          b.setExcludes(g[y].substr(9)), this.$ = g[y].substr(9);
          break;
        case 15:
          b.setIncludes(g[y].substr(9)), this.$ = g[y].substr(9);
          break;
        case 16:
          b.setTodayMarker(g[y].substr(12)), this.$ = g[y].substr(12);
          break;
        case 17:
          b.setDiagramTitle(g[y].substr(6)), this.$ = g[y].substr(6);
          break;
        case 18:
          this.$ = g[y].trim(), b.setAccTitle(this.$);
          break;
        case 19:
        case 20:
          this.$ = g[y].trim(), b.setAccDescription(this.$);
          break;
        case 21:
          b.addSection(g[y].substr(8)), this.$ = g[y].substr(8);
          break;
        case 23:
          b.addTask(g[y - 1], g[y]), this.$ = "task";
          break;
        case 27:
          this.$ = g[y - 1], b.setClickEvent(g[y - 1], g[y], null);
          break;
        case 28:
          this.$ = g[y - 2], b.setClickEvent(g[y - 2], g[y - 1], g[y]);
          break;
        case 29:
          this.$ = g[y - 2], b.setClickEvent(g[y - 2], g[y - 1], null), b.setLink(g[y - 2], g[y]);
          break;
        case 30:
          this.$ = g[y - 3], b.setClickEvent(g[y - 3], g[y - 2], g[y - 1]), b.setLink(g[y - 3], g[y]);
          break;
        case 31:
          this.$ = g[y - 2], b.setClickEvent(g[y - 2], g[y], null), b.setLink(g[y - 2], g[y - 1]);
          break;
        case 32:
          this.$ = g[y - 3], b.setClickEvent(g[y - 3], g[y - 1], g[y]), b.setLink(g[y - 3], g[y - 2]);
          break;
        case 33:
          this.$ = g[y - 1], b.setLink(g[y - 1], g[y]);
          break;
        case 34:
        case 40:
          this.$ = g[y - 1] + " " + g[y];
          break;
        case 35:
        case 36:
        case 38:
          this.$ = g[y - 2] + " " + g[y - 1] + " " + g[y];
          break;
        case 37:
        case 39:
          this.$ = g[y - 3] + " " + g[y - 2] + " " + g[y - 1] + " " + g[y];
          break;
        case 41:
          b.parseDirective("%%{", "open_directive");
          break;
        case 42:
          b.parseDirective(g[y], "type_directive");
          break;
        case 43:
          g[y] = g[y].trim().replace(/'/g, '"'), b.parseDirective(g[y], "arg_directive");
          break;
        case 44:
          b.parseDirective("}%%", "close_directive", "gantt");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: e, 30: 4, 40: r }, { 1: [3] }, { 3: 6, 4: 2, 5: e, 30: 4, 40: r }, t(n, [2, 3], { 6: 7 }), { 31: 8, 41: [1, 9] }, { 41: [2, 41] }, { 1: [2, 1] }, { 4: 30, 7: [1, 10], 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: i, 13: s, 14: a, 15: o, 16: l, 17: u, 18: h, 19: f, 20: d, 21: p, 23: m, 25: _, 26: v, 27: 28, 28: k, 30: 4, 35: x, 40: r }, { 32: 32, 33: [1, 33], 43: D }, t([33, 43], [2, 42]), t(n, [2, 8], { 1: [2, 2] }), t(n, [2, 4]), { 4: 30, 10: 35, 12: i, 13: s, 14: a, 15: o, 16: l, 17: u, 18: h, 19: f, 20: d, 21: p, 23: m, 25: _, 26: v, 27: 28, 28: k, 30: 4, 35: x, 40: r }, t(n, [2, 6]), t(n, [2, 7]), t(n, [2, 9]), t(n, [2, 10]), t(n, [2, 11]), t(n, [2, 12]), t(n, [2, 13]), t(n, [2, 14]), t(n, [2, 15]), t(n, [2, 16]), t(n, [2, 17]), { 22: [1, 36] }, { 24: [1, 37] }, t(n, [2, 20]), t(n, [2, 21]), t(n, [2, 22]), { 29: [1, 38] }, t(n, [2, 24]), { 36: [1, 39], 38: [1, 40] }, { 11: [1, 41] }, { 34: 42, 42: [1, 43] }, { 11: [2, 44] }, t(n, [2, 5]), t(n, [2, 18]), t(n, [2, 19]), t(n, [2, 23]), t(n, [2, 27], { 37: [1, 44], 38: [1, 45] }), t(n, [2, 33], { 36: [1, 46] }), t(F, [2, 25]), { 32: 47, 43: D }, { 43: [2, 43] }, t(n, [2, 28], { 38: [1, 48] }), t(n, [2, 29]), t(n, [2, 31], { 37: [1, 49] }), { 11: [1, 50] }, t(n, [2, 30]), t(n, [2, 32]), t(F, [2, 26])],
    defaultActions: { 5: [2, 41], 6: [2, 1], 34: [2, 44], 43: [2, 43] },
    parseError: function(C, S) {
      if (S.recoverable)
        this.trace(C);
      else {
        var T = new Error(C);
        throw T.hash = S, T;
      }
    },
    parse: function(C) {
      var S = this, T = [0], b = [], w = [null], g = [], M = this.table, y = "", N = 0, it = 0, Y = 2, Z = 1, J = g.slice.call(arguments, 1), X = Object.create(this.lexer), tt = { yy: {} };
      for (var st in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, st) && (tt.yy[st] = this.yy[st]);
      X.setInput(C, tt.yy), tt.yy.lexer = X, tt.yy.parser = this, typeof X.yylloc > "u" && (X.yylloc = {});
      var lt = X.yylloc;
      g.push(lt);
      var U = X.options && X.options.ranges;
      typeof tt.yy.parseError == "function" ? this.parseError = tt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Tt() {
        var Dt;
        return Dt = b.pop() || X.lex() || Z, typeof Dt != "number" && (Dt instanceof Array && (b = Dt, Dt = b.pop()), Dt = S.symbols_[Dt] || Dt), Dt;
      }
      for (var $, j, W, z, A = {}, I, G, L, at; ; ) {
        if (j = T[T.length - 1], this.defaultActions[j] ? W = this.defaultActions[j] : (($ === null || typeof $ > "u") && ($ = Tt()), W = M[j] && M[j][$]), typeof W > "u" || !W.length || !W[0]) {
          var E = "";
          at = [];
          for (I in M[j])
            this.terminals_[I] && I > Y && at.push("'" + this.terminals_[I] + "'");
          X.showPosition ? E = "Parse error on line " + (N + 1) + `:
` + X.showPosition() + `
Expecting ` + at.join(", ") + ", got '" + (this.terminals_[$] || $) + "'" : E = "Parse error on line " + (N + 1) + ": Unexpected " + ($ == Z ? "end of input" : "'" + (this.terminals_[$] || $) + "'"), this.parseError(E, {
            text: X.match,
            token: this.terminals_[$] || $,
            line: X.yylineno,
            loc: lt,
            expected: at
          });
        }
        if (W[0] instanceof Array && W.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + j + ", token: " + $);
        switch (W[0]) {
          case 1:
            T.push($), w.push(X.yytext), g.push(X.yylloc), T.push(W[1]), $ = null, it = X.yyleng, y = X.yytext, N = X.yylineno, lt = X.yylloc;
            break;
          case 2:
            if (G = this.productions_[W[1]][1], A.$ = w[w.length - G], A._$ = {
              first_line: g[g.length - (G || 1)].first_line,
              last_line: g[g.length - 1].last_line,
              first_column: g[g.length - (G || 1)].first_column,
              last_column: g[g.length - 1].last_column
            }, U && (A._$.range = [
              g[g.length - (G || 1)].range[0],
              g[g.length - 1].range[1]
            ]), z = this.performAction.apply(A, [
              y,
              it,
              N,
              tt.yy,
              W[1],
              w,
              g
            ].concat(J)), typeof z < "u")
              return z;
            G && (T = T.slice(0, -1 * G * 2), w = w.slice(0, -1 * G), g = g.slice(0, -1 * G)), T.push(this.productions_[W[1]][0]), w.push(A.$), g.push(A._$), L = M[T[T.length - 2]][T[T.length - 1]], T.push(L);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, V = function() {
    var O = {
      EOF: 1,
      parseError: function(S, T) {
        if (this.yy.parser)
          this.yy.parser.parseError(S, T);
        else
          throw new Error(S);
      },
      // resets the lexer, sets new input
      setInput: function(C, S) {
        return this.yy = S || this.yy || {}, this._input = C, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var C = this._input[0];
        this.yytext += C, this.yyleng++, this.offset++, this.match += C, this.matched += C;
        var S = C.match(/(?:\r\n?|\n).*/g);
        return S ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), C;
      },
      // unshifts one char (or a string) into the input
      unput: function(C) {
        var S = C.length, T = C.split(/(?:\r\n?|\n)/g);
        this._input = C + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - S), this.offset -= S;
        var b = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), T.length - 1 && (this.yylineno -= T.length - 1);
        var w = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: T ? (T.length === b.length ? this.yylloc.first_column : 0) + b[b.length - T.length].length - T[0].length : this.yylloc.first_column - S
        }, this.options.ranges && (this.yylloc.range = [w[0], w[0] + this.yyleng - S]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(C) {
        this.unput(this.match.slice(C));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var C = this.matched.substr(0, this.matched.length - this.match.length);
        return (C.length > 20 ? "..." : "") + C.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var C = this.match;
        return C.length < 20 && (C += this._input.substr(0, 20 - C.length)), (C.substr(0, 20) + (C.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var C = this.pastInput(), S = new Array(C.length + 1).join("-");
        return C + this.upcomingInput() + `
` + S + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(C, S) {
        var T, b, w;
        if (this.options.backtrack_lexer && (w = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (w.yylloc.range = this.yylloc.range.slice(0))), b = C[0].match(/(?:\r\n?|\n).*/g), b && (this.yylineno += b.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: b ? b[b.length - 1].length - b[b.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + C[0].length
        }, this.yytext += C[0], this.match += C[0], this.matches = C, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(C[0].length), this.matched += C[0], T = this.performAction.call(this, this.yy, this, S, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), T)
          return T;
        if (this._backtrack) {
          for (var g in w)
            this[g] = w[g];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var C, S, T, b;
        this._more || (this.yytext = "", this.match = "");
        for (var w = this._currentRules(), g = 0; g < w.length; g++)
          if (T = this._input.match(this.rules[w[g]]), T && (!S || T[0].length > S[0].length)) {
            if (S = T, b = g, this.options.backtrack_lexer) {
              if (C = this.test_match(T, w[g]), C !== !1)
                return C;
              if (this._backtrack) {
                S = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return S ? (C = this.test_match(S, w[b]), C !== !1 ? C : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var S = this.next();
        return S || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(S) {
        this.conditionStack.push(S);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var S = this.conditionStack.length - 1;
        return S > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(S) {
        return S = this.conditionStack.length - 1 - Math.abs(S || 0), S >= 0 ? this.conditionStack[S] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(S) {
        this.begin(S);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(S, T, b, w) {
        switch (b) {
          case 0:
            return this.begin("open_directive"), 40;
          case 1:
            return this.begin("type_directive"), 41;
          case 2:
            return this.popState(), this.begin("arg_directive"), 33;
          case 3:
            return this.popState(), this.popState(), 43;
          case 4:
            return 42;
          case 5:
            return this.begin("acc_title"), 21;
          case 6:
            return this.popState(), "acc_title_value";
          case 7:
            return this.begin("acc_descr"), 23;
          case 8:
            return this.popState(), "acc_descr_value";
          case 9:
            this.begin("acc_descr_multiline");
            break;
          case 10:
            this.popState();
            break;
          case 11:
            return "acc_descr_multiline_value";
          case 12:
            break;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return 11;
          case 16:
            break;
          case 17:
            break;
          case 18:
            break;
          case 19:
            this.begin("href");
            break;
          case 20:
            this.popState();
            break;
          case 21:
            return 38;
          case 22:
            this.begin("callbackname");
            break;
          case 23:
            this.popState();
            break;
          case 24:
            this.popState(), this.begin("callbackargs");
            break;
          case 25:
            return 36;
          case 26:
            this.popState();
            break;
          case 27:
            return 37;
          case 28:
            this.begin("click");
            break;
          case 29:
            this.popState();
            break;
          case 30:
            return 35;
          case 31:
            return 5;
          case 32:
            return 12;
          case 33:
            return 13;
          case 34:
            return 14;
          case 35:
            return 15;
          case 36:
            return 16;
          case 37:
            return 18;
          case 38:
            return 17;
          case 39:
            return 19;
          case 40:
            return "date";
          case 41:
            return 20;
          case 42:
            return "accDescription";
          case 43:
            return 26;
          case 44:
            return 28;
          case 45:
            return 29;
          case 46:
            return 33;
          case 47:
            return 7;
          case 48:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%(?!\{)*[^\n]*)/i, /^(?:[^\}]%%*[^\n]*)/i, /^(?:%%*[^\n]*[\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:href[\s]+["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:call[\s]+)/i, /^(?:\([\s]*\))/i, /^(?:\()/i, /^(?:[^(]*)/i, /^(?:\))/i, /^(?:[^)]*)/i, /^(?:click[\s]+)/i, /^(?:[\s\n])/i, /^(?:[^\s\n]*)/i, /^(?:gantt\b)/i, /^(?:dateFormat\s[^#\n;]+)/i, /^(?:inclusiveEndDates\b)/i, /^(?:topAxis\b)/i, /^(?:axisFormat\s[^#\n;]+)/i, /^(?:tickInterval\s[^#\n;]+)/i, /^(?:includes\s[^#\n;]+)/i, /^(?:excludes\s[^#\n;]+)/i, /^(?:todayMarker\s[^\n;]+)/i, /^(?:\d\d\d\d-\d\d-\d\d\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accDescription\s[^#\n;]+)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [10, 11], inclusive: !1 }, acc_descr: { rules: [8], inclusive: !1 }, acc_title: { rules: [6], inclusive: !1 }, close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, open_directive: { rules: [1], inclusive: !1 }, callbackargs: { rules: [26, 27], inclusive: !1 }, callbackname: { rules: [23, 24, 25], inclusive: !1 }, href: { rules: [20, 21], inclusive: !1 }, click: { rules: [29, 30], inclusive: !1 }, INITIAL: { rules: [0, 5, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 22, 28, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48], inclusive: !0 } }
    };
    return O;
  }();
  P.lexer = V;
  function R() {
    this.yy = {};
  }
  return R.prototype = P, P.Parser = R, new R();
}();
e1.parser = e1;
const KF = e1, ZF = (t) => t.match(/^\s*gantt/) !== null;
var r1 = {}, QF = {
  get exports() {
    return r1;
  },
  set exports(t) {
    r1 = t;
  }
};
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(bc, function() {
    var r = "day";
    return function(n, i, s) {
      var a = function(u) {
        return u.add(4 - u.isoWeekday(), r);
      }, o = i.prototype;
      o.isoWeekYear = function() {
        return a(this).year();
      }, o.isoWeek = function(u) {
        if (!this.$utils().u(u))
          return this.add(7 * (u - this.isoWeek()), r);
        var h, f, d, p, m = a(this), _ = (h = this.isoWeekYear(), f = this.$u, d = (f ? s.utc : s)().year(h).startOf("year"), p = 4 - d.isoWeekday(), d.isoWeekday() > 4 && (p += 7), d.add(p, r));
        return m.diff(_, "week") + 1;
      }, o.isoWeekday = function(u) {
        return this.$utils().u(u) ? this.day() || 7 : this.day(this.day() % 7 ? u : u - 7);
      };
      var l = o.startOf;
      o.startOf = function(u, h) {
        var f = this.$utils(), d = !!f.u(h) || h;
        return f.p(u) === "isoweek" ? d ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : l.bind(this)(u, h);
      };
    };
  });
})(QF);
const JF = r1;
var n1 = {}, tO = {
  get exports() {
    return n1;
  },
  set exports(t) {
    n1 = t;
  }
};
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(bc, function() {
    var r = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, n = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, i = /\d\d/, s = /\d\d?/, a = /\d*[^-_:/,()\s\d]+/, o = {}, l = function(_) {
      return (_ = +_) + (_ > 68 ? 1900 : 2e3);
    }, u = function(_) {
      return function(v) {
        this[_] = +v;
      };
    }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(_) {
      (this.zone || (this.zone = {})).offset = function(v) {
        if (!v || v === "Z")
          return 0;
        var k = v.match(/([+-]|\d\d)/g), x = 60 * k[1] + (+k[2] || 0);
        return x === 0 ? 0 : k[0] === "+" ? -x : x;
      }(_);
    }], f = function(_) {
      var v = o[_];
      return v && (v.indexOf ? v : v.s.concat(v.f));
    }, d = function(_, v) {
      var k, x = o.meridiem;
      if (x) {
        for (var D = 1; D <= 24; D += 1)
          if (_.indexOf(x(D, 0, v)) > -1) {
            k = D > 12;
            break;
          }
      } else
        k = _ === (v ? "pm" : "PM");
      return k;
    }, p = { A: [a, function(_) {
      this.afternoon = d(_, !1);
    }], a: [a, function(_) {
      this.afternoon = d(_, !0);
    }], S: [/\d/, function(_) {
      this.milliseconds = 100 * +_;
    }], SS: [i, function(_) {
      this.milliseconds = 10 * +_;
    }], SSS: [/\d{3}/, function(_) {
      this.milliseconds = +_;
    }], s: [s, u("seconds")], ss: [s, u("seconds")], m: [s, u("minutes")], mm: [s, u("minutes")], H: [s, u("hours")], h: [s, u("hours")], HH: [s, u("hours")], hh: [s, u("hours")], D: [s, u("day")], DD: [i, u("day")], Do: [a, function(_) {
      var v = o.ordinal, k = _.match(/\d+/);
      if (this.day = k[0], v)
        for (var x = 1; x <= 31; x += 1)
          v(x).replace(/\[|\]/g, "") === _ && (this.day = x);
    }], M: [s, u("month")], MM: [i, u("month")], MMM: [a, function(_) {
      var v = f("months"), k = (f("monthsShort") || v.map(function(x) {
        return x.slice(0, 3);
      })).indexOf(_) + 1;
      if (k < 1)
        throw new Error();
      this.month = k % 12 || k;
    }], MMMM: [a, function(_) {
      var v = f("months").indexOf(_) + 1;
      if (v < 1)
        throw new Error();
      this.month = v % 12 || v;
    }], Y: [/[+-]?\d+/, u("year")], YY: [i, function(_) {
      this.year = l(_);
    }], YYYY: [/\d{4}/, u("year")], Z: h, ZZ: h };
    function m(_) {
      var v, k;
      v = _, k = o && o.formats;
      for (var x = (_ = v.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(C, S, T) {
        var b = T && T.toUpperCase();
        return S || k[T] || r[T] || k[b].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(w, g, M) {
          return g || M.slice(1);
        });
      })).match(n), D = x.length, F = 0; F < D; F += 1) {
        var P = x[F], V = p[P], R = V && V[0], O = V && V[1];
        x[F] = O ? { regex: R, parser: O } : P.replace(/^\[|\]$/g, "");
      }
      return function(C) {
        for (var S = {}, T = 0, b = 0; T < D; T += 1) {
          var w = x[T];
          if (typeof w == "string")
            b += w.length;
          else {
            var g = w.regex, M = w.parser, y = C.slice(b), N = g.exec(y)[0];
            M.call(S, N), C = C.replace(N, "");
          }
        }
        return function(it) {
          var Y = it.afternoon;
          if (Y !== void 0) {
            var Z = it.hours;
            Y ? Z < 12 && (it.hours += 12) : Z === 12 && (it.hours = 0), delete it.afternoon;
          }
        }(S), S;
      };
    }
    return function(_, v, k) {
      k.p.customParseFormat = !0, _ && _.parseTwoDigitYear && (l = _.parseTwoDigitYear);
      var x = v.prototype, D = x.parse;
      x.parse = function(F) {
        var P = F.date, V = F.utc, R = F.args;
        this.$u = V;
        var O = R[1];
        if (typeof O == "string") {
          var C = R[2] === !0, S = R[3] === !0, T = C || S, b = R[2];
          S && (b = R[2]), o = this.$locale(), !C && b && (o = k.Ls[b]), this.$d = function(y, N, it) {
            try {
              if (["x", "X"].indexOf(N) > -1)
                return new Date((N === "X" ? 1e3 : 1) * y);
              var Y = m(N)(y), Z = Y.year, J = Y.month, X = Y.day, tt = Y.hours, st = Y.minutes, lt = Y.seconds, U = Y.milliseconds, Tt = Y.zone, $ = new Date(), j = X || (Z || J ? 1 : $.getDate()), W = Z || $.getFullYear(), z = 0;
              Z && !J || (z = J > 0 ? J - 1 : $.getMonth());
              var A = tt || 0, I = st || 0, G = lt || 0, L = U || 0;
              return Tt ? new Date(Date.UTC(W, z, j, A, I, G, L + 60 * Tt.offset * 1e3)) : it ? new Date(Date.UTC(W, z, j, A, I, G, L)) : new Date(W, z, j, A, I, G, L);
            } catch {
              return new Date("");
            }
          }(P, O, V), this.init(), b && b !== !0 && (this.$L = this.locale(b).$L), T && P != this.format(O) && (this.$d = new Date("")), o = {};
        } else if (O instanceof Array)
          for (var w = O.length, g = 1; g <= w; g += 1) {
            R[1] = O[g - 1];
            var M = k.apply(this, R);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            g === w && (this.$d = new Date(""));
          }
        else
          D.call(this, F);
      };
    };
  });
})(tO);
const eO = n1;
var i1 = {}, rO = {
  get exports() {
    return i1;
  },
  set exports(t) {
    i1 = t;
  }
};
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(bc, function() {
    return function(r, n) {
      var i = n.prototype, s = i.format;
      i.format = function(a) {
        var o = this, l = this.$locale();
        if (!this.isValid())
          return s.bind(this)(a);
        var u = this.$utils(), h = (a || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(f) {
          switch (f) {
            case "Q":
              return Math.ceil((o.$M + 1) / 3);
            case "Do":
              return l.ordinal(o.$D);
            case "gggg":
              return o.weekYear();
            case "GGGG":
              return o.isoWeekYear();
            case "wo":
              return l.ordinal(o.week(), "W");
            case "w":
            case "ww":
              return u.s(o.week(), f === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return u.s(o.isoWeek(), f === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return u.s(String(o.$H === 0 ? 24 : o.$H), f === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(o.$d.getTime() / 1e3);
            case "x":
              return o.$d.getTime();
            case "z":
              return "[" + o.offsetName() + "]";
            case "zzz":
              return "[" + o.offsetName("long") + "]";
            default:
              return f;
          }
        });
        return s.bind(this)(h);
      };
    };
  });
})(rO);
const nO = i1;
kr.extend(JF);
kr.extend(eO);
kr.extend(nO);
let mn = "", O0 = "", P0, V0 = "", xo = [], vo = [], Y0 = {}, z0 = [], cc = [], Us = "";
const z3 = ["active", "done", "crit", "milestone"];
let U0 = [], ko = !1, W0 = !1, s1 = 0;
const iO = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
}, sO = function() {
  z0 = [], cc = [], Us = "", U0 = [], ul = 0, o1 = void 0, hl = void 0, Ue = [], mn = "", O0 = "", P0 = void 0, V0 = "", xo = [], vo = [], ko = !1, W0 = !1, s1 = 0, Y0 = {}, Br();
}, aO = function(t) {
  O0 = t;
}, oO = function() {
  return O0;
}, lO = function(t) {
  P0 = t;
}, cO = function() {
  return P0;
}, uO = function(t) {
  V0 = t;
}, hO = function() {
  return V0;
}, fO = function(t) {
  mn = t;
}, dO = function() {
  ko = !0;
}, pO = function() {
  return ko;
}, gO = function() {
  W0 = !0;
}, yO = function() {
  return W0;
}, mO = function() {
  return mn;
}, bO = function(t) {
  xo = t.toLowerCase().split(/[\s,]+/);
}, _O = function() {
  return xo;
}, xO = function(t) {
  vo = t.toLowerCase().split(/[\s,]+/);
}, vO = function() {
  return vo;
}, kO = function() {
  return Y0;
}, wO = function(t) {
  Us = t, z0.push(t);
}, TO = function() {
  return z0;
}, EO = function() {
  let t = A2();
  const e = 10;
  let r = 0;
  for (; !t && r < e; )
    t = A2(), r++;
  return cc = Ue, cc;
}, U3 = function(t, e, r, n) {
  return n.includes(t.format(e.trim())) ? !1 : t.isoWeekday() >= 6 && r.includes("weekends") || r.includes(t.format("dddd").toLowerCase()) ? !0 : r.includes(t.format(e.trim()));
}, W3 = function(t, e, r, n) {
  if (!r.length || t.manualEndTime)
    return;
  let i;
  t.startTime instanceof Date ? i = kr(t.startTime) : i = kr(t.startTime, e, !0), i = i.add(1, "d");
  let s;
  t.endTime instanceof Date ? s = kr(t.endTime) : s = kr(t.endTime, e, !0);
  const [a, o] = CO(
    i,
    s,
    e,
    r,
    n
  );
  t.endTime = a.toDate(), t.renderEndTime = o;
}, CO = function(t, e, r, n, i) {
  let s = !1, a = null;
  for (; t <= e; )
    s || (a = e.toDate()), s = U3(t, r, n, i), s && (e = e.add(1, "d")), t = t.add(1, "d");
  return [e, a];
}, a1 = function(t, e, r) {
  r = r.trim();
  const i = /^after\s+([\d\w- ]+)/.exec(r.trim());
  if (i !== null) {
    let a = null;
    if (i[1].split(" ").forEach(function(o) {
      let l = ea(o);
      l !== void 0 && (a ? l.endTime > a.endTime && (a = l) : a = l);
    }), a)
      return a.endTime;
    {
      const o = new Date();
      return o.setHours(0, 0, 0, 0), o;
    }
  }
  let s = kr(r, e.trim(), !0);
  if (s.isValid())
    return s.toDate();
  {
    B.debug("Invalid date:" + r), B.debug("With date format:" + e.trim());
    const a = new Date(r);
    if (a === void 0 || isNaN(a.getTime()))
      throw new Error("Invalid date:" + r);
    return a;
  }
}, H3 = function(t) {
  const e = /^(\d+(?:\.\d+)?)([Mdhmswy]|ms)$/.exec(t.trim());
  return e !== null ? [Number.parseFloat(e[1]), e[2]] : [NaN, "ms"];
}, G3 = function(t, e, r, n = !1) {
  r = r.trim();
  let i = kr(r, e.trim(), !0);
  if (i.isValid())
    return n && (i = i.add(1, "d")), i.toDate();
  let s = kr(t);
  const [a, o] = H3(r);
  if (!Number.isNaN(a)) {
    const l = s.add(a, o);
    l.isValid() && (s = l);
  }
  return s.toDate();
};
let ul = 0;
const ws = function(t) {
  return t === void 0 ? (ul = ul + 1, "task" + ul) : t;
}, SO = function(t, e) {
  let r;
  e.substr(0, 1) === ":" ? r = e.substr(1, e.length) : r = e;
  const n = r.split(","), i = {};
  X3(n, i, z3);
  for (let a = 0; a < n.length; a++)
    n[a] = n[a].trim();
  let s = "";
  switch (n.length) {
    case 1:
      i.id = ws(), i.startTime = t.endTime, s = n[0];
      break;
    case 2:
      i.id = ws(), i.startTime = a1(void 0, mn, n[0]), s = n[1];
      break;
    case 3:
      i.id = ws(n[0]), i.startTime = a1(void 0, mn, n[1]), s = n[2];
      break;
  }
  return s && (i.endTime = G3(i.startTime, mn, s, ko), i.manualEndTime = kr(s, "YYYY-MM-DD", !0).isValid(), W3(i, mn, vo, xo)), i;
}, AO = function(t, e) {
  let r;
  e.substr(0, 1) === ":" ? r = e.substr(1, e.length) : r = e;
  const n = r.split(","), i = {};
  X3(n, i, z3);
  for (let s = 0; s < n.length; s++)
    n[s] = n[s].trim();
  switch (n.length) {
    case 1:
      i.id = ws(), i.startTime = {
        type: "prevTaskEnd",
        id: t
      }, i.endTime = {
        data: n[0]
      };
      break;
    case 2:
      i.id = ws(), i.startTime = {
        type: "getStartDate",
        startData: n[0]
      }, i.endTime = {
        data: n[1]
      };
      break;
    case 3:
      i.id = ws(n[0]), i.startTime = {
        type: "getStartDate",
        startData: n[1]
      }, i.endTime = {
        data: n[2]
      };
      break;
  }
  return i;
};
let o1, hl, Ue = [];
const q3 = {}, LO = function(t, e) {
  const r = {
    section: Us,
    type: Us,
    processed: !1,
    manualEndTime: !1,
    renderEndTime: null,
    raw: { data: e },
    task: t,
    classes: []
  }, n = AO(hl, e);
  r.raw.startTime = n.startTime, r.raw.endTime = n.endTime, r.id = n.id, r.prevTaskId = hl, r.active = n.active, r.done = n.done, r.crit = n.crit, r.milestone = n.milestone, r.order = s1, s1++;
  const i = Ue.push(r);
  hl = r.id, q3[r.id] = i - 1;
}, ea = function(t) {
  const e = q3[t];
  return Ue[e];
}, BO = function(t, e) {
  const r = {
    section: Us,
    type: Us,
    description: t,
    task: t,
    classes: []
  }, n = SO(o1, e);
  r.startTime = n.startTime, r.endTime = n.endTime, r.id = n.id, r.active = n.active, r.done = n.done, r.crit = n.crit, r.milestone = n.milestone, o1 = r, cc.push(r);
}, A2 = function() {
  const t = function(r) {
    const n = Ue[r];
    let i = "";
    switch (Ue[r].raw.startTime.type) {
      case "prevTaskEnd": {
        const s = ea(n.prevTaskId);
        n.startTime = s.endTime;
        break;
      }
      case "getStartDate":
        i = a1(void 0, mn, Ue[r].raw.startTime.startData), i && (Ue[r].startTime = i);
        break;
    }
    return Ue[r].startTime && (Ue[r].endTime = G3(
      Ue[r].startTime,
      mn,
      Ue[r].raw.endTime.data,
      ko
    ), Ue[r].endTime && (Ue[r].processed = !0, Ue[r].manualEndTime = kr(
      Ue[r].raw.endTime.data,
      "YYYY-MM-DD",
      !0
    ).isValid(), W3(Ue[r], mn, vo, xo))), Ue[r].processed;
  };
  let e = !0;
  for (const [r, n] of Ue.entries())
    t(r), e = e && n.processed;
  return e;
}, DO = function(t, e) {
  let r = e;
  q().securityLevel !== "loose" && (r = Jn(e)), t.split(",").forEach(function(n) {
    ea(n) !== void 0 && (j3(n, () => {
      window.open(r, "_self");
    }), Y0[n] = r);
  }), $3(t, "clickable");
}, $3 = function(t, e) {
  t.split(",").forEach(function(r) {
    let n = ea(r);
    n !== void 0 && n.classes.push(e);
  });
}, IO = function(t, e, r) {
  if (q().securityLevel !== "loose" || e === void 0)
    return;
  let n = [];
  if (typeof r == "string") {
    n = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let s = 0; s < n.length; s++) {
      let a = n[s].trim();
      a.charAt(0) === '"' && a.charAt(a.length - 1) === '"' && (a = a.substr(1, a.length - 2)), n[s] = a;
    }
  }
  n.length === 0 && n.push(t), ea(t) !== void 0 && j3(t, () => {
    jt.runFunc(e, ...n);
  });
}, j3 = function(t, e) {
  U0.push(
    function() {
      const r = document.querySelector(`[id="${t}"]`);
      r !== null && r.addEventListener("click", function() {
        e();
      });
    },
    function() {
      const r = document.querySelector(`[id="${t}-text"]`);
      r !== null && r.addEventListener("click", function() {
        e();
      });
    }
  );
}, MO = function(t, e, r) {
  t.split(",").forEach(function(n) {
    IO(n, e, r);
  }), $3(t, "clickable");
}, NO = function(t) {
  U0.forEach(function(e) {
    e(t);
  });
}, H0 = {
  parseDirective: iO,
  getConfig: () => q().gantt,
  clear: sO,
  setDateFormat: fO,
  getDateFormat: mO,
  enableInclusiveEndDates: dO,
  endDatesAreInclusive: pO,
  enableTopAxis: gO,
  topAxisEnabled: yO,
  setAxisFormat: aO,
  getAxisFormat: oO,
  setTickInterval: lO,
  getTickInterval: cO,
  setTodayMarker: uO,
  getTodayMarker: hO,
  setAccTitle: Tr,
  getAccTitle: Dr,
  setDiagramTitle: un,
  getDiagramTitle: hn,
  setAccDescription: Ir,
  getAccDescription: Mr,
  addSection: wO,
  getSections: TO,
  getTasks: EO,
  addTask: LO,
  findTaskById: ea,
  addTaskOrg: BO,
  setIncludes: bO,
  getIncludes: _O,
  setExcludes: xO,
  getExcludes: vO,
  setClickEvent: MO,
  setLink: DO,
  getLinks: kO,
  bindFunctions: NO,
  parseDuration: H3,
  isInvalidDate: U3
};
function X3(t, e, r) {
  let n = !0;
  for (; n; )
    n = !1, r.forEach(function(i) {
      const s = "^\\s*" + i + "\\s*$", a = new RegExp(s);
      t[0].match(a) && (e[i] = !0, t.shift(1), n = !0);
    });
}
const RO = function() {
  B.debug("Something is calling, setConf, remove the call");
};
let Mn;
const FO = function(t, e, r, n) {
  const i = q().gantt, s = q().securityLevel;
  let a;
  s === "sandbox" && (a = _t("#i" + e));
  const o = _t(s === "sandbox" ? a.nodes()[0].contentDocument.body : "body"), l = s === "sandbox" ? a.nodes()[0].contentDocument : document, u = l.getElementById(e);
  Mn = u.parentElement.offsetWidth, Mn === void 0 && (Mn = 1200), i.useWidth !== void 0 && (Mn = i.useWidth);
  const h = n.db.getTasks(), f = h.length * (i.barHeight + i.barGap) + 2 * i.topPadding;
  u.setAttribute("viewBox", "0 0 " + Mn + " " + f);
  const d = o.select(`[id="${e}"]`), p = Jv().domain([
    D5(h, function(S) {
      return S.startTime;
    }),
    B5(h, function(S) {
      return S.endTime;
    })
  ]).rangeRound([0, Mn - i.leftPadding - i.rightPadding]);
  let m = [];
  for (const S of h)
    m.push(S.type);
  const _ = m;
  m = R(m);
  function v(S, T) {
    const b = S.startTime, w = T.startTime;
    let g = 0;
    return b > w ? g = 1 : b < w && (g = -1), g;
  }
  h.sort(v), k(h, Mn, f), cn(d, f, Mn, i.useMaxWidth), d.append("text").text(n.db.getDiagramTitle()).attr("x", Mn / 2).attr("y", i.titleTopMargin).attr("class", "titleText");
  function k(S, T, b) {
    const w = i.barHeight, g = w + i.barGap, M = i.topPadding, y = i.leftPadding, N = Fp().domain([0, m.length]).range(["#00B9FA", "#F95002"]).interpolate(Q_);
    D(
      g,
      M,
      y,
      T,
      b,
      S,
      n.db.getExcludes(),
      n.db.getIncludes()
    ), F(y, M, T, b), x(S, g, M, y, w, N, T), P(g, M), V(y, M, T, b);
  }
  function x(S, T, b, w, g, M, y) {
    d.append("g").selectAll("rect").data(S).enter().append("rect").attr("x", 0).attr("y", function(Z, J) {
      return J = Z.order, J * T + b - 2;
    }).attr("width", function() {
      return y - i.rightPadding / 2;
    }).attr("height", T).attr("class", function(Z) {
      for (const [J, X] of m.entries())
        if (Z.type === X)
          return "section section" + J % i.numberSectionStyles;
      return "section section0";
    });
    const N = d.append("g").selectAll("rect").data(S).enter(), it = n.db.getLinks();
    if (N.append("rect").attr("id", function(Z) {
      return Z.id;
    }).attr("rx", 3).attr("ry", 3).attr("x", function(Z) {
      return Z.milestone ? p(Z.startTime) + w + 0.5 * (p(Z.endTime) - p(Z.startTime)) - 0.5 * g : p(Z.startTime) + w;
    }).attr("y", function(Z, J) {
      return J = Z.order, J * T + b;
    }).attr("width", function(Z) {
      return Z.milestone ? g : p(Z.renderEndTime || Z.endTime) - p(Z.startTime);
    }).attr("height", g).attr("transform-origin", function(Z, J) {
      return J = Z.order, (p(Z.startTime) + w + 0.5 * (p(Z.endTime) - p(Z.startTime))).toString() + "px " + (J * T + b + 0.5 * g).toString() + "px";
    }).attr("class", function(Z) {
      const J = "task";
      let X = "";
      Z.classes.length > 0 && (X = Z.classes.join(" "));
      let tt = 0;
      for (const [lt, U] of m.entries())
        Z.type === U && (tt = lt % i.numberSectionStyles);
      let st = "";
      return Z.active ? Z.crit ? st += " activeCrit" : st = " active" : Z.done ? Z.crit ? st = " doneCrit" : st = " done" : Z.crit && (st += " crit"), st.length === 0 && (st = " task"), Z.milestone && (st = " milestone " + st), st += tt, st += " " + X, J + st;
    }), N.append("text").attr("id", function(Z) {
      return Z.id + "-text";
    }).text(function(Z) {
      return Z.task;
    }).attr("font-size", i.fontSize).attr("x", function(Z) {
      let J = p(Z.startTime), X = p(Z.renderEndTime || Z.endTime);
      Z.milestone && (J += 0.5 * (p(Z.endTime) - p(Z.startTime)) - 0.5 * g), Z.milestone && (X = J + g);
      const tt = this.getBBox().width;
      return tt > X - J ? X + tt + 1.5 * i.leftPadding > y ? J + w - 5 : X + w + 5 : (X - J) / 2 + J + w;
    }).attr("y", function(Z, J) {
      return J = Z.order, J * T + i.barHeight / 2 + (i.fontSize / 2 - 2) + b;
    }).attr("text-height", g).attr("class", function(Z) {
      const J = p(Z.startTime);
      let X = p(Z.endTime);
      Z.milestone && (X = J + g);
      const tt = this.getBBox().width;
      let st = "";
      Z.classes.length > 0 && (st = Z.classes.join(" "));
      let lt = 0;
      for (const [Tt, $] of m.entries())
        Z.type === $ && (lt = Tt % i.numberSectionStyles);
      let U = "";
      return Z.active && (Z.crit ? U = "activeCritText" + lt : U = "activeText" + lt), Z.done ? Z.crit ? U = U + " doneCritText" + lt : U = U + " doneText" + lt : Z.crit && (U = U + " critText" + lt), Z.milestone && (U += " milestoneText"), tt > X - J ? X + tt + 1.5 * i.leftPadding > y ? st + " taskTextOutsideLeft taskTextOutside" + lt + " " + U : st + " taskTextOutsideRight taskTextOutside" + lt + " " + U + " width-" + tt : st + " taskText taskText" + lt + " " + U + " width-" + tt;
    }), q().securityLevel === "sandbox") {
      let Z;
      Z = _t("#i" + e);
      const J = Z.nodes()[0].contentDocument;
      N.filter(function(X) {
        return it[X.id] !== void 0;
      }).each(function(X) {
        var tt = J.querySelector("#" + X.id), st = J.querySelector("#" + X.id + "-text");
        const lt = tt.parentNode;
        var U = J.createElement("a");
        U.setAttribute("xlink:href", it[X.id]), U.setAttribute("target", "_top"), lt.appendChild(U), U.appendChild(tt), U.appendChild(st);
      });
    }
  }
  function D(S, T, b, w, g, M, y, N) {
    const it = M.reduce(
      (lt, { startTime: U }) => lt ? Math.min(lt, U) : U,
      0
    ), Y = M.reduce((lt, { endTime: U }) => lt ? Math.max(lt, U) : U, 0), Z = n.db.getDateFormat();
    if (!it || !Y)
      return;
    const J = [];
    let X = null, tt = kr(it);
    for (; tt.valueOf() <= Y; )
      n.db.isInvalidDate(tt, Z, y, N) ? X ? X.end = tt : X = {
        start: tt,
        end: tt
      } : X && (J.push(X), X = null), tt = tt.add(1, "d");
    d.append("g").selectAll("rect").data(J).enter().append("rect").attr("id", function(lt) {
      return "exclude-" + lt.start.format("YYYY-MM-DD");
    }).attr("x", function(lt) {
      return p(lt.start) + b;
    }).attr("y", i.gridLineStartPadding).attr("width", function(lt) {
      const U = lt.end.add(1, "day");
      return p(U) - p(lt.start);
    }).attr("height", g - T - i.gridLineStartPadding).attr("transform-origin", function(lt, U) {
      return (p(lt.start) + b + 0.5 * (p(lt.end) - p(lt.start))).toString() + "px " + (U * S + 0.5 * g).toString() + "px";
    }).attr("class", "exclude-range");
  }
  function F(S, T, b, w) {
    let g = V5(p).tickSize(-w + T + i.gridLineStartPadding).tickFormat(Dl(n.db.getAxisFormat() || i.axisFormat || "%Y-%m-%d"));
    const y = /^([1-9]\d*)(minute|hour|day|week|month)$/.exec(
      n.db.getTickInterval() || i.tickInterval
    );
    if (y !== null) {
      const N = y[1];
      switch (y[2]) {
        case "minute":
          g.ticks(Cl.every(N));
          break;
        case "hour":
          g.ticks(Sl.every(N));
          break;
        case "day":
          g.ticks(Ss.every(N));
          break;
        case "week":
          g.ticks(As.every(N));
          break;
        case "month":
          g.ticks(Ll.every(N));
          break;
      }
    }
    if (d.append("g").attr("class", "grid").attr("transform", "translate(" + S + ", " + (w - 50) + ")").call(g).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10).attr("dy", "1em"), n.db.topAxisEnabled() || i.topAxis) {
      let N = P5(p).tickSize(-w + T + i.gridLineStartPadding).tickFormat(Dl(n.db.getAxisFormat() || i.axisFormat || "%Y-%m-%d"));
      if (y !== null) {
        const it = y[1];
        switch (y[2]) {
          case "minute":
            N.ticks(Cl.every(it));
            break;
          case "hour":
            N.ticks(Sl.every(it));
            break;
          case "day":
            N.ticks(Ss.every(it));
            break;
          case "week":
            N.ticks(As.every(it));
            break;
          case "month":
            N.ticks(Ll.every(it));
            break;
        }
      }
      d.append("g").attr("class", "grid").attr("transform", "translate(" + S + ", " + T + ")").call(N).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10);
    }
  }
  function P(S, T) {
    const b = [];
    let w = 0;
    for (const [g, M] of m.entries())
      b[g] = [M, C(M, _)];
    d.append("g").selectAll("text").data(b).enter().append(function(g) {
      const M = g[0].split(Xt.lineBreakRegex), y = -(M.length - 1) / 2, N = l.createElementNS("http://www.w3.org/2000/svg", "text");
      N.setAttribute("dy", y + "em");
      for (const [it, Y] of M.entries()) {
        const Z = l.createElementNS("http://www.w3.org/2000/svg", "tspan");
        Z.setAttribute("alignment-baseline", "central"), Z.setAttribute("x", "10"), it > 0 && Z.setAttribute("dy", "1em"), Z.textContent = Y, N.appendChild(Z);
      }
      return N;
    }).attr("x", 10).attr("y", function(g, M) {
      if (M > 0)
        for (let y = 0; y < M; y++)
          return w += b[M - 1][1], g[1] * S / 2 + w * S + T;
      else
        return g[1] * S / 2 + T;
    }).attr("font-size", i.sectionFontSize).attr("font-size", i.sectionFontSize).attr("class", function(g) {
      for (const [M, y] of m.entries())
        if (g[0] === y)
          return "sectionTitle sectionTitle" + M % i.numberSectionStyles;
      return "sectionTitle";
    });
  }
  function V(S, T, b, w) {
    const g = n.db.getTodayMarker();
    if (g === "off")
      return;
    const M = d.append("g").attr("class", "today"), y = new Date(), N = M.append("line");
    N.attr("x1", p(y) + S).attr("x2", p(y) + S).attr("y1", i.titleTopMargin).attr("y2", w - i.titleTopMargin).attr("class", "today"), g !== "" && N.attr("style", g.replace(/,/g, ";"));
  }
  function R(S) {
    const T = {}, b = [];
    for (let w = 0, g = S.length; w < g; ++w)
      Object.prototype.hasOwnProperty.call(T, S[w]) || (T[S[w]] = !0, b.push(S[w]));
    return b;
  }
  function O(S) {
    let T = S.length;
    const b = {};
    for (; T; )
      b[S[--T]] = (b[S[T]] || 0) + 1;
    return b;
  }
  function C(S, T) {
    return O(T)[S] || 0;
  }
}, OO = {
  setConf: RO,
  draw: FO
};
var l1 = function() {
  var t = function(s, a, o, l) {
    for (o = o || {}, l = s.length; l--; o[s[l]] = a)
      ;
    return o;
  }, e = [6, 9, 10], r = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, info: 4, document: 5, EOF: 6, line: 7, statement: 8, NL: 9, showInfo: 10, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "info", 6: "EOF", 9: "NL", 10: "showInfo" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 1], [7, 1], [8, 1]],
    performAction: function(a, o, l, u, h, f, d) {
      switch (f.length - 1, h) {
        case 1:
          return u;
        case 4:
          break;
        case 6:
          u.setInfo(!0);
          break;
      }
    },
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, t(e, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: 6, 9: [1, 7], 10: [1, 8] }, { 1: [2, 1] }, t(e, [2, 3]), t(e, [2, 4]), t(e, [2, 5]), t(e, [2, 6])],
    defaultActions: { 4: [2, 1] },
    parseError: function(a, o) {
      if (o.recoverable)
        this.trace(a);
      else {
        var l = new Error(a);
        throw l.hash = o, l;
      }
    },
    parse: function(a) {
      var o = this, l = [0], u = [], h = [null], f = [], d = this.table, p = "", m = 0, _ = 0, v = 2, k = 1, x = f.slice.call(arguments, 1), D = Object.create(this.lexer), F = { yy: {} };
      for (var P in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, P) && (F.yy[P] = this.yy[P]);
      D.setInput(a, F.yy), F.yy.lexer = D, F.yy.parser = this, typeof D.yylloc > "u" && (D.yylloc = {});
      var V = D.yylloc;
      f.push(V);
      var R = D.options && D.options.ranges;
      typeof F.yy.parseError == "function" ? this.parseError = F.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function O() {
        var Y;
        return Y = u.pop() || D.lex() || k, typeof Y != "number" && (Y instanceof Array && (u = Y, Y = u.pop()), Y = o.symbols_[Y] || Y), Y;
      }
      for (var C, S, T, b, w = {}, g, M, y, N; ; ) {
        if (S = l[l.length - 1], this.defaultActions[S] ? T = this.defaultActions[S] : ((C === null || typeof C > "u") && (C = O()), T = d[S] && d[S][C]), typeof T > "u" || !T.length || !T[0]) {
          var it = "";
          N = [];
          for (g in d[S])
            this.terminals_[g] && g > v && N.push("'" + this.terminals_[g] + "'");
          D.showPosition ? it = "Parse error on line " + (m + 1) + `:
` + D.showPosition() + `
Expecting ` + N.join(", ") + ", got '" + (this.terminals_[C] || C) + "'" : it = "Parse error on line " + (m + 1) + ": Unexpected " + (C == k ? "end of input" : "'" + (this.terminals_[C] || C) + "'"), this.parseError(it, {
            text: D.match,
            token: this.terminals_[C] || C,
            line: D.yylineno,
            loc: V,
            expected: N
          });
        }
        if (T[0] instanceof Array && T.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + S + ", token: " + C);
        switch (T[0]) {
          case 1:
            l.push(C), h.push(D.yytext), f.push(D.yylloc), l.push(T[1]), C = null, _ = D.yyleng, p = D.yytext, m = D.yylineno, V = D.yylloc;
            break;
          case 2:
            if (M = this.productions_[T[1]][1], w.$ = h[h.length - M], w._$ = {
              first_line: f[f.length - (M || 1)].first_line,
              last_line: f[f.length - 1].last_line,
              first_column: f[f.length - (M || 1)].first_column,
              last_column: f[f.length - 1].last_column
            }, R && (w._$.range = [
              f[f.length - (M || 1)].range[0],
              f[f.length - 1].range[1]
            ]), b = this.performAction.apply(w, [
              p,
              _,
              m,
              F.yy,
              T[1],
              h,
              f
            ].concat(x)), typeof b < "u")
              return b;
            M && (l = l.slice(0, -1 * M * 2), h = h.slice(0, -1 * M), f = f.slice(0, -1 * M)), l.push(this.productions_[T[1]][0]), h.push(w.$), f.push(w._$), y = d[l[l.length - 2]][l[l.length - 1]], l.push(y);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, n = function() {
    var s = {
      EOF: 1,
      parseError: function(o, l) {
        if (this.yy.parser)
          this.yy.parser.parseError(o, l);
        else
          throw new Error(o);
      },
      // resets the lexer, sets new input
      setInput: function(a, o) {
        return this.yy = o || this.yy || {}, this._input = a, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var a = this._input[0];
        this.yytext += a, this.yyleng++, this.offset++, this.match += a, this.matched += a;
        var o = a.match(/(?:\r\n?|\n).*/g);
        return o ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), a;
      },
      // unshifts one char (or a string) into the input
      unput: function(a) {
        var o = a.length, l = a.split(/(?:\r\n?|\n)/g);
        this._input = a + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - o), this.offset -= o;
        var u = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), l.length - 1 && (this.yylineno -= l.length - 1);
        var h = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: l ? (l.length === u.length ? this.yylloc.first_column : 0) + u[u.length - l.length].length - l[0].length : this.yylloc.first_column - o
        }, this.options.ranges && (this.yylloc.range = [h[0], h[0] + this.yyleng - o]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(a) {
        this.unput(this.match.slice(a));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var a = this.matched.substr(0, this.matched.length - this.match.length);
        return (a.length > 20 ? "..." : "") + a.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var a = this.match;
        return a.length < 20 && (a += this._input.substr(0, 20 - a.length)), (a.substr(0, 20) + (a.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var a = this.pastInput(), o = new Array(a.length + 1).join("-");
        return a + this.upcomingInput() + `
` + o + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(a, o) {
        var l, u, h;
        if (this.options.backtrack_lexer && (h = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (h.yylloc.range = this.yylloc.range.slice(0))), u = a[0].match(/(?:\r\n?|\n).*/g), u && (this.yylineno += u.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: u ? u[u.length - 1].length - u[u.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + a[0].length
        }, this.yytext += a[0], this.match += a[0], this.matches = a, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(a[0].length), this.matched += a[0], l = this.performAction.call(this, this.yy, this, o, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), l)
          return l;
        if (this._backtrack) {
          for (var f in h)
            this[f] = h[f];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var a, o, l, u;
        this._more || (this.yytext = "", this.match = "");
        for (var h = this._currentRules(), f = 0; f < h.length; f++)
          if (l = this._input.match(this.rules[h[f]]), l && (!o || l[0].length > o[0].length)) {
            if (o = l, u = f, this.options.backtrack_lexer) {
              if (a = this.test_match(l, h[f]), a !== !1)
                return a;
              if (this._backtrack) {
                o = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return o ? (a = this.test_match(o, h[u]), a !== !1 ? a : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var o = this.next();
        return o || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(o) {
        this.conditionStack.push(o);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var o = this.conditionStack.length - 1;
        return o > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(o) {
        return o = this.conditionStack.length - 1 - Math.abs(o || 0), o >= 0 ? this.conditionStack[o] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(o) {
        this.begin(o);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(o, l, u, h) {
        switch (u) {
          case 0:
            return 4;
          case 1:
            return 9;
          case 2:
            return "space";
          case 3:
            return 10;
          case 4:
            return 6;
          case 5:
            return "TXT";
        }
      },
      rules: [/^(?:info\b)/i, /^(?:[\s\n\r]+)/i, /^(?:[\s]+)/i, /^(?:showInfo\b)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { INITIAL: { rules: [0, 1, 2, 3, 4, 5], inclusive: !0 } }
    };
    return s;
  }();
  r.lexer = n;
  function i() {
    this.yy = {};
  }
  return i.prototype = r, r.Parser = i, new i();
}();
l1.parser = l1;
const PO = l1;
var K3 = "", Z3 = !1;
const VO = (t) => {
  B.debug("Setting message to: " + t), K3 = t;
}, YO = () => K3, zO = (t) => {
  Z3 = t;
}, UO = () => Z3, WO = {
  setMessage: VO,
  getMessage: YO,
  setInfo: zO,
  getInfo: UO,
  clear: Br
  // parseError
}, HO = (t, e, r) => {
  try {
    B.debug(`Rendering info diagram
` + t);
    const n = q().securityLevel;
    let i;
    n === "sandbox" && (i = _t("#i" + e));
    const a = _t(n === "sandbox" ? i.nodes()[0].contentDocument.body : "body").select("#" + e);
    a.append("g").append("text").attr("x", 100).attr("y", 40).attr("class", "version").attr("font-size", "32px").style("text-anchor", "middle").text("v " + r), a.attr("height", 100), a.attr("width", 400);
  } catch (n) {
    B.error("Error while rendering info diagram"), B.error(n.message);
  }
}, GO = {
  draw: HO
}, qO = (t) => t.match(/^\s*info/) !== null;
var c1 = function() {
  var t = function(V, R, O, C) {
    for (O = O || {}, C = V.length; C--; O[V[C]] = R)
      ;
    return O;
  }, e = [1, 4], r = [1, 5], n = [1, 6], i = [1, 7], s = [1, 9], a = [1, 11, 13, 15, 17, 19, 20, 26, 27, 28, 29], o = [2, 5], l = [1, 6, 11, 13, 15, 17, 19, 20, 26, 27, 28, 29], u = [26, 27, 28], h = [2, 8], f = [1, 18], d = [1, 19], p = [1, 20], m = [1, 21], _ = [1, 22], v = [1, 23], k = [1, 28], x = [6, 26, 27, 28, 29], D = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, eol: 4, directive: 5, PIE: 6, document: 7, showData: 8, line: 9, statement: 10, txt: 11, value: 12, title: 13, title_value: 14, acc_title: 15, acc_title_value: 16, acc_descr: 17, acc_descr_value: 18, acc_descr_multiline_value: 19, section: 20, openDirective: 21, typeDirective: 22, closeDirective: 23, ":": 24, argDirective: 25, NEWLINE: 26, ";": 27, EOF: 28, open_directive: 29, type_directive: 30, arg_directive: 31, close_directive: 32, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 6: "PIE", 8: "showData", 11: "txt", 12: "value", 13: "title", 14: "title_value", 15: "acc_title", 16: "acc_title_value", 17: "acc_descr", 18: "acc_descr_value", 19: "acc_descr_multiline_value", 20: "section", 24: ":", 26: "NEWLINE", 27: ";", 28: "EOF", 29: "open_directive", 30: "type_directive", 31: "arg_directive", 32: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 3], [7, 0], [7, 2], [9, 2], [10, 0], [10, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [5, 3], [5, 5], [4, 1], [4, 1], [4, 1], [21, 1], [22, 1], [25, 1], [23, 1]],
    performAction: function(R, O, C, S, T, b, w) {
      var g = b.length - 1;
      switch (T) {
        case 4:
          S.setShowData(!0);
          break;
        case 7:
          this.$ = b[g - 1];
          break;
        case 9:
          S.addSection(b[g - 1], S.cleanupValue(b[g]));
          break;
        case 10:
          this.$ = b[g].trim(), S.setDiagramTitle(this.$);
          break;
        case 11:
          this.$ = b[g].trim(), S.setAccTitle(this.$);
          break;
        case 12:
        case 13:
          this.$ = b[g].trim(), S.setAccDescription(this.$);
          break;
        case 14:
          S.addSection(b[g].substr(8)), this.$ = b[g].substr(8);
          break;
        case 21:
          S.parseDirective("%%{", "open_directive");
          break;
        case 22:
          S.parseDirective(b[g], "type_directive");
          break;
        case 23:
          b[g] = b[g].trim().replace(/'/g, '"'), S.parseDirective(b[g], "arg_directive");
          break;
        case 24:
          S.parseDirective("}%%", "close_directive", "pie");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: e, 21: 8, 26: r, 27: n, 28: i, 29: s }, { 1: [3] }, { 3: 10, 4: 2, 5: 3, 6: e, 21: 8, 26: r, 27: n, 28: i, 29: s }, { 3: 11, 4: 2, 5: 3, 6: e, 21: 8, 26: r, 27: n, 28: i, 29: s }, t(a, o, { 7: 12, 8: [1, 13] }), t(l, [2, 18]), t(l, [2, 19]), t(l, [2, 20]), { 22: 14, 30: [1, 15] }, { 30: [2, 21] }, { 1: [2, 1] }, { 1: [2, 2] }, t(u, h, { 21: 8, 9: 16, 10: 17, 5: 24, 1: [2, 3], 11: f, 13: d, 15: p, 17: m, 19: _, 20: v, 29: s }), t(a, o, { 7: 25 }), { 23: 26, 24: [1, 27], 32: k }, t([24, 32], [2, 22]), t(a, [2, 6]), { 4: 29, 26: r, 27: n, 28: i }, { 12: [1, 30] }, { 14: [1, 31] }, { 16: [1, 32] }, { 18: [1, 33] }, t(u, [2, 13]), t(u, [2, 14]), t(u, [2, 15]), t(u, h, { 21: 8, 9: 16, 10: 17, 5: 24, 1: [2, 4], 11: f, 13: d, 15: p, 17: m, 19: _, 20: v, 29: s }), t(x, [2, 16]), { 25: 34, 31: [1, 35] }, t(x, [2, 24]), t(a, [2, 7]), t(u, [2, 9]), t(u, [2, 10]), t(u, [2, 11]), t(u, [2, 12]), { 23: 36, 32: k }, { 32: [2, 23] }, t(x, [2, 17])],
    defaultActions: { 9: [2, 21], 10: [2, 1], 11: [2, 2], 35: [2, 23] },
    parseError: function(R, O) {
      if (O.recoverable)
        this.trace(R);
      else {
        var C = new Error(R);
        throw C.hash = O, C;
      }
    },
    parse: function(R) {
      var O = this, C = [0], S = [], T = [null], b = [], w = this.table, g = "", M = 0, y = 0, N = 2, it = 1, Y = b.slice.call(arguments, 1), Z = Object.create(this.lexer), J = { yy: {} };
      for (var X in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, X) && (J.yy[X] = this.yy[X]);
      Z.setInput(R, J.yy), J.yy.lexer = Z, J.yy.parser = this, typeof Z.yylloc > "u" && (Z.yylloc = {});
      var tt = Z.yylloc;
      b.push(tt);
      var st = Z.options && Z.options.ranges;
      typeof J.yy.parseError == "function" ? this.parseError = J.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function lt() {
        var at;
        return at = S.pop() || Z.lex() || it, typeof at != "number" && (at instanceof Array && (S = at, at = S.pop()), at = O.symbols_[at] || at), at;
      }
      for (var U, Tt, $, j, W = {}, z, A, I, G; ; ) {
        if (Tt = C[C.length - 1], this.defaultActions[Tt] ? $ = this.defaultActions[Tt] : ((U === null || typeof U > "u") && (U = lt()), $ = w[Tt] && w[Tt][U]), typeof $ > "u" || !$.length || !$[0]) {
          var L = "";
          G = [];
          for (z in w[Tt])
            this.terminals_[z] && z > N && G.push("'" + this.terminals_[z] + "'");
          Z.showPosition ? L = "Parse error on line " + (M + 1) + `:
` + Z.showPosition() + `
Expecting ` + G.join(", ") + ", got '" + (this.terminals_[U] || U) + "'" : L = "Parse error on line " + (M + 1) + ": Unexpected " + (U == it ? "end of input" : "'" + (this.terminals_[U] || U) + "'"), this.parseError(L, {
            text: Z.match,
            token: this.terminals_[U] || U,
            line: Z.yylineno,
            loc: tt,
            expected: G
          });
        }
        if ($[0] instanceof Array && $.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Tt + ", token: " + U);
        switch ($[0]) {
          case 1:
            C.push(U), T.push(Z.yytext), b.push(Z.yylloc), C.push($[1]), U = null, y = Z.yyleng, g = Z.yytext, M = Z.yylineno, tt = Z.yylloc;
            break;
          case 2:
            if (A = this.productions_[$[1]][1], W.$ = T[T.length - A], W._$ = {
              first_line: b[b.length - (A || 1)].first_line,
              last_line: b[b.length - 1].last_line,
              first_column: b[b.length - (A || 1)].first_column,
              last_column: b[b.length - 1].last_column
            }, st && (W._$.range = [
              b[b.length - (A || 1)].range[0],
              b[b.length - 1].range[1]
            ]), j = this.performAction.apply(W, [
              g,
              y,
              M,
              J.yy,
              $[1],
              T,
              b
            ].concat(Y)), typeof j < "u")
              return j;
            A && (C = C.slice(0, -1 * A * 2), T = T.slice(0, -1 * A), b = b.slice(0, -1 * A)), C.push(this.productions_[$[1]][0]), T.push(W.$), b.push(W._$), I = w[C[C.length - 2]][C[C.length - 1]], C.push(I);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, F = function() {
    var V = {
      EOF: 1,
      parseError: function(O, C) {
        if (this.yy.parser)
          this.yy.parser.parseError(O, C);
        else
          throw new Error(O);
      },
      // resets the lexer, sets new input
      setInput: function(R, O) {
        return this.yy = O || this.yy || {}, this._input = R, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var R = this._input[0];
        this.yytext += R, this.yyleng++, this.offset++, this.match += R, this.matched += R;
        var O = R.match(/(?:\r\n?|\n).*/g);
        return O ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), R;
      },
      // unshifts one char (or a string) into the input
      unput: function(R) {
        var O = R.length, C = R.split(/(?:\r\n?|\n)/g);
        this._input = R + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - O), this.offset -= O;
        var S = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), C.length - 1 && (this.yylineno -= C.length - 1);
        var T = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: C ? (C.length === S.length ? this.yylloc.first_column : 0) + S[S.length - C.length].length - C[0].length : this.yylloc.first_column - O
        }, this.options.ranges && (this.yylloc.range = [T[0], T[0] + this.yyleng - O]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(R) {
        this.unput(this.match.slice(R));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var R = this.matched.substr(0, this.matched.length - this.match.length);
        return (R.length > 20 ? "..." : "") + R.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var R = this.match;
        return R.length < 20 && (R += this._input.substr(0, 20 - R.length)), (R.substr(0, 20) + (R.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var R = this.pastInput(), O = new Array(R.length + 1).join("-");
        return R + this.upcomingInput() + `
` + O + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(R, O) {
        var C, S, T;
        if (this.options.backtrack_lexer && (T = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (T.yylloc.range = this.yylloc.range.slice(0))), S = R[0].match(/(?:\r\n?|\n).*/g), S && (this.yylineno += S.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: S ? S[S.length - 1].length - S[S.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + R[0].length
        }, this.yytext += R[0], this.match += R[0], this.matches = R, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(R[0].length), this.matched += R[0], C = this.performAction.call(this, this.yy, this, O, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), C)
          return C;
        if (this._backtrack) {
          for (var b in T)
            this[b] = T[b];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var R, O, C, S;
        this._more || (this.yytext = "", this.match = "");
        for (var T = this._currentRules(), b = 0; b < T.length; b++)
          if (C = this._input.match(this.rules[T[b]]), C && (!O || C[0].length > O[0].length)) {
            if (O = C, S = b, this.options.backtrack_lexer) {
              if (R = this.test_match(C, T[b]), R !== !1)
                return R;
              if (this._backtrack) {
                O = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return O ? (R = this.test_match(O, T[S]), R !== !1 ? R : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var O = this.next();
        return O || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(O) {
        this.conditionStack.push(O);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var O = this.conditionStack.length - 1;
        return O > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(O) {
        return O = this.conditionStack.length - 1 - Math.abs(O || 0), O >= 0 ? this.conditionStack[O] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(O) {
        this.begin(O);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(O, C, S, T) {
        switch (S) {
          case 0:
            return this.begin("open_directive"), 29;
          case 1:
            return this.begin("type_directive"), 30;
          case 2:
            return this.popState(), this.begin("arg_directive"), 24;
          case 3:
            return this.popState(), this.popState(), 32;
          case 4:
            return 31;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return 26;
          case 8:
            break;
          case 9:
            break;
          case 10:
            return this.begin("title"), 13;
          case 11:
            return this.popState(), "title_value";
          case 12:
            return this.begin("acc_title"), 15;
          case 13:
            return this.popState(), "acc_title_value";
          case 14:
            return this.begin("acc_descr"), 17;
          case 15:
            return this.popState(), "acc_descr_value";
          case 16:
            this.begin("acc_descr_multiline");
            break;
          case 17:
            this.popState();
            break;
          case 18:
            return "acc_descr_multiline_value";
          case 19:
            this.begin("string");
            break;
          case 20:
            this.popState();
            break;
          case 21:
            return "txt";
          case 22:
            return 6;
          case 23:
            return 8;
          case 24:
            return "value";
          case 25:
            return 28;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:[\s]+)/i, /^(?:title\b)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:pie\b)/i, /^(?:showData\b)/i, /^(?::[\s]*[\d]+(?:\.[\d]+)?)/i, /^(?:$)/i],
      conditions: { acc_descr_multiline: { rules: [17, 18], inclusive: !1 }, acc_descr: { rules: [15], inclusive: !1 }, acc_title: { rules: [13], inclusive: !1 }, close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, open_directive: { rules: [1], inclusive: !1 }, title: { rules: [11], inclusive: !1 }, string: { rules: [20, 21], inclusive: !1 }, INITIAL: { rules: [0, 5, 6, 7, 8, 9, 10, 12, 14, 16, 19, 22, 23, 24, 25], inclusive: !0 } }
    };
    return V;
  }();
  D.lexer = F;
  function P() {
    this.yy = {};
  }
  return P.prototype = D, D.Parser = P, new P();
}();
c1.parser = c1;
const $O = c1, jO = (t) => t.match(/^\s*pie/) !== null || t.match(/^\s*bar/) !== null;
let uc = {}, G0 = !1;
const XO = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
}, KO = function(t, e) {
  t = Xt.sanitizeText(t, q()), uc[t] === void 0 && (uc[t] = e, B.debug("Added new section :", t));
}, ZO = () => uc, QO = function(t) {
  G0 = t;
}, JO = function() {
  return G0;
}, tP = function(t) {
  return t.substring(0, 1) === ":" && (t = t.substring(1).trim()), Number(t.trim());
}, eP = function() {
  uc = {}, G0 = !1, Br();
}, rP = {
  parseDirective: XO,
  getConfig: () => q().pie,
  addSection: KO,
  getSections: ZO,
  cleanupValue: tP,
  clear: eP,
  setAccTitle: Tr,
  getAccTitle: Dr,
  setDiagramTitle: un,
  getDiagramTitle: hn,
  setShowData: QO,
  getShowData: JO,
  getAccDescription: Mr,
  setAccDescription: Ir
};
let Nn = q(), Rn;
const da = 450, nP = (t, e, r, n) => {
  try {
    Nn = q(), B.debug(`Rendering info diagram
` + t);
    const x = q().securityLevel;
    let D;
    x === "sandbox" && (D = _t("#i" + e));
    const F = _t(x === "sandbox" ? D.nodes()[0].contentDocument.body : "body"), P = x === "sandbox" ? D.nodes()[0].contentDocument : document;
    n.db.clear(), n.parser.parse(t), B.debug("Parsed info diagram");
    const V = P.getElementById(e);
    Rn = V.parentElement.offsetWidth, Rn === void 0 && (Rn = 1200), Nn.useWidth !== void 0 && (Rn = Nn.useWidth), Nn.pie.useWidth !== void 0 && (Rn = Nn.pie.useWidth);
    const R = F.select("#" + e);
    cn(R, da, Rn, Nn.pie.useMaxWidth), V.setAttribute("viewBox", "0 0 " + Rn + " " + da);
    var i = 40, s = 18, a = 4, o = Math.min(Rn, da) / 2 - i, l = R.append("g").attr("transform", "translate(" + Rn / 2 + "," + da / 2 + ")"), u = n.db.getSections(), h = 0;
    Object.keys(u).forEach(function(C) {
      h += u[C];
    });
    const O = Nn.themeVariables;
    var f = [
      O.pie1,
      O.pie2,
      O.pie3,
      O.pie4,
      O.pie5,
      O.pie6,
      O.pie7,
      O.pie8,
      O.pie9,
      O.pie10,
      O.pie11,
      O.pie12
    ], d = Mp().range(f), p = Object.entries(u).map(function(C, S) {
      return {
        order: S,
        name: C[0],
        value: C[1]
      };
    }), m = fk().value(function(C) {
      return C.value;
    }).sort(function(C, S) {
      return C.order - S.order;
    }), _ = m(p), v = xh().innerRadius(0).outerRadius(o);
    l.selectAll("mySlices").data(_).enter().append("path").attr("d", v).attr("fill", function(C) {
      return d(C.data.name);
    }).attr("class", "pieCircle"), l.selectAll("mySlices").data(_).enter().append("text").text(function(C) {
      return (C.data.value / h * 100).toFixed(0) + "%";
    }).attr("transform", function(C) {
      return "translate(" + v.centroid(C) + ")";
    }).style("text-anchor", "middle").attr("class", "slice"), l.append("text").text(n.db.getDiagramTitle()).attr("x", 0).attr("y", -(da - 50) / 2).attr("class", "pieTitleText");
    var k = l.selectAll(".legend").data(d.domain()).enter().append("g").attr("class", "legend").attr("transform", function(C, S) {
      const T = s + a, b = T * d.domain().length / 2, w = 12 * s, g = S * T - b;
      return "translate(" + w + "," + g + ")";
    });
    k.append("rect").attr("width", s).attr("height", s).style("fill", d).style("stroke", d), k.data(_).append("text").attr("x", s + a).attr("y", s - a).text(function(C) {
      return n.db.getShowData() || Nn.showData || Nn.pie.showData ? C.data.name + " [" + C.data.value + "]" : C.data.name;
    });
  } catch (x) {
    B.error("Error while rendering info diagram"), B.error(x);
  }
}, iP = {
  draw: nP
};
var u1 = function() {
  var t = function(Tt, $, j, W) {
    for (j = j || {}, W = Tt.length; W--; j[Tt[W]] = $)
      ;
    return j;
  }, e = [1, 3], r = [1, 5], n = [1, 6], i = [1, 7], s = [1, 8], a = [5, 6, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 71, 72], o = [1, 22], l = [2, 13], u = [1, 26], h = [1, 27], f = [1, 28], d = [1, 29], p = [1, 30], m = [1, 31], _ = [1, 24], v = [1, 32], k = [1, 33], x = [1, 36], D = [71, 72], F = [5, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 60, 62, 71, 72], P = [1, 56], V = [1, 57], R = [1, 58], O = [1, 59], C = [1, 60], S = [1, 61], T = [1, 62], b = [62, 63], w = [1, 74], g = [1, 70], M = [1, 71], y = [1, 72], N = [1, 73], it = [1, 75], Y = [1, 79], Z = [1, 80], J = [1, 77], X = [1, 78], tt = [5, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 71, 72], st = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, directive: 4, NEWLINE: 5, RD: 6, diagram: 7, EOF: 8, openDirective: 9, typeDirective: 10, closeDirective: 11, ":": 12, argDirective: 13, acc_title: 14, acc_title_value: 15, acc_descr: 16, acc_descr_value: 17, acc_descr_multiline_value: 18, open_directive: 19, type_directive: 20, arg_directive: 21, close_directive: 22, requirementDef: 23, elementDef: 24, relationshipDef: 25, requirementType: 26, requirementName: 27, STRUCT_START: 28, requirementBody: 29, ID: 30, COLONSEP: 31, id: 32, TEXT: 33, text: 34, RISK: 35, riskLevel: 36, VERIFYMTHD: 37, verifyType: 38, STRUCT_STOP: 39, REQUIREMENT: 40, FUNCTIONAL_REQUIREMENT: 41, INTERFACE_REQUIREMENT: 42, PERFORMANCE_REQUIREMENT: 43, PHYSICAL_REQUIREMENT: 44, DESIGN_CONSTRAINT: 45, LOW_RISK: 46, MED_RISK: 47, HIGH_RISK: 48, VERIFY_ANALYSIS: 49, VERIFY_DEMONSTRATION: 50, VERIFY_INSPECTION: 51, VERIFY_TEST: 52, ELEMENT: 53, elementName: 54, elementBody: 55, TYPE: 56, type: 57, DOCREF: 58, ref: 59, END_ARROW_L: 60, relationship: 61, LINE: 62, END_ARROW_R: 63, CONTAINS: 64, COPIES: 65, DERIVES: 66, SATISFIES: 67, VERIFIES: 68, REFINES: 69, TRACES: 70, unqString: 71, qString: 72, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 5: "NEWLINE", 6: "RD", 8: "EOF", 12: ":", 14: "acc_title", 15: "acc_title_value", 16: "acc_descr", 17: "acc_descr_value", 18: "acc_descr_multiline_value", 19: "open_directive", 20: "type_directive", 21: "arg_directive", 22: "close_directive", 28: "STRUCT_START", 30: "ID", 31: "COLONSEP", 33: "TEXT", 35: "RISK", 37: "VERIFYMTHD", 39: "STRUCT_STOP", 40: "REQUIREMENT", 41: "FUNCTIONAL_REQUIREMENT", 42: "INTERFACE_REQUIREMENT", 43: "PERFORMANCE_REQUIREMENT", 44: "PHYSICAL_REQUIREMENT", 45: "DESIGN_CONSTRAINT", 46: "LOW_RISK", 47: "MED_RISK", 48: "HIGH_RISK", 49: "VERIFY_ANALYSIS", 50: "VERIFY_DEMONSTRATION", 51: "VERIFY_INSPECTION", 52: "VERIFY_TEST", 53: "ELEMENT", 56: "TYPE", 58: "DOCREF", 60: "END_ARROW_L", 62: "LINE", 63: "END_ARROW_R", 64: "CONTAINS", 65: "COPIES", 66: "DERIVES", 67: "SATISFIES", 68: "VERIFIES", 69: "REFINES", 70: "TRACES", 71: "unqString", 72: "qString" },
    productions_: [0, [3, 3], [3, 2], [3, 4], [4, 3], [4, 5], [4, 2], [4, 2], [4, 1], [9, 1], [10, 1], [13, 1], [11, 1], [7, 0], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [23, 5], [29, 5], [29, 5], [29, 5], [29, 5], [29, 2], [29, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [36, 1], [36, 1], [36, 1], [38, 1], [38, 1], [38, 1], [38, 1], [24, 5], [55, 5], [55, 5], [55, 2], [55, 1], [25, 5], [25, 5], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [27, 1], [27, 1], [32, 1], [32, 1], [34, 1], [34, 1], [54, 1], [54, 1], [57, 1], [57, 1], [59, 1], [59, 1]],
    performAction: function($, j, W, z, A, I, G) {
      var L = I.length - 1;
      switch (A) {
        case 6:
          this.$ = I[L].trim(), z.setAccTitle(this.$);
          break;
        case 7:
        case 8:
          this.$ = I[L].trim(), z.setAccDescription(this.$);
          break;
        case 9:
          z.parseDirective("%%{", "open_directive");
          break;
        case 10:
          z.parseDirective(I[L], "type_directive");
          break;
        case 11:
          I[L] = I[L].trim().replace(/'/g, '"'), z.parseDirective(I[L], "arg_directive");
          break;
        case 12:
          z.parseDirective("}%%", "close_directive", "pie");
          break;
        case 13:
          this.$ = [];
          break;
        case 19:
          z.addRequirement(I[L - 3], I[L - 4]);
          break;
        case 20:
          z.setNewReqId(I[L - 2]);
          break;
        case 21:
          z.setNewReqText(I[L - 2]);
          break;
        case 22:
          z.setNewReqRisk(I[L - 2]);
          break;
        case 23:
          z.setNewReqVerifyMethod(I[L - 2]);
          break;
        case 26:
          this.$ = z.RequirementType.REQUIREMENT;
          break;
        case 27:
          this.$ = z.RequirementType.FUNCTIONAL_REQUIREMENT;
          break;
        case 28:
          this.$ = z.RequirementType.INTERFACE_REQUIREMENT;
          break;
        case 29:
          this.$ = z.RequirementType.PERFORMANCE_REQUIREMENT;
          break;
        case 30:
          this.$ = z.RequirementType.PHYSICAL_REQUIREMENT;
          break;
        case 31:
          this.$ = z.RequirementType.DESIGN_CONSTRAINT;
          break;
        case 32:
          this.$ = z.RiskLevel.LOW_RISK;
          break;
        case 33:
          this.$ = z.RiskLevel.MED_RISK;
          break;
        case 34:
          this.$ = z.RiskLevel.HIGH_RISK;
          break;
        case 35:
          this.$ = z.VerifyType.VERIFY_ANALYSIS;
          break;
        case 36:
          this.$ = z.VerifyType.VERIFY_DEMONSTRATION;
          break;
        case 37:
          this.$ = z.VerifyType.VERIFY_INSPECTION;
          break;
        case 38:
          this.$ = z.VerifyType.VERIFY_TEST;
          break;
        case 39:
          z.addElement(I[L - 3]);
          break;
        case 40:
          z.setNewElementType(I[L - 2]);
          break;
        case 41:
          z.setNewElementDocRef(I[L - 2]);
          break;
        case 44:
          z.addRelationship(I[L - 2], I[L], I[L - 4]);
          break;
        case 45:
          z.addRelationship(I[L - 2], I[L - 4], I[L]);
          break;
        case 46:
          this.$ = z.Relationships.CONTAINS;
          break;
        case 47:
          this.$ = z.Relationships.COPIES;
          break;
        case 48:
          this.$ = z.Relationships.DERIVES;
          break;
        case 49:
          this.$ = z.Relationships.SATISFIES;
          break;
        case 50:
          this.$ = z.Relationships.VERIFIES;
          break;
        case 51:
          this.$ = z.Relationships.REFINES;
          break;
        case 52:
          this.$ = z.Relationships.TRACES;
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 6: e, 9: 4, 14: r, 16: n, 18: i, 19: s }, { 1: [3] }, { 3: 10, 4: 2, 5: [1, 9], 6: e, 9: 4, 14: r, 16: n, 18: i, 19: s }, { 5: [1, 11] }, { 10: 12, 20: [1, 13] }, { 15: [1, 14] }, { 17: [1, 15] }, t(a, [2, 8]), { 20: [2, 9] }, { 3: 16, 4: 2, 6: e, 9: 4, 14: r, 16: n, 18: i, 19: s }, { 1: [2, 2] }, { 4: 21, 5: o, 7: 17, 8: l, 9: 4, 14: r, 16: n, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: u, 41: h, 42: f, 43: d, 44: p, 45: m, 53: _, 71: v, 72: k }, { 11: 34, 12: [1, 35], 22: x }, t([12, 22], [2, 10]), t(a, [2, 6]), t(a, [2, 7]), { 1: [2, 1] }, { 8: [1, 37] }, { 4: 21, 5: o, 7: 38, 8: l, 9: 4, 14: r, 16: n, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: u, 41: h, 42: f, 43: d, 44: p, 45: m, 53: _, 71: v, 72: k }, { 4: 21, 5: o, 7: 39, 8: l, 9: 4, 14: r, 16: n, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: u, 41: h, 42: f, 43: d, 44: p, 45: m, 53: _, 71: v, 72: k }, { 4: 21, 5: o, 7: 40, 8: l, 9: 4, 14: r, 16: n, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: u, 41: h, 42: f, 43: d, 44: p, 45: m, 53: _, 71: v, 72: k }, { 4: 21, 5: o, 7: 41, 8: l, 9: 4, 14: r, 16: n, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: u, 41: h, 42: f, 43: d, 44: p, 45: m, 53: _, 71: v, 72: k }, { 4: 21, 5: o, 7: 42, 8: l, 9: 4, 14: r, 16: n, 18: i, 19: s, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: u, 41: h, 42: f, 43: d, 44: p, 45: m, 53: _, 71: v, 72: k }, { 27: 43, 71: [1, 44], 72: [1, 45] }, { 54: 46, 71: [1, 47], 72: [1, 48] }, { 60: [1, 49], 62: [1, 50] }, t(D, [2, 26]), t(D, [2, 27]), t(D, [2, 28]), t(D, [2, 29]), t(D, [2, 30]), t(D, [2, 31]), t(F, [2, 55]), t(F, [2, 56]), t(a, [2, 4]), { 13: 51, 21: [1, 52] }, t(a, [2, 12]), { 1: [2, 3] }, { 8: [2, 14] }, { 8: [2, 15] }, { 8: [2, 16] }, { 8: [2, 17] }, { 8: [2, 18] }, { 28: [1, 53] }, { 28: [2, 53] }, { 28: [2, 54] }, { 28: [1, 54] }, { 28: [2, 59] }, { 28: [2, 60] }, { 61: 55, 64: P, 65: V, 66: R, 67: O, 68: C, 69: S, 70: T }, { 61: 63, 64: P, 65: V, 66: R, 67: O, 68: C, 69: S, 70: T }, { 11: 64, 22: x }, { 22: [2, 11] }, { 5: [1, 65] }, { 5: [1, 66] }, { 62: [1, 67] }, t(b, [2, 46]), t(b, [2, 47]), t(b, [2, 48]), t(b, [2, 49]), t(b, [2, 50]), t(b, [2, 51]), t(b, [2, 52]), { 63: [1, 68] }, t(a, [2, 5]), { 5: w, 29: 69, 30: g, 33: M, 35: y, 37: N, 39: it }, { 5: Y, 39: Z, 55: 76, 56: J, 58: X }, { 32: 81, 71: v, 72: k }, { 32: 82, 71: v, 72: k }, t(tt, [2, 19]), { 31: [1, 83] }, { 31: [1, 84] }, { 31: [1, 85] }, { 31: [1, 86] }, { 5: w, 29: 87, 30: g, 33: M, 35: y, 37: N, 39: it }, t(tt, [2, 25]), t(tt, [2, 39]), { 31: [1, 88] }, { 31: [1, 89] }, { 5: Y, 39: Z, 55: 90, 56: J, 58: X }, t(tt, [2, 43]), t(tt, [2, 44]), t(tt, [2, 45]), { 32: 91, 71: v, 72: k }, { 34: 92, 71: [1, 93], 72: [1, 94] }, { 36: 95, 46: [1, 96], 47: [1, 97], 48: [1, 98] }, { 38: 99, 49: [1, 100], 50: [1, 101], 51: [1, 102], 52: [1, 103] }, t(tt, [2, 24]), { 57: 104, 71: [1, 105], 72: [1, 106] }, { 59: 107, 71: [1, 108], 72: [1, 109] }, t(tt, [2, 42]), { 5: [1, 110] }, { 5: [1, 111] }, { 5: [2, 57] }, { 5: [2, 58] }, { 5: [1, 112] }, { 5: [2, 32] }, { 5: [2, 33] }, { 5: [2, 34] }, { 5: [1, 113] }, { 5: [2, 35] }, { 5: [2, 36] }, { 5: [2, 37] }, { 5: [2, 38] }, { 5: [1, 114] }, { 5: [2, 61] }, { 5: [2, 62] }, { 5: [1, 115] }, { 5: [2, 63] }, { 5: [2, 64] }, { 5: w, 29: 116, 30: g, 33: M, 35: y, 37: N, 39: it }, { 5: w, 29: 117, 30: g, 33: M, 35: y, 37: N, 39: it }, { 5: w, 29: 118, 30: g, 33: M, 35: y, 37: N, 39: it }, { 5: w, 29: 119, 30: g, 33: M, 35: y, 37: N, 39: it }, { 5: Y, 39: Z, 55: 120, 56: J, 58: X }, { 5: Y, 39: Z, 55: 121, 56: J, 58: X }, t(tt, [2, 20]), t(tt, [2, 21]), t(tt, [2, 22]), t(tt, [2, 23]), t(tt, [2, 40]), t(tt, [2, 41])],
    defaultActions: { 8: [2, 9], 10: [2, 2], 16: [2, 1], 37: [2, 3], 38: [2, 14], 39: [2, 15], 40: [2, 16], 41: [2, 17], 42: [2, 18], 44: [2, 53], 45: [2, 54], 47: [2, 59], 48: [2, 60], 52: [2, 11], 93: [2, 57], 94: [2, 58], 96: [2, 32], 97: [2, 33], 98: [2, 34], 100: [2, 35], 101: [2, 36], 102: [2, 37], 103: [2, 38], 105: [2, 61], 106: [2, 62], 108: [2, 63], 109: [2, 64] },
    parseError: function($, j) {
      if (j.recoverable)
        this.trace($);
      else {
        var W = new Error($);
        throw W.hash = j, W;
      }
    },
    parse: function($) {
      var j = this, W = [0], z = [], A = [null], I = [], G = this.table, L = "", at = 0, E = 0, Dt = 2, et = 1, Et = I.slice.call(arguments, 1), vt = Object.create(this.lexer), pt = { yy: {} };
      for (var ht in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ht) && (pt.yy[ht] = this.yy[ht]);
      vt.setInput($, pt.yy), pt.yy.lexer = vt, pt.yy.parser = this, typeof vt.yylloc > "u" && (vt.yylloc = {});
      var gt = vt.yylloc;
      I.push(gt);
      var ut = vt.options && vt.options.ranges;
      typeof pt.yy.parseError == "function" ? this.parseError = pt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function yt() {
        var mt;
        return mt = z.pop() || vt.lex() || et, typeof mt != "number" && (mt instanceof Array && (z = mt, mt = z.pop()), mt = j.symbols_[mt] || mt), mt;
      }
      for (var ue, re, Mt, Nt, Kt = {}, fe, Gt, Ot, Bt; ; ) {
        if (re = W[W.length - 1], this.defaultActions[re] ? Mt = this.defaultActions[re] : ((ue === null || typeof ue > "u") && (ue = yt()), Mt = G[re] && G[re][ue]), typeof Mt > "u" || !Mt.length || !Mt[0]) {
          var bt = "";
          Bt = [];
          for (fe in G[re])
            this.terminals_[fe] && fe > Dt && Bt.push("'" + this.terminals_[fe] + "'");
          vt.showPosition ? bt = "Parse error on line " + (at + 1) + `:
` + vt.showPosition() + `
Expecting ` + Bt.join(", ") + ", got '" + (this.terminals_[ue] || ue) + "'" : bt = "Parse error on line " + (at + 1) + ": Unexpected " + (ue == et ? "end of input" : "'" + (this.terminals_[ue] || ue) + "'"), this.parseError(bt, {
            text: vt.match,
            token: this.terminals_[ue] || ue,
            line: vt.yylineno,
            loc: gt,
            expected: Bt
          });
        }
        if (Mt[0] instanceof Array && Mt.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + re + ", token: " + ue);
        switch (Mt[0]) {
          case 1:
            W.push(ue), A.push(vt.yytext), I.push(vt.yylloc), W.push(Mt[1]), ue = null, E = vt.yyleng, L = vt.yytext, at = vt.yylineno, gt = vt.yylloc;
            break;
          case 2:
            if (Gt = this.productions_[Mt[1]][1], Kt.$ = A[A.length - Gt], Kt._$ = {
              first_line: I[I.length - (Gt || 1)].first_line,
              last_line: I[I.length - 1].last_line,
              first_column: I[I.length - (Gt || 1)].first_column,
              last_column: I[I.length - 1].last_column
            }, ut && (Kt._$.range = [
              I[I.length - (Gt || 1)].range[0],
              I[I.length - 1].range[1]
            ]), Nt = this.performAction.apply(Kt, [
              L,
              E,
              at,
              pt.yy,
              Mt[1],
              A,
              I
            ].concat(Et)), typeof Nt < "u")
              return Nt;
            Gt && (W = W.slice(0, -1 * Gt * 2), A = A.slice(0, -1 * Gt), I = I.slice(0, -1 * Gt)), W.push(this.productions_[Mt[1]][0]), A.push(Kt.$), I.push(Kt._$), Ot = G[W[W.length - 2]][W[W.length - 1]], W.push(Ot);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, lt = function() {
    var Tt = {
      EOF: 1,
      parseError: function(j, W) {
        if (this.yy.parser)
          this.yy.parser.parseError(j, W);
        else
          throw new Error(j);
      },
      // resets the lexer, sets new input
      setInput: function($, j) {
        return this.yy = j || this.yy || {}, this._input = $, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var $ = this._input[0];
        this.yytext += $, this.yyleng++, this.offset++, this.match += $, this.matched += $;
        var j = $.match(/(?:\r\n?|\n).*/g);
        return j ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), $;
      },
      // unshifts one char (or a string) into the input
      unput: function($) {
        var j = $.length, W = $.split(/(?:\r\n?|\n)/g);
        this._input = $ + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - j), this.offset -= j;
        var z = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), W.length - 1 && (this.yylineno -= W.length - 1);
        var A = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: W ? (W.length === z.length ? this.yylloc.first_column : 0) + z[z.length - W.length].length - W[0].length : this.yylloc.first_column - j
        }, this.options.ranges && (this.yylloc.range = [A[0], A[0] + this.yyleng - j]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function($) {
        this.unput(this.match.slice($));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var $ = this.matched.substr(0, this.matched.length - this.match.length);
        return ($.length > 20 ? "..." : "") + $.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var $ = this.match;
        return $.length < 20 && ($ += this._input.substr(0, 20 - $.length)), ($.substr(0, 20) + ($.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var $ = this.pastInput(), j = new Array($.length + 1).join("-");
        return $ + this.upcomingInput() + `
` + j + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function($, j) {
        var W, z, A;
        if (this.options.backtrack_lexer && (A = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (A.yylloc.range = this.yylloc.range.slice(0))), z = $[0].match(/(?:\r\n?|\n).*/g), z && (this.yylineno += z.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: z ? z[z.length - 1].length - z[z.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + $[0].length
        }, this.yytext += $[0], this.match += $[0], this.matches = $, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice($[0].length), this.matched += $[0], W = this.performAction.call(this, this.yy, this, j, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), W)
          return W;
        if (this._backtrack) {
          for (var I in A)
            this[I] = A[I];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var $, j, W, z;
        this._more || (this.yytext = "", this.match = "");
        for (var A = this._currentRules(), I = 0; I < A.length; I++)
          if (W = this._input.match(this.rules[A[I]]), W && (!j || W[0].length > j[0].length)) {
            if (j = W, z = I, this.options.backtrack_lexer) {
              if ($ = this.test_match(W, A[I]), $ !== !1)
                return $;
              if (this._backtrack) {
                j = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return j ? ($ = this.test_match(j, A[z]), $ !== !1 ? $ : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var j = this.next();
        return j || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(j) {
        this.conditionStack.push(j);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var j = this.conditionStack.length - 1;
        return j > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(j) {
        return j = this.conditionStack.length - 1 - Math.abs(j || 0), j >= 0 ? this.conditionStack[j] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(j) {
        this.begin(j);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(j, W, z, A) {
        switch (z) {
          case 0:
            return this.begin("open_directive"), 19;
          case 1:
            return this.begin("type_directive"), 20;
          case 2:
            return this.popState(), this.begin("arg_directive"), 12;
          case 3:
            return this.popState(), this.popState(), 22;
          case 4:
            return 21;
          case 5:
            return "title";
          case 6:
            return this.begin("acc_title"), 14;
          case 7:
            return this.popState(), "acc_title_value";
          case 8:
            return this.begin("acc_descr"), 16;
          case 9:
            return this.popState(), "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            return 5;
          case 14:
            break;
          case 15:
            break;
          case 16:
            break;
          case 17:
            return 8;
          case 18:
            return 6;
          case 19:
            return 28;
          case 20:
            return 39;
          case 21:
            return 31;
          case 22:
            return 30;
          case 23:
            return 33;
          case 24:
            return 35;
          case 25:
            return 37;
          case 26:
            return 40;
          case 27:
            return 41;
          case 28:
            return 42;
          case 29:
            return 43;
          case 30:
            return 44;
          case 31:
            return 45;
          case 32:
            return 46;
          case 33:
            return 47;
          case 34:
            return 48;
          case 35:
            return 49;
          case 36:
            return 50;
          case 37:
            return 51;
          case 38:
            return 52;
          case 39:
            return 53;
          case 40:
            return 64;
          case 41:
            return 65;
          case 42:
            return 66;
          case 43:
            return 67;
          case 44:
            return 68;
          case 45:
            return 69;
          case 46:
            return 70;
          case 47:
            return 56;
          case 48:
            return 58;
          case 49:
            return 60;
          case 50:
            return 63;
          case 51:
            return 62;
          case 52:
            this.begin("string");
            break;
          case 53:
            this.popState();
            break;
          case 54:
            return "qString";
          case 55:
            return W.yytext = W.yytext.trim(), 71;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:(\r?\n)+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:$)/i, /^(?:requirementDiagram\b)/i, /^(?:\{)/i, /^(?:\})/i, /^(?::)/i, /^(?:id\b)/i, /^(?:text\b)/i, /^(?:risk\b)/i, /^(?:verifyMethod\b)/i, /^(?:requirement\b)/i, /^(?:functionalRequirement\b)/i, /^(?:interfaceRequirement\b)/i, /^(?:performanceRequirement\b)/i, /^(?:physicalRequirement\b)/i, /^(?:designConstraint\b)/i, /^(?:low\b)/i, /^(?:medium\b)/i, /^(?:high\b)/i, /^(?:analysis\b)/i, /^(?:demonstration\b)/i, /^(?:inspection\b)/i, /^(?:test\b)/i, /^(?:element\b)/i, /^(?:contains\b)/i, /^(?:copies\b)/i, /^(?:derives\b)/i, /^(?:satisfies\b)/i, /^(?:verifies\b)/i, /^(?:refines\b)/i, /^(?:traces\b)/i, /^(?:type\b)/i, /^(?:docref\b)/i, /^(?:<-)/i, /^(?:->)/i, /^(?:-)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[\w][^\r\n\{\<\>\-\=]*)/i],
      conditions: { acc_descr_multiline: { rules: [11, 12], inclusive: !1 }, acc_descr: { rules: [9], inclusive: !1 }, acc_title: { rules: [7], inclusive: !1 }, close_directive: { rules: [], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, open_directive: { rules: [1], inclusive: !1 }, unqString: { rules: [], inclusive: !1 }, token: { rules: [], inclusive: !1 }, string: { rules: [53, 54], inclusive: !1 }, INITIAL: { rules: [0, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 55], inclusive: !0 } }
    };
    return Tt;
  }();
  st.lexer = lt;
  function U() {
    this.yy = {};
  }
  return U.prototype = st, st.Parser = U, new U();
}();
u1.parser = u1;
const sP = u1, aP = (t) => t.match(/^\s*requirement(Diagram)?/) !== null;
let q0 = [], vr = {}, Ia = {}, di = {}, Ma = {};
const oP = {
  REQUIREMENT: "Requirement",
  FUNCTIONAL_REQUIREMENT: "Functional Requirement",
  INTERFACE_REQUIREMENT: "Interface Requirement",
  PERFORMANCE_REQUIREMENT: "Performance Requirement",
  PHYSICAL_REQUIREMENT: "Physical Requirement",
  DESIGN_CONSTRAINT: "Design Constraint"
}, lP = {
  LOW_RISK: "Low",
  MED_RISK: "Medium",
  HIGH_RISK: "High"
}, cP = {
  VERIFY_ANALYSIS: "Analysis",
  VERIFY_DEMONSTRATION: "Demonstration",
  VERIFY_INSPECTION: "Inspection",
  VERIFY_TEST: "Test"
}, uP = {
  CONTAINS: "contains",
  COPIES: "copies",
  DERIVES: "derives",
  SATISFIES: "satisfies",
  VERIFIES: "verifies",
  REFINES: "refines",
  TRACES: "traces"
}, hP = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
}, fP = (t, e) => (Ia[t] === void 0 && (Ia[t] = {
  name: t,
  type: e,
  id: vr.id,
  text: vr.text,
  risk: vr.risk,
  verifyMethod: vr.verifyMethod
}), vr = {}, Ia[t]), dP = () => Ia, pP = (t) => {
  vr !== void 0 && (vr.id = t);
}, gP = (t) => {
  vr !== void 0 && (vr.text = t);
}, yP = (t) => {
  vr !== void 0 && (vr.risk = t);
}, mP = (t) => {
  vr !== void 0 && (vr.verifyMethod = t);
}, bP = (t) => (Ma[t] === void 0 && (Ma[t] = {
  name: t,
  type: di.type,
  docRef: di.docRef
}, B.info("Added new requirement: ", t)), di = {}, Ma[t]), _P = () => Ma, xP = (t) => {
  di !== void 0 && (di.type = t);
}, vP = (t) => {
  di !== void 0 && (di.docRef = t);
}, kP = (t, e, r) => {
  q0.push({
    type: t,
    src: e,
    dst: r
  });
}, wP = () => q0, TP = () => {
  q0 = [], vr = {}, Ia = {}, di = {}, Ma = {}, Br();
}, EP = {
  RequirementType: oP,
  RiskLevel: lP,
  VerifyType: cP,
  Relationships: uP,
  parseDirective: hP,
  getConfig: () => q().req,
  addRequirement: fP,
  getRequirements: dP,
  setNewReqId: pP,
  setNewReqText: gP,
  setNewReqRisk: yP,
  setNewReqVerifyMethod: mP,
  setAccTitle: Tr,
  getAccTitle: Dr,
  setAccDescription: Ir,
  getAccDescription: Mr,
  addElement: bP,
  getElements: _P,
  setNewElementType: xP,
  setNewElementDocRef: vP,
  addRelationship: kP,
  getRelationships: wP,
  clear: TP
}, h1 = {
  CONTAINS: "contains",
  ARROW: "arrow"
}, CP = (t, e) => {
  let r = t.append("defs").append("marker").attr("id", h1.CONTAINS + "_line_ending").attr("refX", 0).attr("refY", e.line_height / 2).attr("markerWidth", e.line_height).attr("markerHeight", e.line_height).attr("orient", "auto").append("g");
  r.append("circle").attr("cx", e.line_height / 2).attr("cy", e.line_height / 2).attr("r", e.line_height / 2).attr("fill", "none"), r.append("line").attr("x1", 0).attr("x2", e.line_height).attr("y1", e.line_height / 2).attr("y2", e.line_height / 2).attr("stroke-width", 1), r.append("line").attr("y1", 0).attr("y2", e.line_height).attr("x1", e.line_height / 2).attr("x2", e.line_height / 2).attr("stroke-width", 1), t.append("defs").append("marker").attr("id", h1.ARROW + "_line_ending").attr("refX", e.line_height).attr("refY", 0.5 * e.line_height).attr("markerWidth", e.line_height).attr("markerHeight", e.line_height).attr("orient", "auto").append("path").attr(
    "d",
    `M0,0
      L${e.line_height},${e.line_height / 2}
      M${e.line_height},${e.line_height / 2}
      L0,${e.line_height}`
  ).attr("stroke-width", 1);
}, Q3 = {
  ReqMarkers: h1,
  insertLineEndings: CP
};
let Te = {}, L2 = 0;
const J3 = (t, e) => t.insert("rect", "#" + e).attr("class", "req reqBox").attr("x", 0).attr("y", 0).attr("width", Te.rect_min_width + "px").attr("height", Te.rect_min_height + "px"), t4 = (t, e, r) => {
  let n = Te.rect_min_width / 2, i = t.append("text").attr("class", "req reqLabel reqTitle").attr("id", e).attr("x", n).attr("y", Te.rect_padding).attr("dominant-baseline", "hanging"), s = 0;
  r.forEach((u) => {
    s == 0 ? i.append("tspan").attr("text-anchor", "middle").attr("x", Te.rect_min_width / 2).attr("dy", 0).text(u) : i.append("tspan").attr("text-anchor", "middle").attr("x", Te.rect_min_width / 2).attr("dy", Te.line_height * 0.75).text(u), s++;
  });
  let a = 1.5 * Te.rect_padding, o = s * Te.line_height * 0.75, l = a + o;
  return t.append("line").attr("class", "req-title-line").attr("x1", "0").attr("x2", Te.rect_min_width).attr("y1", l).attr("y2", l), {
    titleNode: i,
    y: l
  };
}, e4 = (t, e, r, n) => {
  let i = t.append("text").attr("class", "req reqLabel").attr("id", e).attr("x", Te.rect_padding).attr("y", n).attr("dominant-baseline", "hanging"), s = 0;
  const a = 30;
  let o = [];
  return r.forEach((l) => {
    let u = l.length;
    for (; u > a && s < 3; ) {
      let h = l.substring(0, a);
      l = l.substring(a, l.length), u = l.length, o[o.length] = h, s++;
    }
    if (s == 3) {
      let h = o[o.length - 1];
      o[o.length - 1] = h.substring(0, h.length - 4) + "...";
    } else
      o[o.length] = l;
    s = 0;
  }), o.forEach((l) => {
    i.append("tspan").attr("x", Te.rect_padding).attr("dy", Te.line_height).text(l);
  }), i;
}, SP = (t, e, r, n) => {
  const i = e.node().getTotalLength(), s = e.node().getPointAtLength(i * 0.5), a = "rel" + L2;
  L2++;
  const l = t.append("text").attr("class", "req relationshipLabel").attr("id", a).attr("x", s.x).attr("y", s.y).attr("text-anchor", "middle").attr("dominant-baseline", "middle").text(n).node().getBBox();
  t.insert("rect", "#" + a).attr("class", "req reqLabelBox").attr("x", s.x - l.width / 2).attr("y", s.y - l.height / 2).attr("width", l.width).attr("height", l.height).attr("fill", "white").attr("fill-opacity", "85%");
}, AP = function(t, e, r, n, i) {
  const s = r.edge(Ws(e.src), Ws(e.dst)), a = js().x(function(l) {
    return l.x;
  }).y(function(l) {
    return l.y;
  }), o = t.insert("path", "#" + n).attr("class", "er relationshipLine").attr("d", a(s.points)).attr("fill", "none");
  e.type == i.db.Relationships.CONTAINS ? o.attr(
    "marker-start",
    "url(" + Xt.getUrl(Te.arrowMarkerAbsolute) + "#" + e.type + "_line_ending)"
  ) : (o.attr("stroke-dasharray", "10,7"), o.attr(
    "marker-end",
    "url(" + Xt.getUrl(Te.arrowMarkerAbsolute) + "#" + Q3.ReqMarkers.ARROW + "_line_ending)"
  )), SP(t, o, Te, `<<${e.type}>>`);
}, LP = (t, e, r) => {
  Object.keys(t).forEach((n) => {
    let i = t[n];
    n = Ws(n), B.info("Added new requirement: ", n);
    const s = r.append("g").attr("id", n), a = "req-" + n, o = J3(s, a);
    let l = t4(s, n + "_title", [
      `<<${i.type}>>`,
      `${i.name}`
    ]);
    e4(
      s,
      n + "_body",
      [
        `Id: ${i.id}`,
        `Text: ${i.text}`,
        `Risk: ${i.risk}`,
        `Verification: ${i.verifyMethod}`
      ],
      l.y
    );
    const u = o.node().getBBox();
    e.setNode(n, {
      width: u.width,
      height: u.height,
      shape: "rect",
      id: n
    });
  });
}, BP = (t, e, r) => {
  Object.keys(t).forEach((n) => {
    let i = t[n];
    const s = Ws(n), a = r.append("g").attr("id", s), o = "element-" + s, l = J3(a, o);
    let u = t4(a, o + "_title", ["<<Element>>", `${n}`]);
    e4(
      a,
      o + "_body",
      [`Type: ${i.type || "Not Specified"}`, `Doc Ref: ${i.docRef || "None"}`],
      u.y
    );
    const h = l.node().getBBox();
    e.setNode(s, {
      width: h.width,
      height: h.height,
      shape: "rect",
      id: s
    });
  });
}, DP = (t, e) => (t.forEach(function(r) {
  let n = Ws(r.src), i = Ws(r.dst);
  e.setEdge(n, i, { relationship: r });
}), t), IP = function(t, e) {
  e.nodes().forEach(function(r) {
    r !== void 0 && e.node(r) !== void 0 && (t.select("#" + r), t.select("#" + r).attr(
      "transform",
      "translate(" + (e.node(r).x - e.node(r).width / 2) + "," + (e.node(r).y - e.node(r).height / 2) + " )"
    ));
  });
}, Ws = (t) => t.replace(/\s/g, "").replace(/\./g, "_"), MP = (t, e, r, n) => {
  Te = q().requirement, n.db.clear(), n.parser.parse(t);
  const i = Te.securityLevel;
  let s;
  i === "sandbox" && (s = _t("#i" + e));
  const o = _t(i === "sandbox" ? s.nodes()[0].contentDocument.body : "body").select(`[id='${e}']`);
  Q3.insertLineEndings(o, Te);
  const l = new Ve({
    multigraph: !1,
    compound: !1,
    directed: !0
  }).setGraph({
    rankdir: Te.layoutDirection,
    marginx: 20,
    marginy: 20,
    nodesep: 100,
    edgesep: 100,
    ranksep: 100
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let u = n.db.getRequirements(), h = n.db.getElements(), f = n.db.getRelationships();
  LP(u, l, o), BP(h, l, o), DP(f, l), ta(l), IP(o, l), f.forEach(function(v) {
    AP(o, v, l, e, n);
  });
  const d = Te.rect_padding, p = o.node().getBBox(), m = p.width + d * 2, _ = p.height + d * 2;
  cn(o, _, m, Te.useMaxWidth), o.attr("viewBox", `${p.x - d} ${p.y - d} ${m} ${_}`);
}, NP = {
  draw: MP
};
var f1 = function() {
  var t = function(j, W, z, A) {
    for (z = z || {}, A = j.length; A--; z[j[A]] = W)
      ;
    return z;
  }, e = [1, 2], r = [1, 3], n = [1, 5], i = [1, 7], s = [2, 5], a = [1, 15], o = [1, 17], l = [1, 19], u = [1, 21], h = [1, 22], f = [1, 23], d = [1, 29], p = [1, 30], m = [1, 31], _ = [1, 32], v = [1, 33], k = [1, 34], x = [1, 35], D = [1, 36], F = [1, 37], P = [1, 38], V = [1, 39], R = [1, 40], O = [1, 42], C = [1, 43], S = [1, 45], T = [1, 46], b = [1, 47], w = [1, 48], g = [1, 49], M = [1, 50], y = [1, 53], N = [1, 4, 5, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 51, 52, 53, 54, 56, 57, 62, 63, 64, 65, 73, 83], it = [4, 5, 21, 54, 56], Y = [4, 5, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 54, 56, 57, 62, 63, 64, 65, 73, 83], Z = [4, 5, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 53, 54, 56, 57, 62, 63, 64, 65, 73, 83], J = [4, 5, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 52, 54, 56, 57, 62, 63, 64, 65, 73, 83], X = [4, 5, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 51, 54, 56, 57, 62, 63, 64, 65, 73, 83], tt = [71, 72, 73], st = [1, 125], lt = [1, 4, 5, 7, 19, 21, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 51, 52, 53, 54, 56, 57, 62, 63, 64, 65, 73, 83], U = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, SPACE: 4, NEWLINE: 5, directive: 6, SD: 7, document: 8, line: 9, statement: 10, box_section: 11, box_line: 12, participant_statement: 13, openDirective: 14, typeDirective: 15, closeDirective: 16, ":": 17, argDirective: 18, box: 19, restOfLine: 20, end: 21, signal: 22, autonumber: 23, NUM: 24, off: 25, activate: 26, actor: 27, deactivate: 28, note_statement: 29, links_statement: 30, link_statement: 31, properties_statement: 32, details_statement: 33, title: 34, legacy_title: 35, acc_title: 36, acc_title_value: 37, acc_descr: 38, acc_descr_value: 39, acc_descr_multiline_value: 40, loop: 41, rect: 42, opt: 43, alt: 44, else_sections: 45, par: 46, par_sections: 47, critical: 48, option_sections: 49, break: 50, option: 51, and: 52, else: 53, participant: 54, AS: 55, participant_actor: 56, note: 57, placement: 58, text2: 59, over: 60, actor_pair: 61, links: 62, link: 63, properties: 64, details: 65, spaceList: 66, ",": 67, left_of: 68, right_of: 69, signaltype: 70, "+": 71, "-": 72, ACTOR: 73, SOLID_OPEN_ARROW: 74, DOTTED_OPEN_ARROW: 75, SOLID_ARROW: 76, DOTTED_ARROW: 77, SOLID_CROSS: 78, DOTTED_CROSS: 79, SOLID_POINT: 80, DOTTED_POINT: 81, TXT: 82, open_directive: 83, type_directive: 84, arg_directive: 85, close_directive: 86, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NEWLINE", 7: "SD", 17: ":", 19: "box", 20: "restOfLine", 21: "end", 23: "autonumber", 24: "NUM", 25: "off", 26: "activate", 28: "deactivate", 34: "title", 35: "legacy_title", 36: "acc_title", 37: "acc_title_value", 38: "acc_descr", 39: "acc_descr_value", 40: "acc_descr_multiline_value", 41: "loop", 42: "rect", 43: "opt", 44: "alt", 46: "par", 48: "critical", 50: "break", 51: "option", 52: "and", 53: "else", 54: "participant", 55: "AS", 56: "participant_actor", 57: "note", 60: "over", 62: "links", 63: "link", 64: "properties", 65: "details", 67: ",", 68: "left_of", 69: "right_of", 71: "+", 72: "-", 73: "ACTOR", 74: "SOLID_OPEN_ARROW", 75: "DOTTED_OPEN_ARROW", 76: "SOLID_ARROW", 77: "DOTTED_ARROW", 78: "SOLID_CROSS", 79: "DOTTED_CROSS", 80: "SOLID_POINT", 81: "DOTTED_POINT", 82: "TXT", 83: "open_directive", 84: "type_directive", 85: "arg_directive", 86: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [8, 0], [8, 2], [9, 2], [9, 1], [9, 1], [11, 0], [11, 2], [12, 2], [12, 1], [12, 1], [6, 4], [6, 6], [10, 1], [10, 4], [10, 2], [10, 4], [10, 3], [10, 3], [10, 2], [10, 3], [10, 3], [10, 2], [10, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 1], [49, 1], [49, 4], [47, 1], [47, 4], [45, 1], [45, 4], [13, 5], [13, 3], [13, 5], [13, 3], [29, 4], [29, 4], [30, 3], [31, 3], [32, 3], [33, 3], [66, 2], [66, 1], [61, 3], [61, 1], [58, 1], [58, 1], [22, 5], [22, 5], [22, 4], [27, 1], [70, 1], [70, 1], [70, 1], [70, 1], [70, 1], [70, 1], [70, 1], [70, 1], [59, 1], [14, 1], [15, 1], [18, 1], [16, 1]],
    performAction: function(W, z, A, I, G, L, at) {
      var E = L.length - 1;
      switch (G) {
        case 4:
          return I.apply(L[E]), L[E];
        case 5:
        case 10:
          this.$ = [];
          break;
        case 6:
        case 11:
          L[E - 1].push(L[E]), this.$ = L[E - 1];
          break;
        case 7:
        case 8:
        case 12:
        case 13:
          this.$ = L[E];
          break;
        case 9:
        case 14:
          this.$ = [];
          break;
        case 18:
          L[E - 1].unshift({ type: "boxStart", boxData: I.parseBoxData(L[E - 2]) }), L[E - 1].push({ type: "boxEnd", boxText: L[E - 2] }), this.$ = L[E - 1];
          break;
        case 20:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number(L[E - 2]), sequenceIndexStep: Number(L[E - 1]), sequenceVisible: !0, signalType: I.LINETYPE.AUTONUMBER };
          break;
        case 21:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number(L[E - 1]), sequenceIndexStep: 1, sequenceVisible: !0, signalType: I.LINETYPE.AUTONUMBER };
          break;
        case 22:
          this.$ = { type: "sequenceIndex", sequenceVisible: !1, signalType: I.LINETYPE.AUTONUMBER };
          break;
        case 23:
          this.$ = { type: "sequenceIndex", sequenceVisible: !0, signalType: I.LINETYPE.AUTONUMBER };
          break;
        case 24:
          this.$ = { type: "activeStart", signalType: I.LINETYPE.ACTIVE_START, actor: L[E - 1] };
          break;
        case 25:
          this.$ = { type: "activeEnd", signalType: I.LINETYPE.ACTIVE_END, actor: L[E - 1] };
          break;
        case 31:
          I.setDiagramTitle(L[E].substring(6)), this.$ = L[E].substring(6);
          break;
        case 32:
          I.setDiagramTitle(L[E].substring(7)), this.$ = L[E].substring(7);
          break;
        case 33:
          this.$ = L[E].trim(), I.setAccTitle(this.$);
          break;
        case 34:
        case 35:
          this.$ = L[E].trim(), I.setAccDescription(this.$);
          break;
        case 36:
          L[E - 1].unshift({ type: "loopStart", loopText: I.parseMessage(L[E - 2]), signalType: I.LINETYPE.LOOP_START }), L[E - 1].push({ type: "loopEnd", loopText: L[E - 2], signalType: I.LINETYPE.LOOP_END }), this.$ = L[E - 1];
          break;
        case 37:
          L[E - 1].unshift({ type: "rectStart", color: I.parseMessage(L[E - 2]), signalType: I.LINETYPE.RECT_START }), L[E - 1].push({ type: "rectEnd", color: I.parseMessage(L[E - 2]), signalType: I.LINETYPE.RECT_END }), this.$ = L[E - 1];
          break;
        case 38:
          L[E - 1].unshift({ type: "optStart", optText: I.parseMessage(L[E - 2]), signalType: I.LINETYPE.OPT_START }), L[E - 1].push({ type: "optEnd", optText: I.parseMessage(L[E - 2]), signalType: I.LINETYPE.OPT_END }), this.$ = L[E - 1];
          break;
        case 39:
          L[E - 1].unshift({ type: "altStart", altText: I.parseMessage(L[E - 2]), signalType: I.LINETYPE.ALT_START }), L[E - 1].push({ type: "altEnd", signalType: I.LINETYPE.ALT_END }), this.$ = L[E - 1];
          break;
        case 40:
          L[E - 1].unshift({ type: "parStart", parText: I.parseMessage(L[E - 2]), signalType: I.LINETYPE.PAR_START }), L[E - 1].push({ type: "parEnd", signalType: I.LINETYPE.PAR_END }), this.$ = L[E - 1];
          break;
        case 41:
          L[E - 1].unshift({ type: "criticalStart", criticalText: I.parseMessage(L[E - 2]), signalType: I.LINETYPE.CRITICAL_START }), L[E - 1].push({ type: "criticalEnd", signalType: I.LINETYPE.CRITICAL_END }), this.$ = L[E - 1];
          break;
        case 42:
          L[E - 1].unshift({ type: "breakStart", breakText: I.parseMessage(L[E - 2]), signalType: I.LINETYPE.BREAK_START }), L[E - 1].push({ type: "breakEnd", optText: I.parseMessage(L[E - 2]), signalType: I.LINETYPE.BREAK_END }), this.$ = L[E - 1];
          break;
        case 45:
          this.$ = L[E - 3].concat([{ type: "option", optionText: I.parseMessage(L[E - 1]), signalType: I.LINETYPE.CRITICAL_OPTION }, L[E]]);
          break;
        case 47:
          this.$ = L[E - 3].concat([{ type: "and", parText: I.parseMessage(L[E - 1]), signalType: I.LINETYPE.PAR_AND }, L[E]]);
          break;
        case 49:
          this.$ = L[E - 3].concat([{ type: "else", altText: I.parseMessage(L[E - 1]), signalType: I.LINETYPE.ALT_ELSE }, L[E]]);
          break;
        case 50:
          L[E - 3].type = "addParticipant", L[E - 3].description = I.parseMessage(L[E - 1]), this.$ = L[E - 3];
          break;
        case 51:
          L[E - 1].type = "addParticipant", this.$ = L[E - 1];
          break;
        case 52:
          L[E - 3].type = "addActor", L[E - 3].description = I.parseMessage(L[E - 1]), this.$ = L[E - 3];
          break;
        case 53:
          L[E - 1].type = "addActor", this.$ = L[E - 1];
          break;
        case 54:
          this.$ = [L[E - 1], { type: "addNote", placement: L[E - 2], actor: L[E - 1].actor, text: L[E] }];
          break;
        case 55:
          L[E - 2] = [].concat(L[E - 1], L[E - 1]).slice(0, 2), L[E - 2][0] = L[E - 2][0].actor, L[E - 2][1] = L[E - 2][1].actor, this.$ = [L[E - 1], { type: "addNote", placement: I.PLACEMENT.OVER, actor: L[E - 2].slice(0, 2), text: L[E] }];
          break;
        case 56:
          this.$ = [L[E - 1], { type: "addLinks", actor: L[E - 1].actor, text: L[E] }];
          break;
        case 57:
          this.$ = [L[E - 1], { type: "addALink", actor: L[E - 1].actor, text: L[E] }];
          break;
        case 58:
          this.$ = [L[E - 1], { type: "addProperties", actor: L[E - 1].actor, text: L[E] }];
          break;
        case 59:
          this.$ = [L[E - 1], { type: "addDetails", actor: L[E - 1].actor, text: L[E] }];
          break;
        case 62:
          this.$ = [L[E - 2], L[E]];
          break;
        case 63:
          this.$ = L[E];
          break;
        case 64:
          this.$ = I.PLACEMENT.LEFTOF;
          break;
        case 65:
          this.$ = I.PLACEMENT.RIGHTOF;
          break;
        case 66:
          this.$ = [
            L[E - 4],
            L[E - 1],
            { type: "addMessage", from: L[E - 4].actor, to: L[E - 1].actor, signalType: L[E - 3], msg: L[E] },
            { type: "activeStart", signalType: I.LINETYPE.ACTIVE_START, actor: L[E - 1] }
          ];
          break;
        case 67:
          this.$ = [
            L[E - 4],
            L[E - 1],
            { type: "addMessage", from: L[E - 4].actor, to: L[E - 1].actor, signalType: L[E - 3], msg: L[E] },
            { type: "activeEnd", signalType: I.LINETYPE.ACTIVE_END, actor: L[E - 4] }
          ];
          break;
        case 68:
          this.$ = [L[E - 3], L[E - 1], { type: "addMessage", from: L[E - 3].actor, to: L[E - 1].actor, signalType: L[E - 2], msg: L[E] }];
          break;
        case 69:
          this.$ = { type: "addParticipant", actor: L[E] };
          break;
        case 70:
          this.$ = I.LINETYPE.SOLID_OPEN;
          break;
        case 71:
          this.$ = I.LINETYPE.DOTTED_OPEN;
          break;
        case 72:
          this.$ = I.LINETYPE.SOLID;
          break;
        case 73:
          this.$ = I.LINETYPE.DOTTED;
          break;
        case 74:
          this.$ = I.LINETYPE.SOLID_CROSS;
          break;
        case 75:
          this.$ = I.LINETYPE.DOTTED_CROSS;
          break;
        case 76:
          this.$ = I.LINETYPE.SOLID_POINT;
          break;
        case 77:
          this.$ = I.LINETYPE.DOTTED_POINT;
          break;
        case 78:
          this.$ = I.parseMessage(L[E].trim().substring(1));
          break;
        case 79:
          I.parseDirective("%%{", "open_directive");
          break;
        case 80:
          I.parseDirective(L[E], "type_directive");
          break;
        case 81:
          L[E] = L[E].trim().replace(/'/g, '"'), I.parseDirective(L[E], "arg_directive");
          break;
        case 82:
          I.parseDirective("}%%", "close_directive", "sequence");
          break;
      }
    },
    table: [{ 3: 1, 4: e, 5: r, 6: 4, 7: n, 14: 6, 83: i }, { 1: [3] }, { 3: 8, 4: e, 5: r, 6: 4, 7: n, 14: 6, 83: i }, { 3: 9, 4: e, 5: r, 6: 4, 7: n, 14: 6, 83: i }, { 3: 10, 4: e, 5: r, 6: 4, 7: n, 14: 6, 83: i }, t([1, 4, 5, 19, 23, 26, 28, 34, 35, 36, 38, 40, 41, 42, 43, 44, 46, 48, 50, 54, 56, 57, 62, 63, 64, 65, 73, 83], s, { 8: 11 }), { 15: 12, 84: [1, 13] }, { 84: [2, 79] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4], 4: a, 5: o, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 22: 20, 23: u, 26: h, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: m, 38: _, 40: v, 41: k, 42: x, 43: D, 44: F, 46: P, 48: V, 50: R, 54: O, 56: C, 57: S, 62: T, 63: b, 64: w, 65: g, 73: M, 83: i }, { 16: 51, 17: [1, 52], 86: y }, t([17, 86], [2, 80]), t(N, [2, 6]), { 6: 41, 10: 54, 13: 18, 14: 6, 19: l, 22: 20, 23: u, 26: h, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: m, 38: _, 40: v, 41: k, 42: x, 43: D, 44: F, 46: P, 48: V, 50: R, 54: O, 56: C, 57: S, 62: T, 63: b, 64: w, 65: g, 73: M, 83: i }, t(N, [2, 8]), t(N, [2, 9]), t(N, [2, 17]), { 20: [1, 55] }, { 5: [1, 56] }, { 5: [1, 59], 24: [1, 57], 25: [1, 58] }, { 27: 60, 73: M }, { 27: 61, 73: M }, { 5: [1, 62] }, { 5: [1, 63] }, { 5: [1, 64] }, { 5: [1, 65] }, { 5: [1, 66] }, t(N, [2, 31]), t(N, [2, 32]), { 37: [1, 67] }, { 39: [1, 68] }, t(N, [2, 35]), { 20: [1, 69] }, { 20: [1, 70] }, { 20: [1, 71] }, { 20: [1, 72] }, { 20: [1, 73] }, { 20: [1, 74] }, { 20: [1, 75] }, t(N, [2, 43]), { 27: 76, 73: M }, { 27: 77, 73: M }, { 70: 78, 74: [1, 79], 75: [1, 80], 76: [1, 81], 77: [1, 82], 78: [1, 83], 79: [1, 84], 80: [1, 85], 81: [1, 86] }, { 58: 87, 60: [1, 88], 68: [1, 89], 69: [1, 90] }, { 27: 91, 73: M }, { 27: 92, 73: M }, { 27: 93, 73: M }, { 27: 94, 73: M }, t([5, 55, 67, 74, 75, 76, 77, 78, 79, 80, 81, 82], [2, 69]), { 5: [1, 95] }, { 18: 96, 85: [1, 97] }, { 5: [2, 82] }, t(N, [2, 7]), t(it, [2, 10], { 11: 98 }), t(N, [2, 19]), { 5: [1, 100], 24: [1, 99] }, { 5: [1, 101] }, t(N, [2, 23]), { 5: [1, 102] }, { 5: [1, 103] }, t(N, [2, 26]), t(N, [2, 27]), t(N, [2, 28]), t(N, [2, 29]), t(N, [2, 30]), t(N, [2, 33]), t(N, [2, 34]), t(Y, s, { 8: 104 }), t(Y, s, { 8: 105 }), t(Y, s, { 8: 106 }), t(Z, s, { 45: 107, 8: 108 }), t(J, s, { 47: 109, 8: 110 }), t(X, s, { 49: 111, 8: 112 }), t(Y, s, { 8: 113 }), { 5: [1, 115], 55: [1, 114] }, { 5: [1, 117], 55: [1, 116] }, { 27: 120, 71: [1, 118], 72: [1, 119], 73: M }, t(tt, [2, 70]), t(tt, [2, 71]), t(tt, [2, 72]), t(tt, [2, 73]), t(tt, [2, 74]), t(tt, [2, 75]), t(tt, [2, 76]), t(tt, [2, 77]), { 27: 121, 73: M }, { 27: 123, 61: 122, 73: M }, { 73: [2, 64] }, { 73: [2, 65] }, { 59: 124, 82: st }, { 59: 126, 82: st }, { 59: 127, 82: st }, { 59: 128, 82: st }, t(lt, [2, 15]), { 16: 129, 86: y }, { 86: [2, 81] }, { 4: [1, 132], 5: [1, 134], 12: 131, 13: 133, 21: [1, 130], 54: O, 56: C }, { 5: [1, 135] }, t(N, [2, 21]), t(N, [2, 22]), t(N, [2, 24]), t(N, [2, 25]), { 4: a, 5: o, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [1, 136], 22: 20, 23: u, 26: h, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: m, 38: _, 40: v, 41: k, 42: x, 43: D, 44: F, 46: P, 48: V, 50: R, 54: O, 56: C, 57: S, 62: T, 63: b, 64: w, 65: g, 73: M, 83: i }, { 4: a, 5: o, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [1, 137], 22: 20, 23: u, 26: h, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: m, 38: _, 40: v, 41: k, 42: x, 43: D, 44: F, 46: P, 48: V, 50: R, 54: O, 56: C, 57: S, 62: T, 63: b, 64: w, 65: g, 73: M, 83: i }, { 4: a, 5: o, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [1, 138], 22: 20, 23: u, 26: h, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: m, 38: _, 40: v, 41: k, 42: x, 43: D, 44: F, 46: P, 48: V, 50: R, 54: O, 56: C, 57: S, 62: T, 63: b, 64: w, 65: g, 73: M, 83: i }, { 21: [1, 139] }, { 4: a, 5: o, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [2, 48], 22: 20, 23: u, 26: h, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: m, 38: _, 40: v, 41: k, 42: x, 43: D, 44: F, 46: P, 48: V, 50: R, 53: [1, 140], 54: O, 56: C, 57: S, 62: T, 63: b, 64: w, 65: g, 73: M, 83: i }, { 21: [1, 141] }, { 4: a, 5: o, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [2, 46], 22: 20, 23: u, 26: h, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: m, 38: _, 40: v, 41: k, 42: x, 43: D, 44: F, 46: P, 48: V, 50: R, 52: [1, 142], 54: O, 56: C, 57: S, 62: T, 63: b, 64: w, 65: g, 73: M, 83: i }, { 21: [1, 143] }, { 4: a, 5: o, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [2, 44], 22: 20, 23: u, 26: h, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: m, 38: _, 40: v, 41: k, 42: x, 43: D, 44: F, 46: P, 48: V, 50: R, 51: [1, 144], 54: O, 56: C, 57: S, 62: T, 63: b, 64: w, 65: g, 73: M, 83: i }, { 4: a, 5: o, 6: 41, 9: 14, 10: 16, 13: 18, 14: 6, 19: l, 21: [1, 145], 22: 20, 23: u, 26: h, 27: 44, 28: f, 29: 24, 30: 25, 31: 26, 32: 27, 33: 28, 34: d, 35: p, 36: m, 38: _, 40: v, 41: k, 42: x, 43: D, 44: F, 46: P, 48: V, 50: R, 54: O, 56: C, 57: S, 62: T, 63: b, 64: w, 65: g, 73: M, 83: i }, { 20: [1, 146] }, t(N, [2, 51]), { 20: [1, 147] }, t(N, [2, 53]), { 27: 148, 73: M }, { 27: 149, 73: M }, { 59: 150, 82: st }, { 59: 151, 82: st }, { 59: 152, 82: st }, { 67: [1, 153], 82: [2, 63] }, { 5: [2, 56] }, { 5: [2, 78] }, { 5: [2, 57] }, { 5: [2, 58] }, { 5: [2, 59] }, { 5: [1, 154] }, t(N, [2, 18]), t(it, [2, 11]), { 13: 155, 54: O, 56: C }, t(it, [2, 13]), t(it, [2, 14]), t(N, [2, 20]), t(N, [2, 36]), t(N, [2, 37]), t(N, [2, 38]), t(N, [2, 39]), { 20: [1, 156] }, t(N, [2, 40]), { 20: [1, 157] }, t(N, [2, 41]), { 20: [1, 158] }, t(N, [2, 42]), { 5: [1, 159] }, { 5: [1, 160] }, { 59: 161, 82: st }, { 59: 162, 82: st }, { 5: [2, 68] }, { 5: [2, 54] }, { 5: [2, 55] }, { 27: 163, 73: M }, t(lt, [2, 16]), t(it, [2, 12]), t(Z, s, { 8: 108, 45: 164 }), t(J, s, { 8: 110, 47: 165 }), t(X, s, { 8: 112, 49: 166 }), t(N, [2, 50]), t(N, [2, 52]), { 5: [2, 66] }, { 5: [2, 67] }, { 82: [2, 62] }, { 21: [2, 49] }, { 21: [2, 47] }, { 21: [2, 45] }],
    defaultActions: { 7: [2, 79], 8: [2, 1], 9: [2, 2], 10: [2, 3], 53: [2, 82], 89: [2, 64], 90: [2, 65], 97: [2, 81], 124: [2, 56], 125: [2, 78], 126: [2, 57], 127: [2, 58], 128: [2, 59], 150: [2, 68], 151: [2, 54], 152: [2, 55], 161: [2, 66], 162: [2, 67], 163: [2, 62], 164: [2, 49], 165: [2, 47], 166: [2, 45] },
    parseError: function(W, z) {
      if (z.recoverable)
        this.trace(W);
      else {
        var A = new Error(W);
        throw A.hash = z, A;
      }
    },
    parse: function(W) {
      var z = this, A = [0], I = [], G = [null], L = [], at = this.table, E = "", Dt = 0, et = 0, Et = 2, vt = 1, pt = L.slice.call(arguments, 1), ht = Object.create(this.lexer), gt = { yy: {} };
      for (var ut in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, ut) && (gt.yy[ut] = this.yy[ut]);
      ht.setInput(W, gt.yy), gt.yy.lexer = ht, gt.yy.parser = this, typeof ht.yylloc > "u" && (ht.yylloc = {});
      var yt = ht.yylloc;
      L.push(yt);
      var ue = ht.options && ht.options.ranges;
      typeof gt.yy.parseError == "function" ? this.parseError = gt.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function re() {
        var ft;
        return ft = I.pop() || ht.lex() || vt, typeof ft != "number" && (ft instanceof Array && (I = ft, ft = I.pop()), ft = z.symbols_[ft] || ft), ft;
      }
      for (var Mt, Nt, Kt, fe, Gt = {}, Ot, Bt, bt, mt; ; ) {
        if (Nt = A[A.length - 1], this.defaultActions[Nt] ? Kt = this.defaultActions[Nt] : ((Mt === null || typeof Mt > "u") && (Mt = re()), Kt = at[Nt] && at[Nt][Mt]), typeof Kt > "u" || !Kt.length || !Kt[0]) {
          var wt = "";
          mt = [];
          for (Ot in at[Nt])
            this.terminals_[Ot] && Ot > Et && mt.push("'" + this.terminals_[Ot] + "'");
          ht.showPosition ? wt = "Parse error on line " + (Dt + 1) + `:
` + ht.showPosition() + `
Expecting ` + mt.join(", ") + ", got '" + (this.terminals_[Mt] || Mt) + "'" : wt = "Parse error on line " + (Dt + 1) + ": Unexpected " + (Mt == vt ? "end of input" : "'" + (this.terminals_[Mt] || Mt) + "'"), this.parseError(wt, {
            text: ht.match,
            token: this.terminals_[Mt] || Mt,
            line: ht.yylineno,
            loc: yt,
            expected: mt
          });
        }
        if (Kt[0] instanceof Array && Kt.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Nt + ", token: " + Mt);
        switch (Kt[0]) {
          case 1:
            A.push(Mt), G.push(ht.yytext), L.push(ht.yylloc), A.push(Kt[1]), Mt = null, et = ht.yyleng, E = ht.yytext, Dt = ht.yylineno, yt = ht.yylloc;
            break;
          case 2:
            if (Bt = this.productions_[Kt[1]][1], Gt.$ = G[G.length - Bt], Gt._$ = {
              first_line: L[L.length - (Bt || 1)].first_line,
              last_line: L[L.length - 1].last_line,
              first_column: L[L.length - (Bt || 1)].first_column,
              last_column: L[L.length - 1].last_column
            }, ue && (Gt._$.range = [
              L[L.length - (Bt || 1)].range[0],
              L[L.length - 1].range[1]
            ]), fe = this.performAction.apply(Gt, [
              E,
              et,
              Dt,
              gt.yy,
              Kt[1],
              G,
              L
            ].concat(pt)), typeof fe < "u")
              return fe;
            Bt && (A = A.slice(0, -1 * Bt * 2), G = G.slice(0, -1 * Bt), L = L.slice(0, -1 * Bt)), A.push(this.productions_[Kt[1]][0]), G.push(Gt.$), L.push(Gt._$), bt = at[A[A.length - 2]][A[A.length - 1]], A.push(bt);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, Tt = function() {
    var j = {
      EOF: 1,
      parseError: function(z, A) {
        if (this.yy.parser)
          this.yy.parser.parseError(z, A);
        else
          throw new Error(z);
      },
      // resets the lexer, sets new input
      setInput: function(W, z) {
        return this.yy = z || this.yy || {}, this._input = W, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var W = this._input[0];
        this.yytext += W, this.yyleng++, this.offset++, this.match += W, this.matched += W;
        var z = W.match(/(?:\r\n?|\n).*/g);
        return z ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), W;
      },
      // unshifts one char (or a string) into the input
      unput: function(W) {
        var z = W.length, A = W.split(/(?:\r\n?|\n)/g);
        this._input = W + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - z), this.offset -= z;
        var I = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), A.length - 1 && (this.yylineno -= A.length - 1);
        var G = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: A ? (A.length === I.length ? this.yylloc.first_column : 0) + I[I.length - A.length].length - A[0].length : this.yylloc.first_column - z
        }, this.options.ranges && (this.yylloc.range = [G[0], G[0] + this.yyleng - z]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(W) {
        this.unput(this.match.slice(W));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var W = this.matched.substr(0, this.matched.length - this.match.length);
        return (W.length > 20 ? "..." : "") + W.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var W = this.match;
        return W.length < 20 && (W += this._input.substr(0, 20 - W.length)), (W.substr(0, 20) + (W.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var W = this.pastInput(), z = new Array(W.length + 1).join("-");
        return W + this.upcomingInput() + `
` + z + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(W, z) {
        var A, I, G;
        if (this.options.backtrack_lexer && (G = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (G.yylloc.range = this.yylloc.range.slice(0))), I = W[0].match(/(?:\r\n?|\n).*/g), I && (this.yylineno += I.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: I ? I[I.length - 1].length - I[I.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + W[0].length
        }, this.yytext += W[0], this.match += W[0], this.matches = W, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(W[0].length), this.matched += W[0], A = this.performAction.call(this, this.yy, this, z, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), A)
          return A;
        if (this._backtrack) {
          for (var L in G)
            this[L] = G[L];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var W, z, A, I;
        this._more || (this.yytext = "", this.match = "");
        for (var G = this._currentRules(), L = 0; L < G.length; L++)
          if (A = this._input.match(this.rules[G[L]]), A && (!z || A[0].length > z[0].length)) {
            if (z = A, I = L, this.options.backtrack_lexer) {
              if (W = this.test_match(A, G[L]), W !== !1)
                return W;
              if (this._backtrack) {
                z = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return z ? (W = this.test_match(z, G[I]), W !== !1 ? W : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var z = this.next();
        return z || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(z) {
        this.conditionStack.push(z);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var z = this.conditionStack.length - 1;
        return z > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(z) {
        return z = this.conditionStack.length - 1 - Math.abs(z || 0), z >= 0 ? this.conditionStack[z] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(z) {
        this.begin(z);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(z, A, I, G) {
        switch (I) {
          case 0:
            return this.begin("open_directive"), 83;
          case 1:
            return this.begin("type_directive"), 84;
          case 2:
            return this.popState(), this.begin("arg_directive"), 17;
          case 3:
            return this.popState(), this.popState(), 86;
          case 4:
            return 85;
          case 5:
            return 5;
          case 6:
            break;
          case 7:
            break;
          case 8:
            break;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return 24;
          case 12:
            return this.begin("LINE"), 19;
          case 13:
            return this.begin("ID"), 54;
          case 14:
            return this.begin("ID"), 56;
          case 15:
            return A.yytext = A.yytext.trim(), this.begin("ALIAS"), 73;
          case 16:
            return this.popState(), this.popState(), this.begin("LINE"), 55;
          case 17:
            return this.popState(), this.popState(), 5;
          case 18:
            return this.begin("LINE"), 41;
          case 19:
            return this.begin("LINE"), 42;
          case 20:
            return this.begin("LINE"), 43;
          case 21:
            return this.begin("LINE"), 44;
          case 22:
            return this.begin("LINE"), 53;
          case 23:
            return this.begin("LINE"), 46;
          case 24:
            return this.begin("LINE"), 52;
          case 25:
            return this.begin("LINE"), 48;
          case 26:
            return this.begin("LINE"), 51;
          case 27:
            return this.begin("LINE"), 50;
          case 28:
            return this.popState(), 20;
          case 29:
            return 21;
          case 30:
            return 68;
          case 31:
            return 69;
          case 32:
            return 62;
          case 33:
            return 63;
          case 34:
            return 64;
          case 35:
            return 65;
          case 36:
            return 60;
          case 37:
            return 57;
          case 38:
            return this.begin("ID"), 26;
          case 39:
            return this.begin("ID"), 28;
          case 40:
            return 34;
          case 41:
            return 35;
          case 42:
            return this.begin("acc_title"), 36;
          case 43:
            return this.popState(), "acc_title_value";
          case 44:
            return this.begin("acc_descr"), 38;
          case 45:
            return this.popState(), "acc_descr_value";
          case 46:
            this.begin("acc_descr_multiline");
            break;
          case 47:
            this.popState();
            break;
          case 48:
            return "acc_descr_multiline_value";
          case 49:
            return 7;
          case 50:
            return 23;
          case 51:
            return 25;
          case 52:
            return 67;
          case 53:
            return 5;
          case 54:
            return A.yytext = A.yytext.trim(), 73;
          case 55:
            return 76;
          case 56:
            return 77;
          case 57:
            return 74;
          case 58:
            return 75;
          case 59:
            return 78;
          case 60:
            return 79;
          case 61:
            return 80;
          case 62:
            return 81;
          case 63:
            return 82;
          case 64:
            return 71;
          case 65:
            return 72;
          case 66:
            return 5;
          case 67:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[0-9]+(?=[ \n]+))/i, /^(?:box\b)/i, /^(?:participant\b)/i, /^(?:actor\b)/i, /^(?:[^\->:\n,;]+?([\-]*[^\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:as\b)/i, /^(?:(?:))/i, /^(?:loop\b)/i, /^(?:rect\b)/i, /^(?:opt\b)/i, /^(?:alt\b)/i, /^(?:else\b)/i, /^(?:par\b)/i, /^(?:and\b)/i, /^(?:critical\b)/i, /^(?:option\b)/i, /^(?:break\b)/i, /^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i, /^(?:end\b)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:links\b)/i, /^(?:link\b)/i, /^(?:properties\b)/i, /^(?:details\b)/i, /^(?:over\b)/i, /^(?:note\b)/i, /^(?:activate\b)/i, /^(?:deactivate\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:title:\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:sequenceDiagram\b)/i, /^(?:autonumber\b)/i, /^(?:off\b)/i, /^(?:,)/i, /^(?:;)/i, /^(?:[^\+\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+\->:\n,;]+)*)/i, /^(?:->>)/i, /^(?:-->>)/i, /^(?:->)/i, /^(?:-->)/i, /^(?:-[x])/i, /^(?:--[x])/i, /^(?:-[\)])/i, /^(?:--[\)])/i, /^(?::(?:(?:no)?wrap)?[^#\n;]+)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { acc_descr_multiline: { rules: [47, 48], inclusive: !1 }, acc_descr: { rules: [45], inclusive: !1 }, acc_title: { rules: [43], inclusive: !1 }, open_directive: { rules: [1, 8], inclusive: !1 }, type_directive: { rules: [2, 3, 8], inclusive: !1 }, arg_directive: { rules: [3, 4, 8], inclusive: !1 }, ID: { rules: [7, 8, 15], inclusive: !1 }, ALIAS: { rules: [7, 8, 16, 17], inclusive: !1 }, LINE: { rules: [7, 8, 28], inclusive: !1 }, INITIAL: { rules: [0, 5, 6, 8, 9, 10, 11, 12, 13, 14, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 46, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67], inclusive: !0 } }
    };
    return j;
  }();
  U.lexer = Tt;
  function $() {
    this.yy = {};
  }
  return $.prototype = U, U.Parser = $, new $();
}();
f1.parser = f1;
const RP = f1, FP = (t) => t.match(/^\s*sequenceDiagram/) !== null;
let pa, li = {}, Hs = [], Xr = [], nu = !1, d1, Pn;
const OP = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
}, PP = function(t) {
  Hs.push({
    name: t.text,
    wrap: t.wrap === void 0 && qi() || !!t.wrap,
    fill: t.color,
    actorKeys: []
  }), Pn = Hs.slice(-1)[0];
}, p1 = function(t, e, r, n) {
  let i = Pn;
  const s = li[t];
  if (s) {
    if (Pn && s.box && Pn !== s.box)
      throw new Error(
        "A same participant should only be defined in one Box: " + s.name + " can't be in '" + s.box.name + "' and in '" + Pn.name + "' at the same time."
      );
    if (i = s.box ? s.box : Pn, s.box = i, s && e === s.name && r == null)
      return;
  }
  (r == null || r.text == null) && (r = { text: e, wrap: null, type: n }), (n == null || r.text == null) && (r = { text: e, wrap: null, type: n }), li[t] = {
    box: i,
    name: e,
    description: r.text,
    wrap: r.wrap === void 0 && qi() || !!r.wrap,
    prevActor: pa,
    links: {},
    properties: {},
    actorCnt: null,
    rectData: null,
    type: n || "participant"
  }, pa && li[pa] && (li[pa].nextActor = t), Pn && Pn.actorKeys.push(t), pa = t;
}, VP = (t) => {
  let e, r = 0;
  for (e = 0; e < Xr.length; e++)
    Xr[e].type === no.ACTIVE_START && Xr[e].from.actor === t && r++, Xr[e].type === no.ACTIVE_END && Xr[e].from.actor === t && r--;
  return r;
}, YP = function(t, e, r, n) {
  Xr.push({
    from: t,
    to: e,
    message: r.text,
    wrap: r.wrap === void 0 && qi() || !!r.wrap,
    answer: n
  });
}, Ae = function(t, e, r = { text: void 0, wrap: void 0 }, n) {
  if (n === no.ACTIVE_END && VP(t.actor) < 1) {
    let s = new Error("Trying to inactivate an inactive participant (" + t.actor + ")");
    throw s.hash = {
      text: "->>-",
      token: "->>-",
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["'ACTIVE_PARTICIPANT'"]
    }, s;
  }
  return Xr.push({
    from: t,
    to: e,
    message: r.text,
    wrap: r.wrap === void 0 && qi() || !!r.wrap,
    type: n
  }), !0;
}, zP = function() {
  return Hs.length > 0;
}, UP = function() {
  return Hs.some((t) => t.name);
}, WP = function() {
  return Xr;
}, HP = function() {
  return Hs;
}, GP = function() {
  return li;
}, wo = function(t) {
  return li[t];
}, qP = function() {
  return Object.keys(li);
}, $P = function() {
  nu = !0;
}, jP = function() {
  nu = !1;
}, XP = () => nu, KP = function(t) {
  d1 = t;
}, qi = () => d1 !== void 0 ? d1 : q().sequence.wrap, ZP = function() {
  li = {}, Hs = [], Xr = [], nu = !1, Br();
}, QP = function(t) {
  const e = t.trim(), r = {
    text: e.replace(/^:?(?:no)?wrap:/, "").trim(),
    wrap: e.match(/^:?wrap:/) !== null ? !0 : e.match(/^:?nowrap:/) !== null ? !1 : void 0
  };
  return B.debug("parseMessage:", r), r;
}, JP = function(t) {
  const e = t.match(/^((?:rgba?|hsla?)\s*\(.*\)|\w*)(.*)$/);
  let r = e != null && e[1] ? e[1].trim() : "transparent", n = e != null && e[2] ? e[2].trim() : void 0;
  if (window && window.CSS)
    window.CSS.supports("color", r) || (r = "transparent", n = t.trim());
  else {
    const s = new Option().style;
    s.color = r, s.color !== r && (r = "transparent", n = t.trim());
  }
  return {
    color: r,
    text: n !== void 0 ? Ur(n.replace(/^:?(?:no)?wrap:/, ""), q()) : void 0,
    wrap: n !== void 0 ? n.match(/^:?wrap:/) !== null ? !0 : n.match(/^:?nowrap:/) !== null ? !1 : void 0 : void 0
  };
}, no = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25,
  AUTONUMBER: 26,
  CRITICAL_START: 27,
  CRITICAL_OPTION: 28,
  CRITICAL_END: 29,
  BREAK_START: 30,
  BREAK_END: 31
}, tV = {
  FILLED: 0,
  OPEN: 1
}, eV = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
}, r4 = function(t, e, r) {
  r.text, r.wrap === void 0 && qi() || r.wrap;
  const n = [].concat(t, t);
  Xr.push({
    from: n[0],
    to: n[1],
    message: r.text,
    wrap: r.wrap === void 0 && qi() || !!r.wrap,
    type: no.NOTE,
    placement: e
  });
}, n4 = function(t, e) {
  const r = wo(t);
  try {
    let n = Ur(e.text, q());
    n = n.replace(/&amp;/g, "&"), n = n.replace(/&equals;/g, "=");
    const i = JSON.parse(n);
    $0(r, i);
  } catch (n) {
    B.error("error while parsing actor link text", n);
  }
}, rV = function(t, e) {
  const r = wo(t);
  try {
    const a = {};
    let o = Ur(e.text, q());
    var n = o.indexOf("@");
    o = o.replace(/&amp;/g, "&"), o = o.replace(/&equals;/g, "=");
    var i = o.slice(0, n - 1).trim(), s = o.slice(n + 1).trim();
    a[i] = s, $0(r, a);
  } catch (a) {
    B.error("error while parsing actor link text", a);
  }
};
function $0(t, e) {
  if (t.links == null)
    t.links = e;
  else
    for (let r in e)
      t.links[r] = e[r];
}
const i4 = function(t, e) {
  const r = wo(t);
  try {
    let n = Ur(e.text, q());
    const i = JSON.parse(n);
    s4(r, i);
  } catch (n) {
    B.error("error while parsing actor properties text", n);
  }
};
function s4(t, e) {
  if (t.properties == null)
    t.properties = e;
  else
    for (let r in e)
      t.properties[r] = e[r];
}
function nV() {
  Pn = void 0;
}
const a4 = function(t, e) {
  const r = wo(t), n = document.getElementById(e.text);
  try {
    const i = n.innerHTML, s = JSON.parse(i);
    s.properties && s4(r, s.properties), s.links && $0(r, s.links);
  } catch (i) {
    B.error("error while parsing actor details text", i);
  }
}, iV = function(t, e) {
  if (t !== void 0 && t.properties !== void 0)
    return t.properties[e];
}, o4 = function(t) {
  if (Array.isArray(t))
    t.forEach(function(e) {
      o4(e);
    });
  else
    switch (t.type) {
      case "sequenceIndex":
        Xr.push({
          from: void 0,
          to: void 0,
          message: {
            start: t.sequenceIndex,
            step: t.sequenceIndexStep,
            visible: t.sequenceVisible
          },
          wrap: !1,
          type: t.signalType
        });
        break;
      case "addParticipant":
        p1(t.actor, t.actor, t.description, "participant");
        break;
      case "addActor":
        p1(t.actor, t.actor, t.description, "actor");
        break;
      case "activeStart":
        Ae(t.actor, void 0, void 0, t.signalType);
        break;
      case "activeEnd":
        Ae(t.actor, void 0, void 0, t.signalType);
        break;
      case "addNote":
        r4(t.actor, t.placement, t.text);
        break;
      case "addLinks":
        n4(t.actor, t.text);
        break;
      case "addALink":
        rV(t.actor, t.text);
        break;
      case "addProperties":
        i4(t.actor, t.text);
        break;
      case "addDetails":
        a4(t.actor, t.text);
        break;
      case "addMessage":
        Ae(t.from, t.to, t.msg, t.signalType);
        break;
      case "boxStart":
        PP(t.boxData);
        break;
      case "boxEnd":
        nV();
        break;
      case "loopStart":
        Ae(void 0, void 0, t.loopText, t.signalType);
        break;
      case "loopEnd":
        Ae(void 0, void 0, void 0, t.signalType);
        break;
      case "rectStart":
        Ae(void 0, void 0, t.color, t.signalType);
        break;
      case "rectEnd":
        Ae(void 0, void 0, void 0, t.signalType);
        break;
      case "optStart":
        Ae(void 0, void 0, t.optText, t.signalType);
        break;
      case "optEnd":
        Ae(void 0, void 0, void 0, t.signalType);
        break;
      case "altStart":
        Ae(void 0, void 0, t.altText, t.signalType);
        break;
      case "else":
        Ae(void 0, void 0, t.altText, t.signalType);
        break;
      case "altEnd":
        Ae(void 0, void 0, void 0, t.signalType);
        break;
      case "setAccTitle":
        Tr(t.text);
        break;
      case "parStart":
        Ae(void 0, void 0, t.parText, t.signalType);
        break;
      case "and":
        Ae(void 0, void 0, t.parText, t.signalType);
        break;
      case "parEnd":
        Ae(void 0, void 0, void 0, t.signalType);
        break;
      case "criticalStart":
        Ae(void 0, void 0, t.criticalText, t.signalType);
        break;
      case "option":
        Ae(void 0, void 0, t.optionText, t.signalType);
        break;
      case "criticalEnd":
        Ae(void 0, void 0, void 0, t.signalType);
        break;
      case "breakStart":
        Ae(void 0, void 0, t.breakText, t.signalType);
        break;
      case "breakEnd":
        Ae(void 0, void 0, void 0, t.signalType);
        break;
    }
}, B2 = {
  addActor: p1,
  addMessage: YP,
  addSignal: Ae,
  addLinks: n4,
  addDetails: a4,
  addProperties: i4,
  autoWrap: qi,
  setWrap: KP,
  enableSequenceNumbers: $P,
  disableSequenceNumbers: jP,
  showSequenceNumbers: XP,
  getMessages: WP,
  getActors: GP,
  getActor: wo,
  getActorKeys: qP,
  getActorProperty: iV,
  getAccTitle: Dr,
  getBoxes: HP,
  getDiagramTitle: hn,
  setDiagramTitle: un,
  parseDirective: OP,
  getConfig: () => q().sequence,
  clear: ZP,
  parseMessage: QP,
  parseBoxData: JP,
  LINETYPE: no,
  ARROWTYPE: tV,
  PLACEMENT: eV,
  addNote: r4,
  setAccTitle: Tr,
  apply: o4,
  setAccDescription: Ir,
  getAccDescription: Mr,
  hasAtLeastOneBox: zP,
  hasAtLeastOneBoxWithTitle: UP
};
let g1 = [];
const sV = (t) => {
  g1.push(t);
}, l4 = () => {
  g1.forEach((t) => {
    t();
  }), g1 = [];
}, iu = function(t, e) {
  const r = t.append("rect");
  return r.attr("x", e.x), r.attr("y", e.y), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("width", e.width), r.attr("height", e.height), r.attr("rx", e.rx), r.attr("ry", e.ry), e.class !== void 0 && r.attr("class", e.class), r;
}, c4 = (t, e) => {
  sV(() => {
    const r = document.querySelectorAll(t);
    r.length !== 0 && (r[0].addEventListener("mouseover", function() {
      cV("actor" + e + "_popup");
    }), r[0].addEventListener("mouseout", function() {
      uV("actor" + e + "_popup");
    }));
  });
}, aV = function(t, e, r, n, i) {
  if (e.links === void 0 || e.links === null || Object.keys(e.links).length === 0)
    return { height: 0, width: 0 };
  const s = e.links, a = e.actorCnt, o = e.rectData;
  var l = "none";
  i && (l = "block !important");
  const u = t.append("g");
  u.attr("id", "actor" + a + "_popup"), u.attr("class", "actorPopupMenu"), u.attr("display", l), c4("#actor" + a + "_popup", a);
  var h = "";
  o.class !== void 0 && (h = " " + o.class);
  let f = o.width > r ? o.width : r;
  const d = u.append("rect");
  if (d.attr("class", "actorPopupMenuPanel" + h), d.attr("x", o.x), d.attr("y", o.height), d.attr("fill", o.fill), d.attr("stroke", o.stroke), d.attr("width", f), d.attr("height", o.height), d.attr("rx", o.rx), d.attr("ry", o.ry), s != null) {
    var p = 20;
    for (let v in s) {
      var m = u.append("a"), _ = Jn(s[v]);
      m.attr("xlink:href", _), m.attr("target", "_blank"), EV(n)(
        v,
        m,
        o.x + 10,
        o.height + p,
        f,
        20,
        { class: "actor" },
        n
      ), p += 30;
    }
  }
  return d.attr("height", p), { height: o.height + p, width: f };
}, u4 = function(t, e, r, n) {
  const i = t.append("image");
  i.attr("x", e), i.attr("y", r);
  var s = Jn(n);
  i.attr("xlink:href", s);
}, h4 = function(t, e, r, n) {
  const i = t.append("use");
  i.attr("x", e), i.attr("y", r);
  var s = Jn(n);
  i.attr("xlink:href", "#" + s);
}, oV = function(t) {
  return "var pu = document.getElementById('" + t + "'); if (pu != null) { pu.style.display = 'block'; }";
}, lV = function(t) {
  return "var pu = document.getElementById('" + t + "'); if (pu != null) { pu.style.display = 'none'; }";
}, cV = function(t) {
  var e = document.getElementById(t);
  e != null && (e.style.display = "block");
}, uV = function(t) {
  var e = document.getElementById(t);
  e != null && (e.style.display = "none");
}, Gs = function(t, e) {
  let r = 0, n = 0;
  const i = e.text.split(Xt.lineBreakRegex), [s, a] = ho(e.fontSize);
  let o = [], l = 0, u = () => e.y;
  if (e.valign !== void 0 && e.textMargin !== void 0 && e.textMargin > 0)
    switch (e.valign) {
      case "top":
      case "start":
        u = () => Math.round(e.y + e.textMargin);
        break;
      case "middle":
      case "center":
        u = () => Math.round(e.y + (r + n + e.textMargin) / 2);
        break;
      case "bottom":
      case "end":
        u = () => Math.round(
          e.y + (r + n + 2 * e.textMargin) - e.textMargin
        );
        break;
    }
  if (e.anchor !== void 0 && e.textMargin !== void 0 && e.width !== void 0)
    switch (e.anchor) {
      case "left":
      case "start":
        e.x = Math.round(e.x + e.textMargin), e.anchor = "start", e.dominantBaseline = "middle", e.alignmentBaseline = "middle";
        break;
      case "middle":
      case "center":
        e.x = Math.round(e.x + e.width / 2), e.anchor = "middle", e.dominantBaseline = "middle", e.alignmentBaseline = "middle";
        break;
      case "right":
      case "end":
        e.x = Math.round(e.x + e.width - e.textMargin), e.anchor = "end", e.dominantBaseline = "middle", e.alignmentBaseline = "middle";
        break;
    }
  for (let [h, f] of i.entries()) {
    e.textMargin !== void 0 && e.textMargin === 0 && s !== void 0 && (l = h * s);
    const d = t.append("text");
    if (d.attr("x", e.x), d.attr("y", u()), e.anchor !== void 0 && d.attr("text-anchor", e.anchor).attr("dominant-baseline", e.dominantBaseline).attr("alignment-baseline", e.alignmentBaseline), e.fontFamily !== void 0 && d.style("font-family", e.fontFamily), a !== void 0 && d.style("font-size", a), e.fontWeight !== void 0 && d.style("font-weight", e.fontWeight), e.fill !== void 0 && d.attr("fill", e.fill), e.class !== void 0 && d.attr("class", e.class), e.dy !== void 0 ? d.attr("dy", e.dy) : l !== 0 && d.attr("dy", l), e.tspan) {
      const p = d.append("tspan");
      p.attr("x", e.x), e.fill !== void 0 && p.attr("fill", e.fill), p.text(f);
    } else
      d.text(f);
    e.valign !== void 0 && e.textMargin !== void 0 && e.textMargin > 0 && (n += (d._groups || d)[0][0].getBBox().height, r = n), o.push(d);
  }
  return o;
}, f4 = function(t, e) {
  function r(i, s, a, o, l) {
    return i + "," + s + " " + (i + a) + "," + s + " " + (i + a) + "," + (s + o - l) + " " + (i + a - l * 1.2) + "," + (s + o) + " " + i + "," + (s + o);
  }
  const n = t.append("polygon");
  return n.attr("points", r(e.x, e.y, e.width, e.height, 7)), n.attr("class", "labelBox"), e.y = e.y + e.height / 2, Gs(t, e), n;
};
let yn = -1;
const d4 = (t, e) => {
  t.selectAll && t.selectAll(".actor-line").attr("class", "200").attr("y2", e - 55);
}, hV = function(t, e, r, n) {
  const i = e.x + e.width / 2, s = e.y + 5, a = t.append("g");
  var o = a;
  n || (yn++, o.append("line").attr("id", "actor" + yn).attr("x1", i).attr("y1", s).attr("x2", i).attr("y2", 2e3).attr("class", "actor-line").attr("stroke-width", "0.5px").attr("stroke", "#999"), o = a.append("g"), e.actorCnt = yn, e.links != null && (o.attr("id", "root-" + yn), c4("#root-" + yn, yn)));
  const l = su();
  var u = "actor";
  e.properties != null && e.properties.class ? u = e.properties.class : l.fill = "#eaeaea", l.x = e.x, l.y = e.y, l.width = e.width, l.height = e.height, l.class = u, l.rx = 3, l.ry = 3;
  const h = iu(o, l);
  if (e.rectData = l, e.properties != null && e.properties.icon) {
    const d = e.properties.icon.trim();
    d.charAt(0) === "@" ? h4(o, l.x + l.width - 20, l.y + 10, d.substr(1)) : u4(o, l.x + l.width - 20, l.y + 10, d);
  }
  j0(r)(
    e.description,
    o,
    l.x,
    l.y,
    l.width,
    l.height,
    { class: "actor" },
    r
  );
  let f = e.height;
  if (h.node) {
    const d = h.node().getBBox();
    e.height = d.height, f = d.height;
  }
  return f;
}, fV = function(t, e, r, n) {
  const i = e.x + e.width / 2, s = e.y + 80;
  n || (yn++, t.append("line").attr("id", "actor" + yn).attr("x1", i).attr("y1", s).attr("x2", i).attr("y2", 2e3).attr("class", "actor-line").attr("stroke-width", "0.5px").attr("stroke", "#999"));
  const a = t.append("g");
  a.attr("class", "actor-man");
  const o = su();
  o.x = e.x, o.y = e.y, o.fill = "#eaeaea", o.width = e.width, o.height = e.height, o.class = "actor", o.rx = 3, o.ry = 3, a.append("line").attr("id", "actor-man-torso" + yn).attr("x1", i).attr("y1", e.y + 25).attr("x2", i).attr("y2", e.y + 45), a.append("line").attr("id", "actor-man-arms" + yn).attr("x1", i - 18).attr("y1", e.y + 33).attr("x2", i + 18).attr("y2", e.y + 33), a.append("line").attr("x1", i - 18).attr("y1", e.y + 60).attr("x2", i).attr("y2", e.y + 45), a.append("line").attr("x1", i).attr("y1", e.y + 45).attr("x2", i + 16).attr("y2", e.y + 60);
  const l = a.append("circle");
  l.attr("cx", e.x + e.width / 2), l.attr("cy", e.y + 10), l.attr("r", 15), l.attr("width", e.width), l.attr("height", e.height);
  const u = a.node().getBBox();
  return e.height = u.height, j0(r)(
    e.description,
    a,
    o.x,
    o.y + 35,
    o.width,
    o.height,
    { class: "actor" },
    r
  ), e.height;
}, dV = function(t, e, r, n) {
  switch (e.type) {
    case "actor":
      return fV(t, e, r, n);
    case "participant":
      return hV(t, e, r, n);
  }
}, pV = function(t, e, r) {
  const i = t.append("g");
  p4(i, e), e.name && j0(r)(
    e.name,
    i,
    e.x,
    e.y + (e.textMaxHeight || 0) / 2,
    e.width,
    0,
    { class: "text" },
    r
  ), i.lower();
}, gV = function(t) {
  return t.append("g");
}, yV = function(t, e, r, n, i) {
  const s = su(), a = e.anchored;
  s.x = e.startx, s.y = e.starty, s.class = "activation" + i % 3, s.width = e.stopx - e.startx, s.height = r - e.starty, iu(a, s);
}, mV = function(t, e, r, n) {
  const {
    boxMargin: i,
    boxTextMargin: s,
    labelBoxHeight: a,
    labelBoxWidth: o,
    messageFontFamily: l,
    messageFontSize: u,
    messageFontWeight: h
  } = n, f = t.append("g"), d = function(_, v, k, x) {
    return f.append("line").attr("x1", _).attr("y1", v).attr("x2", k).attr("y2", x).attr("class", "loopLine");
  };
  d(e.startx, e.starty, e.stopx, e.starty), d(e.stopx, e.starty, e.stopx, e.stopy), d(e.startx, e.stopy, e.stopx, e.stopy), d(e.startx, e.starty, e.startx, e.stopy), e.sections !== void 0 && e.sections.forEach(function(_) {
    d(e.startx, _.y, e.stopx, _.y).style(
      "stroke-dasharray",
      "3, 3"
    );
  });
  let p = y1();
  p.text = r, p.x = e.startx, p.y = e.starty, p.fontFamily = l, p.fontSize = u, p.fontWeight = h, p.anchor = "middle", p.valign = "middle", p.tspan = !1, p.width = o || 50, p.height = a || 20, p.textMargin = s, p.class = "labelText", f4(f, p), p = y1(), p.text = e.title, p.x = e.startx + o / 2 + (e.stopx - e.startx) / 2, p.y = e.starty + i + s, p.anchor = "middle", p.valign = "middle", p.textMargin = s, p.class = "loopText", p.fontFamily = l, p.fontSize = u, p.fontWeight = h, p.wrap = !0;
  let m = Gs(f, p);
  return e.sectionTitles !== void 0 && e.sectionTitles.forEach(function(_, v) {
    if (_.message) {
      p.text = _.message, p.x = e.startx + (e.stopx - e.startx) / 2, p.y = e.sections[v].y + i + s, p.class = "loopText", p.anchor = "middle", p.valign = "middle", p.tspan = !1, p.fontFamily = l, p.fontSize = u, p.fontWeight = h, p.wrap = e.wrap, m = Gs(f, p);
      let k = Math.round(
        m.map((x) => (x._groups || x)[0][0].getBBox().height).reduce((x, D) => x + D)
      );
      e.sections[v].height += k - (i + s);
    }
  }), e.height = Math.round(e.stopy - e.starty), f;
}, p4 = function(t, e) {
  iu(t, {
    x: e.startx,
    y: e.starty,
    width: e.stopx - e.startx,
    height: e.stopy - e.starty,
    fill: e.fill,
    stroke: e.stroke,
    class: "rect"
  }).lower();
}, bV = function(t) {
  t.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
}, _V = function(t) {
  t.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
}, xV = function(t) {
  t.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
}, vV = function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
}, kV = function(t) {
  t.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, wV = function(t) {
  t.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, TV = function(t) {
  t.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 4).attr("refY", 5).append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1pt").attr("d", "M 1,2 L 6,7 M 6,2 L 1,7");
}, y1 = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: void 0,
    style: "#666",
    width: void 0,
    height: void 0,
    textMargin: 0,
    rx: 0,
    ry: 0,
    tspan: !0,
    valign: void 0
  };
}, su = function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, j0 = function() {
  function t(i, s, a, o, l, u, h) {
    const f = s.append("text").attr("x", a + l / 2).attr("y", o + u / 2 + 5).style("text-anchor", "middle").text(i);
    n(f, h);
  }
  function e(i, s, a, o, l, u, h, f) {
    const { actorFontSize: d, actorFontFamily: p, actorFontWeight: m } = f, [_, v] = ho(d), k = i.split(Xt.lineBreakRegex);
    for (let x = 0; x < k.length; x++) {
      const D = x * _ - _ * (k.length - 1) / 2, F = s.append("text").attr("x", a + l / 2).attr("y", o).style("text-anchor", "middle").style("font-size", v).style("font-weight", m).style("font-family", p);
      F.append("tspan").attr("x", a + l / 2).attr("dy", D).text(k[x]), F.attr("y", o + u / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), n(F, h);
    }
  }
  function r(i, s, a, o, l, u, h, f) {
    const d = s.append("switch"), m = d.append("foreignObject").attr("x", a).attr("y", o).attr("width", l).attr("height", u).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    m.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, d, a, o, l, u, h, f), n(m, h);
  }
  function n(i, s) {
    for (const a in s)
      s.hasOwnProperty(a) && i.attr(a, s[a]);
  }
  return function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
}(), EV = function() {
  function t(i, s, a, o, l, u, h) {
    const f = s.append("text").attr("x", a).attr("y", o).style("text-anchor", "start").text(i);
    n(f, h);
  }
  function e(i, s, a, o, l, u, h, f) {
    const { actorFontSize: d, actorFontFamily: p, actorFontWeight: m } = f, _ = i.split(Xt.lineBreakRegex);
    for (let v = 0; v < _.length; v++) {
      const k = v * d - d * (_.length - 1) / 2, x = s.append("text").attr("x", a).attr("y", o).style("text-anchor", "start").style("font-size", d).style("font-weight", m).style("font-family", p);
      x.append("tspan").attr("x", a).attr("dy", k).text(_[v]), x.attr("y", o + u / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), n(x, h);
    }
  }
  function r(i, s, a, o, l, u, h, f) {
    const d = s.append("switch"), m = d.append("foreignObject").attr("x", a).attr("y", o).attr("width", l).attr("height", u).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    m.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, d, a, o, l, u, h, f), n(m, h);
  }
  function n(i, s) {
    for (const a in s)
      s.hasOwnProperty(a) && i.attr(a, s[a]);
  }
  return function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
}(), ke = {
  drawRect: iu,
  drawText: Gs,
  drawLabel: f4,
  drawActor: dV,
  drawBox: pV,
  drawPopup: aV,
  drawImage: u4,
  drawEmbeddedImage: h4,
  anchorElement: gV,
  drawActivation: yV,
  drawLoop: mV,
  drawBackgroundRect: p4,
  insertArrowHead: vV,
  insertArrowFilledHead: kV,
  insertSequenceNumber: wV,
  insertArrowCrossHead: TV,
  insertDatabaseIcon: bV,
  insertComputerIcon: _V,
  insertClockIcon: xV,
  getTextObj: y1,
  getNoteRect: su,
  popupMenu: oV,
  popdownMenu: lV,
  fixLifeLineHeights: d4,
  sanitizeUrl: Jn
};
let rt = {};
const kt = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  activations: [],
  models: {
    getHeight: function() {
      return Math.max.apply(
        null,
        this.actors.length === 0 ? [0] : this.actors.map((t) => t.height || 0)
      ) + (this.loops.length === 0 ? 0 : this.loops.map((t) => t.height || 0).reduce((t, e) => t + e)) + (this.messages.length === 0 ? 0 : this.messages.map((t) => t.height || 0).reduce((t, e) => t + e)) + (this.notes.length === 0 ? 0 : this.notes.map((t) => t.height || 0).reduce((t, e) => t + e));
    },
    clear: function() {
      this.actors = [], this.boxes = [], this.loops = [], this.messages = [], this.notes = [];
    },
    addBox: function(t) {
      this.boxes.push(t);
    },
    addActor: function(t) {
      this.actors.push(t);
    },
    addLoop: function(t) {
      this.loops.push(t);
    },
    addMessage: function(t) {
      this.messages.push(t);
    },
    addNote: function(t) {
      this.notes.push(t);
    },
    lastActor: function() {
      return this.actors[this.actors.length - 1];
    },
    lastLoop: function() {
      return this.loops[this.loops.length - 1];
    },
    lastMessage: function() {
      return this.messages[this.messages.length - 1];
    },
    lastNote: function() {
      return this.notes[this.notes.length - 1];
    },
    actors: [],
    boxes: [],
    loops: [],
    messages: [],
    notes: []
  },
  init: function() {
    this.sequenceItems = [], this.activations = [], this.models.clear(), this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    }, this.verticalPos = 0, y4(q());
  },
  updateVal: function(t, e, r, n) {
    t[e] === void 0 ? t[e] = r : t[e] = n(r, t[e]);
  },
  updateBounds: function(t, e, r, n) {
    const i = this;
    let s = 0;
    function a(o) {
      return function(u) {
        s++;
        const h = i.sequenceItems.length - s + 1;
        i.updateVal(u, "starty", e - h * rt.boxMargin, Math.min), i.updateVal(u, "stopy", n + h * rt.boxMargin, Math.max), i.updateVal(kt.data, "startx", t - h * rt.boxMargin, Math.min), i.updateVal(kt.data, "stopx", r + h * rt.boxMargin, Math.max), o !== "activation" && (i.updateVal(u, "startx", t - h * rt.boxMargin, Math.min), i.updateVal(u, "stopx", r + h * rt.boxMargin, Math.max), i.updateVal(kt.data, "starty", e - h * rt.boxMargin, Math.min), i.updateVal(kt.data, "stopy", n + h * rt.boxMargin, Math.max));
      };
    }
    this.sequenceItems.forEach(a()), this.activations.forEach(a("activation"));
  },
  insert: function(t, e, r, n) {
    const i = Math.min(t, r), s = Math.max(t, r), a = Math.min(e, n), o = Math.max(e, n);
    this.updateVal(kt.data, "startx", i, Math.min), this.updateVal(kt.data, "starty", a, Math.min), this.updateVal(kt.data, "stopx", s, Math.max), this.updateVal(kt.data, "stopy", o, Math.max), this.updateBounds(i, a, s, o);
  },
  newActivation: function(t, e, r) {
    const n = r[t.from.actor], i = au(t.from.actor).length || 0, s = n.x + n.width / 2 + (i - 1) * rt.activationWidth / 2;
    this.activations.push({
      startx: s,
      starty: this.verticalPos + 2,
      stopx: s + rt.activationWidth,
      stopy: void 0,
      actor: t.from.actor,
      anchored: ke.anchorElement(e)
    });
  },
  endActivation: function(t) {
    const e = this.activations.map(function(r) {
      return r.actor;
    }).lastIndexOf(t.from.actor);
    return this.activations.splice(e, 1)[0];
  },
  createLoop: function(t = { message: void 0, wrap: !1, width: void 0 }, e) {
    return {
      startx: void 0,
      starty: this.verticalPos,
      stopx: void 0,
      stopy: void 0,
      title: t.message,
      wrap: t.wrap,
      width: t.width,
      height: 0,
      fill: e
    };
  },
  newLoop: function(t = { message: void 0, wrap: !1, width: void 0 }, e) {
    this.sequenceItems.push(this.createLoop(t, e));
  },
  endLoop: function() {
    return this.sequenceItems.pop();
  },
  addSectionToLoop: function(t) {
    const e = this.sequenceItems.pop();
    e.sections = e.sections || [], e.sectionTitles = e.sectionTitles || [], e.sections.push({ y: kt.getVerticalPos(), height: 0 }), e.sectionTitles.push(t), this.sequenceItems.push(e);
  },
  bumpVerticalPos: function(t) {
    this.verticalPos = this.verticalPos + t, this.data.stopy = this.verticalPos;
  },
  getVerticalPos: function() {
    return this.verticalPos;
  },
  getBounds: function() {
    return { bounds: this.data, models: this.models };
  }
}, CV = function(t, e) {
  kt.bumpVerticalPos(rt.boxMargin), e.height = rt.boxMargin, e.starty = kt.getVerticalPos();
  const r = ke.getNoteRect();
  r.x = e.startx, r.y = e.starty, r.width = e.width || rt.width, r.class = "note";
  const n = t.append("g"), i = ke.drawRect(n, r), s = ke.getTextObj();
  s.x = e.startx, s.y = e.starty, s.width = r.width, s.dy = "1em", s.text = e.message, s.class = "noteText", s.fontFamily = rt.noteFontFamily, s.fontSize = rt.noteFontSize, s.fontWeight = rt.noteFontWeight, s.anchor = rt.noteAlign, s.textMargin = rt.noteMargin, s.valign = "center";
  const a = Gs(n, s), o = Math.round(
    a.map((l) => (l._groups || l)[0][0].getBBox().height).reduce((l, u) => l + u)
  );
  i.attr("height", o + 2 * rt.noteMargin), e.height += o + 2 * rt.noteMargin, kt.bumpVerticalPos(o + 2 * rt.noteMargin), e.stopy = e.starty + o + 2 * rt.noteMargin, e.stopx = e.startx + r.width, kt.insert(e.startx, e.starty, e.stopx, e.stopy), kt.models.addNote(e);
}, $i = (t) => ({
  fontFamily: t.messageFontFamily,
  fontSize: t.messageFontSize,
  fontWeight: t.messageFontWeight
}), cs = (t) => ({
  fontFamily: t.noteFontFamily,
  fontSize: t.noteFontSize,
  fontWeight: t.noteFontWeight
}), m1 = (t) => ({
  fontFamily: t.actorFontFamily,
  fontSize: t.actorFontSize,
  fontWeight: t.actorFontWeight
});
function SV(t, e) {
  kt.bumpVerticalPos(10);
  const { startx: r, stopx: n, message: i } = e, s = Xt.splitBreaks(i).length, a = jt.calculateTextDimensions(i, $i(rt)), o = a.height / s;
  e.height += o, kt.bumpVerticalPos(o);
  let l, u = a.height - 10;
  const h = a.width;
  if (r === n) {
    l = kt.getVerticalPos() + u, rt.rightAngles || (u += rt.boxMargin, l = kt.getVerticalPos() + u), u += 30;
    const f = Math.max(h / 2, rt.width / 2);
    kt.insert(
      r - f,
      kt.getVerticalPos() - 10 + u,
      n + f,
      kt.getVerticalPos() + 30 + u
    );
  } else
    u += rt.boxMargin, l = kt.getVerticalPos() + u, kt.insert(r, l - 10, n, l);
  return kt.bumpVerticalPos(u), e.height += u, e.stopy = e.starty + e.height, kt.insert(e.fromBounds, e.starty, e.toBounds, e.stopy), l;
}
const AV = function(t, e, r, n) {
  const { startx: i, stopx: s, starty: a, message: o, type: l, sequenceIndex: u, sequenceVisible: h } = e, f = jt.calculateTextDimensions(o, $i(rt)), d = ke.getTextObj();
  d.x = i, d.y = a + 10, d.width = s - i, d.class = "messageText", d.dy = "1em", d.text = o, d.fontFamily = rt.messageFontFamily, d.fontSize = rt.messageFontSize, d.fontWeight = rt.messageFontWeight, d.anchor = rt.messageAlign, d.valign = "center", d.textMargin = rt.wrapPadding, d.tspan = !1, Gs(t, d);
  const p = f.width;
  let m;
  i === s ? rt.rightAngles ? m = t.append("path").attr(
    "d",
    `M  ${i},${r} H ${i + Math.max(rt.width / 2, p / 2)} V ${r + 25} H ${i}`
  ) : m = t.append("path").attr(
    "d",
    "M " + i + "," + r + " C " + (i + 60) + "," + (r - 10) + " " + (i + 60) + "," + (r + 30) + " " + i + "," + (r + 20)
  ) : (m = t.append("line"), m.attr("x1", i), m.attr("y1", r), m.attr("x2", s), m.attr("y2", r)), l === n.db.LINETYPE.DOTTED || l === n.db.LINETYPE.DOTTED_CROSS || l === n.db.LINETYPE.DOTTED_POINT || l === n.db.LINETYPE.DOTTED_OPEN ? (m.style("stroke-dasharray", "3, 3"), m.attr("class", "messageLine1")) : m.attr("class", "messageLine0");
  let _ = "";
  rt.arrowMarkerAbsolute && (_ = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, _ = _.replace(/\(/g, "\\("), _ = _.replace(/\)/g, "\\)")), m.attr("stroke-width", 2), m.attr("stroke", "none"), m.style("fill", "none"), (l === n.db.LINETYPE.SOLID || l === n.db.LINETYPE.DOTTED) && m.attr("marker-end", "url(" + _ + "#arrowhead)"), (l === n.db.LINETYPE.SOLID_POINT || l === n.db.LINETYPE.DOTTED_POINT) && m.attr("marker-end", "url(" + _ + "#filled-head)"), (l === n.db.LINETYPE.SOLID_CROSS || l === n.db.LINETYPE.DOTTED_CROSS) && m.attr("marker-end", "url(" + _ + "#crosshead)"), (h || rt.showSequenceNumbers) && (m.attr("marker-start", "url(" + _ + "#sequencenumber)"), t.append("text").attr("x", i).attr("y", r + 4).attr("font-family", "sans-serif").attr("font-size", "12px").attr("text-anchor", "middle").attr("class", "sequenceNumber").text(u));
}, b1 = function(t, e, r, n, i, s, a) {
  if (i.hideUnusedParticipants === !0) {
    const f = /* @__PURE__ */ new Set();
    s.forEach((d) => {
      f.add(d.from), f.add(d.to);
    }), r = r.filter((d) => f.has(d));
  }
  let o = 0, l = 0, u = 0, h;
  for (const f of r) {
    const d = e[f], p = d.box;
    h && h != p && (a || kt.models.addBox(h), l += rt.boxMargin + h.margin), p && p != h && (a || (p.x = o + l, p.y = n), l += p.margin), d.width = d.width || rt.width, d.height = Math.max(d.height || rt.height, rt.height), d.margin = d.margin || rt.actorMargin, d.x = o + l, d.y = kt.getVerticalPos();
    const m = ke.drawActor(t, d, rt, a);
    u = Math.max(u, m), kt.insert(d.x, n, d.x + d.width, d.height), o += d.width + l, d.box && (d.box.width = o + p.margin - d.box.x), l = d.margin, h = d.box, kt.models.addActor(d);
  }
  h && !a && kt.models.addBox(h), kt.bumpVerticalPos(u);
}, g4 = function(t, e, r, n) {
  let i = 0, s = 0;
  for (const a of r) {
    const o = e[a], l = DV(o), u = ke.drawPopup(
      t,
      o,
      l,
      rt,
      rt.forceMenus,
      n
    );
    u.height > i && (i = u.height), u.width + o.x > s && (s = u.width + o.x);
  }
  return { maxHeight: i, maxWidth: s };
}, y4 = function(t) {
  Xe(rt, t), t.fontFamily && (rt.actorFontFamily = rt.noteFontFamily = rt.messageFontFamily = t.fontFamily), t.fontSize && (rt.actorFontSize = rt.noteFontSize = rt.messageFontSize = t.fontSize), t.fontWeight && (rt.actorFontWeight = rt.noteFontWeight = rt.messageFontWeight = t.fontWeight);
}, au = function(t) {
  return kt.activations.filter(function(e) {
    return e.actor === t;
  });
}, D2 = function(t, e) {
  const r = e[t], n = au(t), i = n.reduce(function(a, o) {
    return Math.min(a, o.startx);
  }, r.x + r.width / 2), s = n.reduce(function(a, o) {
    return Math.max(a, o.stopx);
  }, r.x + r.width / 2);
  return [i, s];
};
function dn(t, e, r, n, i) {
  kt.bumpVerticalPos(r);
  let s = n;
  if (e.id && e.message && t[e.id]) {
    const a = t[e.id].width, o = $i(rt);
    e.message = jt.wrapLabel(`[${e.message}]`, a - 2 * rt.wrapPadding, o), e.width = a, e.wrap = !0;
    const l = jt.calculateTextDimensions(e.message, o), u = Math.max(l.height, rt.labelBoxHeight);
    s = n + u, B.debug(`${u} - ${e.message}`);
  }
  i(e), kt.bumpVerticalPos(s);
}
const LV = function(t, e, r, n) {
  const { securityLevel: i, sequence: s } = q();
  rt = s, n.db.clear(), n.parser.parse(t);
  let a;
  i === "sandbox" && (a = _t("#i" + e));
  const o = _t(i === "sandbox" ? a.nodes()[0].contentDocument.body : "body"), l = i === "sandbox" ? a.nodes()[0].contentDocument : document;
  kt.init(), B.debug(n.db);
  const u = i === "sandbox" ? o.select(`[id="${e}"]`) : _t(`[id="${e}"]`), h = n.db.getActors(), f = n.db.getBoxes(), d = n.db.getActorKeys(), p = n.db.getMessages(), m = n.db.getDiagramTitle(), _ = n.db.hasAtLeastOneBox(), v = n.db.hasAtLeastOneBoxWithTitle(), k = BV(h, p, n);
  rt.height = IV(h, k, f), ke.insertComputerIcon(u), ke.insertDatabaseIcon(u), ke.insertClockIcon(u), _ && (kt.bumpVerticalPos(rt.boxMargin), v && kt.bumpVerticalPos(f[0].textMaxHeight)), b1(u, h, d, 0, rt, p, !1);
  const x = RV(p, h, k, n);
  ke.insertArrowHead(u), ke.insertArrowCrossHead(u), ke.insertArrowFilledHead(u), ke.insertSequenceNumber(u);
  function D(M, y) {
    const N = kt.endActivation(M);
    N.starty + 18 > y && (N.starty = y - 6, y += 12), ke.drawActivation(
      u,
      N,
      y,
      rt,
      au(M.from.actor).length
    ), kt.insert(N.startx, y - 10, N.stopx, y);
  }
  let F = 1, P = 1;
  const V = [];
  p.forEach(function(M) {
    let y, N, it;
    switch (M.type) {
      case n.db.LINETYPE.NOTE:
        N = M.noteModel, CV(u, N);
        break;
      case n.db.LINETYPE.ACTIVE_START:
        kt.newActivation(M, u, h);
        break;
      case n.db.LINETYPE.ACTIVE_END:
        D(M, kt.getVerticalPos());
        break;
      case n.db.LINETYPE.LOOP_START:
        dn(
          x,
          M,
          rt.boxMargin,
          rt.boxMargin + rt.boxTextMargin,
          (Y) => kt.newLoop(Y)
        );
        break;
      case n.db.LINETYPE.LOOP_END:
        y = kt.endLoop(), ke.drawLoop(u, y, "loop", rt), kt.bumpVerticalPos(y.stopy - kt.getVerticalPos()), kt.models.addLoop(y);
        break;
      case n.db.LINETYPE.RECT_START:
        dn(
          x,
          M,
          rt.boxMargin,
          rt.boxMargin,
          (Y) => kt.newLoop(void 0, Y.message)
        );
        break;
      case n.db.LINETYPE.RECT_END:
        y = kt.endLoop(), ke.drawBackgroundRect(u, y), kt.models.addLoop(y), kt.bumpVerticalPos(y.stopy - kt.getVerticalPos());
        break;
      case n.db.LINETYPE.OPT_START:
        dn(
          x,
          M,
          rt.boxMargin,
          rt.boxMargin + rt.boxTextMargin,
          (Y) => kt.newLoop(Y)
        );
        break;
      case n.db.LINETYPE.OPT_END:
        y = kt.endLoop(), ke.drawLoop(u, y, "opt", rt), kt.bumpVerticalPos(y.stopy - kt.getVerticalPos()), kt.models.addLoop(y);
        break;
      case n.db.LINETYPE.ALT_START:
        dn(
          x,
          M,
          rt.boxMargin,
          rt.boxMargin + rt.boxTextMargin,
          (Y) => kt.newLoop(Y)
        );
        break;
      case n.db.LINETYPE.ALT_ELSE:
        dn(
          x,
          M,
          rt.boxMargin + rt.boxTextMargin,
          rt.boxMargin,
          (Y) => kt.addSectionToLoop(Y)
        );
        break;
      case n.db.LINETYPE.ALT_END:
        y = kt.endLoop(), ke.drawLoop(u, y, "alt", rt), kt.bumpVerticalPos(y.stopy - kt.getVerticalPos()), kt.models.addLoop(y);
        break;
      case n.db.LINETYPE.PAR_START:
        dn(
          x,
          M,
          rt.boxMargin,
          rt.boxMargin + rt.boxTextMargin,
          (Y) => kt.newLoop(Y)
        );
        break;
      case n.db.LINETYPE.PAR_AND:
        dn(
          x,
          M,
          rt.boxMargin + rt.boxTextMargin,
          rt.boxMargin,
          (Y) => kt.addSectionToLoop(Y)
        );
        break;
      case n.db.LINETYPE.PAR_END:
        y = kt.endLoop(), ke.drawLoop(u, y, "par", rt), kt.bumpVerticalPos(y.stopy - kt.getVerticalPos()), kt.models.addLoop(y);
        break;
      case n.db.LINETYPE.AUTONUMBER:
        F = M.message.start || F, P = M.message.step || P, M.message.visible ? n.db.enableSequenceNumbers() : n.db.disableSequenceNumbers();
        break;
      case n.db.LINETYPE.CRITICAL_START:
        dn(
          x,
          M,
          rt.boxMargin,
          rt.boxMargin + rt.boxTextMargin,
          (Y) => kt.newLoop(Y)
        );
        break;
      case n.db.LINETYPE.CRITICAL_OPTION:
        dn(
          x,
          M,
          rt.boxMargin + rt.boxTextMargin,
          rt.boxMargin,
          (Y) => kt.addSectionToLoop(Y)
        );
        break;
      case n.db.LINETYPE.CRITICAL_END:
        y = kt.endLoop(), ke.drawLoop(u, y, "critical", rt), kt.bumpVerticalPos(y.stopy - kt.getVerticalPos()), kt.models.addLoop(y);
        break;
      case n.db.LINETYPE.BREAK_START:
        dn(
          x,
          M,
          rt.boxMargin,
          rt.boxMargin + rt.boxTextMargin,
          (Y) => kt.newLoop(Y)
        );
        break;
      case n.db.LINETYPE.BREAK_END:
        y = kt.endLoop(), ke.drawLoop(u, y, "break", rt), kt.bumpVerticalPos(y.stopy - kt.getVerticalPos()), kt.models.addLoop(y);
        break;
      default:
        try {
          it = M.msgModel, it.starty = kt.getVerticalPos(), it.sequenceIndex = F, it.sequenceVisible = n.db.showSequenceNumbers();
          const Y = SV(u, it);
          V.push({ messageModel: it, lineStartY: Y }), kt.models.addMessage(it);
        } catch (Y) {
          B.error("error while drawing message", Y);
        }
    }
    [
      n.db.LINETYPE.SOLID_OPEN,
      n.db.LINETYPE.DOTTED_OPEN,
      n.db.LINETYPE.SOLID,
      n.db.LINETYPE.DOTTED,
      n.db.LINETYPE.SOLID_CROSS,
      n.db.LINETYPE.DOTTED_CROSS,
      n.db.LINETYPE.SOLID_POINT,
      n.db.LINETYPE.DOTTED_POINT
    ].includes(M.type) && (F = F + P);
  }), V.forEach((M) => AV(u, M.messageModel, M.lineStartY, n)), rt.mirrorActors && (kt.bumpVerticalPos(rt.boxMargin * 2), b1(u, h, d, kt.getVerticalPos(), rt, p, !0), kt.bumpVerticalPos(rt.boxMargin), d4(u, kt.getVerticalPos())), kt.models.boxes.forEach(function(M) {
    M.height = kt.getVerticalPos() - M.y, kt.insert(M.x, M.y, M.x + M.width, M.height), M.startx = M.x, M.starty = M.y, M.stopx = M.startx + M.width, M.stopy = M.starty + M.height, M.stroke = "rgb(0,0,0, 0.5)", ke.drawBox(u, M, rt);
  }), _ && kt.bumpVerticalPos(rt.boxMargin);
  const R = g4(u, h, d, l), { bounds: O } = kt.getBounds();
  B.debug("For line height fix Querying: #" + e + " .actor-line"), I1("#" + e + " .actor-line").attr("y2", O.stopy);
  let S = O.stopy - O.starty;
  S < R.maxHeight && (S = R.maxHeight);
  let T = S + 2 * rt.diagramMarginY;
  rt.mirrorActors && (T = T - rt.boxMargin + rt.bottomMarginAdj);
  let b = O.stopx - O.startx;
  b < R.maxWidth && (b = R.maxWidth);
  const w = b + 2 * rt.diagramMarginX;
  m && u.append("text").text(m).attr("x", (O.stopx - O.startx) / 2 - 2 * rt.diagramMarginX).attr("y", -25), cn(u, T, w, rt.useMaxWidth);
  const g = m ? 40 : 0;
  u.attr(
    "viewBox",
    O.startx - rt.diagramMarginX + " -" + (rt.diagramMarginY + g) + " " + w + " " + (T + g)
  ), B.debug("models:", kt.models);
};
function BV(t, e, r) {
  const n = {};
  return e.forEach(function(i) {
    if (t[i.to] && t[i.from]) {
      const s = t[i.to];
      if (i.placement === r.db.PLACEMENT.LEFTOF && !s.prevActor || i.placement === r.db.PLACEMENT.RIGHTOF && !s.nextActor)
        return;
      const a = i.placement !== void 0, o = !a, l = a ? cs(rt) : $i(rt), u = i.wrap ? jt.wrapLabel(i.message, rt.width - 2 * rt.wrapPadding, l) : i.message, f = jt.calculateTextDimensions(u, l).width + 2 * rt.wrapPadding;
      o && i.from === s.nextActor ? n[i.to] = Math.max(
        n[i.to] || 0,
        f
      ) : o && i.from === s.prevActor ? n[i.from] = Math.max(
        n[i.from] || 0,
        f
      ) : o && i.from === i.to ? (n[i.from] = Math.max(
        n[i.from] || 0,
        f / 2
      ), n[i.to] = Math.max(
        n[i.to] || 0,
        f / 2
      )) : i.placement === r.db.PLACEMENT.RIGHTOF ? n[i.from] = Math.max(
        n[i.from] || 0,
        f
      ) : i.placement === r.db.PLACEMENT.LEFTOF ? n[s.prevActor] = Math.max(
        n[s.prevActor] || 0,
        f
      ) : i.placement === r.db.PLACEMENT.OVER && (s.prevActor && (n[s.prevActor] = Math.max(
        n[s.prevActor] || 0,
        f / 2
      )), s.nextActor && (n[i.from] = Math.max(
        n[i.from] || 0,
        f / 2
      )));
    }
  }), B.debug("maxMessageWidthPerActor:", n), n;
}
const DV = function(t) {
  let e = 0;
  const r = m1(rt);
  for (const n in t.links) {
    const s = jt.calculateTextDimensions(n, r).width + 2 * rt.wrapPadding + 2 * rt.boxMargin;
    e < s && (e = s);
  }
  return e;
};
function IV(t, e, r) {
  let n = 0;
  Object.keys(t).forEach((s) => {
    const a = t[s];
    a.wrap && (a.description = jt.wrapLabel(
      a.description,
      rt.width - 2 * rt.wrapPadding,
      m1(rt)
    ));
    const o = jt.calculateTextDimensions(a.description, m1(rt));
    a.width = a.wrap ? rt.width : Math.max(rt.width, o.width + 2 * rt.wrapPadding), a.height = a.wrap ? Math.max(o.height, rt.height) : rt.height, n = Math.max(n, a.height);
  });
  for (const s in e) {
    const a = t[s];
    if (!a)
      continue;
    const o = t[a.nextActor];
    if (!o) {
      const f = e[s] + rt.actorMargin - a.width / 2;
      a.margin = Math.max(f, rt.actorMargin);
      continue;
    }
    const u = e[s] + rt.actorMargin - a.width / 2 - o.width / 2;
    a.margin = Math.max(u, rt.actorMargin);
  }
  let i = 0;
  return r.forEach((s) => {
    const a = $i(rt);
    let o = s.actorKeys.reduce((h, f) => h += t[f].width + (t[f].margin || 0), 0);
    o -= 2 * rt.boxTextMargin, s.wrap && (s.name = jt.wrapLabel(s.name, o - 2 * rt.wrapPadding, a));
    const l = jt.calculateTextDimensions(s.name, a);
    i = Math.max(l.height, i);
    const u = Math.max(o, l.width + 2 * rt.wrapPadding);
    if (s.margin = rt.boxTextMargin, o < u) {
      const h = (u - o) / 2;
      s.margin += h;
    }
  }), r.forEach((s) => s.textMaxHeight = i), Math.max(n, rt.height);
}
const MV = function(t, e, r) {
  const n = e[t.from].x, i = e[t.to].x, s = t.wrap && t.message;
  let a = jt.calculateTextDimensions(
    s ? jt.wrapLabel(t.message, rt.width, cs(rt)) : t.message,
    cs(rt)
  );
  const o = {
    width: s ? rt.width : Math.max(rt.width, a.width + 2 * rt.noteMargin),
    height: 0,
    startx: e[t.from].x,
    stopx: 0,
    starty: 0,
    stopy: 0,
    message: t.message
  };
  return t.placement === r.db.PLACEMENT.RIGHTOF ? (o.width = s ? Math.max(rt.width, a.width) : Math.max(
    e[t.from].width / 2 + e[t.to].width / 2,
    a.width + 2 * rt.noteMargin
  ), o.startx = n + (e[t.from].width + rt.actorMargin) / 2) : t.placement === r.db.PLACEMENT.LEFTOF ? (o.width = Math.max(s ? rt.width : e[t.from].width / 2 + e[t.to].width / 2, a.width + 2 * rt.noteMargin), o.startx = n - o.width + (e[t.from].width - rt.actorMargin) / 2) : t.to === t.from ? (a = jt.calculateTextDimensions(
    s ? jt.wrapLabel(t.message, Math.max(rt.width, e[t.from].width), cs(rt)) : t.message,
    cs(rt)
  ), o.width = s ? Math.max(rt.width, e[t.from].width) : Math.max(e[t.from].width, rt.width, a.width + 2 * rt.noteMargin), o.startx = n + (e[t.from].width - o.width) / 2) : (o.width = Math.abs(n + e[t.from].width / 2 - (i + e[t.to].width / 2)) + rt.actorMargin, o.startx = n < i ? n + e[t.from].width / 2 - rt.actorMargin / 2 : i + e[t.to].width / 2 - rt.actorMargin / 2), s && (o.message = jt.wrapLabel(
    t.message,
    o.width - 2 * rt.wrapPadding,
    cs(rt)
  )), B.debug(
    `NM:[${o.startx},${o.stopx},${o.starty},${o.stopy}:${o.width},${o.height}=${t.message}]`
  ), o;
}, NV = function(t, e, r) {
  let n = !1;
  if ([
    r.db.LINETYPE.SOLID_OPEN,
    r.db.LINETYPE.DOTTED_OPEN,
    r.db.LINETYPE.SOLID,
    r.db.LINETYPE.DOTTED,
    r.db.LINETYPE.SOLID_CROSS,
    r.db.LINETYPE.DOTTED_CROSS,
    r.db.LINETYPE.SOLID_POINT,
    r.db.LINETYPE.DOTTED_POINT
  ].includes(t.type) && (n = !0), !n)
    return {};
  const i = D2(t.from, e), s = D2(t.to, e), a = i[0] <= s[0] ? 1 : 0, o = i[0] < s[0] ? 0 : 1, l = [...i, ...s], u = Math.abs(s[o] - i[a]);
  t.wrap && t.message && (t.message = jt.wrapLabel(
    t.message,
    Math.max(u + 2 * rt.wrapPadding, rt.width),
    $i(rt)
  ));
  const h = jt.calculateTextDimensions(t.message, $i(rt));
  return {
    width: Math.max(
      t.wrap ? 0 : h.width + 2 * rt.wrapPadding,
      u + 2 * rt.wrapPadding,
      rt.width
    ),
    height: 0,
    startx: i[a],
    stopx: s[o],
    starty: 0,
    stopy: 0,
    message: t.message,
    type: t.type,
    wrap: t.wrap,
    fromBounds: Math.min.apply(null, l),
    toBounds: Math.max.apply(null, l)
  };
}, RV = function(t, e, r, n) {
  const i = {}, s = [];
  let a, o, l;
  return t.forEach(function(u) {
    switch (u.id = jt.random({ length: 10 }), u.type) {
      case n.db.LINETYPE.LOOP_START:
      case n.db.LINETYPE.ALT_START:
      case n.db.LINETYPE.OPT_START:
      case n.db.LINETYPE.PAR_START:
      case n.db.LINETYPE.CRITICAL_START:
      case n.db.LINETYPE.BREAK_START:
        s.push({
          id: u.id,
          msg: u.message,
          from: Number.MAX_SAFE_INTEGER,
          to: Number.MIN_SAFE_INTEGER,
          width: 0
        });
        break;
      case n.db.LINETYPE.ALT_ELSE:
      case n.db.LINETYPE.PAR_AND:
      case n.db.LINETYPE.CRITICAL_OPTION:
        u.message && (a = s.pop(), i[a.id] = a, i[u.id] = a, s.push(a));
        break;
      case n.db.LINETYPE.LOOP_END:
      case n.db.LINETYPE.ALT_END:
      case n.db.LINETYPE.OPT_END:
      case n.db.LINETYPE.PAR_END:
      case n.db.LINETYPE.CRITICAL_END:
      case n.db.LINETYPE.BREAK_END:
        a = s.pop(), i[a.id] = a;
        break;
      case n.db.LINETYPE.ACTIVE_START:
        {
          const f = e[u.from ? u.from.actor : u.to.actor], d = au(u.from ? u.from.actor : u.to.actor).length, p = f.x + f.width / 2 + (d - 1) * rt.activationWidth / 2, m = {
            startx: p,
            stopx: p + rt.activationWidth,
            actor: u.from.actor,
            enabled: !0
          };
          kt.activations.push(m);
        }
        break;
      case n.db.LINETYPE.ACTIVE_END:
        {
          const f = kt.activations.map((d) => d.actor).lastIndexOf(u.from.actor);
          delete kt.activations.splice(f, 1)[0];
        }
        break;
    }
    u.placement !== void 0 ? (o = MV(u, e, n), u.noteModel = o, s.forEach((f) => {
      a = f, a.from = Math.min(a.from, o.startx), a.to = Math.max(a.to, o.startx + o.width), a.width = Math.max(a.width, Math.abs(a.from - a.to)) - rt.labelBoxWidth;
    })) : (l = NV(u, e, n), u.msgModel = l, l.startx && l.stopx && s.length > 0 && s.forEach((f) => {
      if (a = f, l.startx === l.stopx) {
        const d = e[u.from], p = e[u.to];
        a.from = Math.min(
          d.x - l.width / 2,
          d.x - d.width / 2,
          a.from
        ), a.to = Math.max(p.x + l.width / 2, p.x + d.width / 2, a.to), a.width = Math.max(a.width, Math.abs(a.to - a.from)) - rt.labelBoxWidth;
      } else
        a.from = Math.min(l.startx, a.from), a.to = Math.max(l.stopx, a.to), a.width = Math.max(a.width, l.width) - rt.labelBoxWidth;
    }));
  }), kt.activations = [], B.debug("Loop type widths:", i), i;
}, I2 = {
  bounds: kt,
  drawActors: b1,
  drawActorsPopup: g4,
  setConf: y4,
  draw: LV
};
var _1 = function() {
  var t = function(Z, J, X, tt) {
    for (X = X || {}, tt = Z.length; tt--; X[Z[tt]] = J)
      ;
    return X;
  }, e = [1, 2], r = [1, 3], n = [1, 5], i = [1, 7], s = [2, 5], a = [1, 15], o = [1, 17], l = [1, 21], u = [1, 22], h = [1, 23], f = [1, 24], d = [1, 37], p = [1, 25], m = [1, 26], _ = [1, 27], v = [1, 28], k = [1, 29], x = [1, 32], D = [1, 33], F = [1, 34], P = [1, 35], V = [1, 36], R = [1, 39], O = [1, 40], C = [1, 41], S = [1, 42], T = [1, 38], b = [1, 45], w = [1, 4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 50, 51, 52, 53, 56, 60], g = [1, 4, 5, 14, 15, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 50, 51, 52, 53, 56, 60], M = [1, 4, 5, 7, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 50, 51, 52, 53, 56, 60], y = [4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 50, 51, 52, 53, 56, 60], N = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, SPACE: 4, NL: 5, directive: 6, SD: 7, document: 8, line: 9, statement: 10, classDefStatement: 11, cssClassStatement: 12, idStatement: 13, DESCR: 14, "-->": 15, HIDE_EMPTY: 16, scale: 17, WIDTH: 18, COMPOSIT_STATE: 19, STRUCT_START: 20, STRUCT_STOP: 21, STATE_DESCR: 22, AS: 23, ID: 24, FORK: 25, JOIN: 26, CHOICE: 27, CONCURRENT: 28, note: 29, notePosition: 30, NOTE_TEXT: 31, direction: 32, acc_title: 33, acc_title_value: 34, acc_descr: 35, acc_descr_value: 36, acc_descr_multiline_value: 37, classDef: 38, CLASSDEF_ID: 39, CLASSDEF_STYLEOPTS: 40, DEFAULT: 41, class: 42, CLASSENTITY_IDS: 43, STYLECLASS: 44, openDirective: 45, typeDirective: 46, closeDirective: 47, ":": 48, argDirective: 49, direction_tb: 50, direction_bt: 51, direction_rl: 52, direction_lr: 53, eol: 54, ";": 55, EDGE_STATE: 56, STYLE_SEPARATOR: 57, left_of: 58, right_of: 59, open_directive: 60, type_directive: 61, arg_directive: 62, close_directive: 63, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NL", 7: "SD", 14: "DESCR", 15: "-->", 16: "HIDE_EMPTY", 17: "scale", 18: "WIDTH", 19: "COMPOSIT_STATE", 20: "STRUCT_START", 21: "STRUCT_STOP", 22: "STATE_DESCR", 23: "AS", 24: "ID", 25: "FORK", 26: "JOIN", 27: "CHOICE", 28: "CONCURRENT", 29: "note", 31: "NOTE_TEXT", 33: "acc_title", 34: "acc_title_value", 35: "acc_descr", 36: "acc_descr_value", 37: "acc_descr_multiline_value", 38: "classDef", 39: "CLASSDEF_ID", 40: "CLASSDEF_STYLEOPTS", 41: "DEFAULT", 42: "class", 43: "CLASSENTITY_IDS", 44: "STYLECLASS", 48: ":", 50: "direction_tb", 51: "direction_bt", 52: "direction_rl", 53: "direction_lr", 55: ";", 56: "EDGE_STATE", 57: "STYLE_SEPARATOR", 58: "left_of", 59: "right_of", 60: "open_directive", 61: "type_directive", 62: "arg_directive", 63: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [8, 0], [8, 2], [9, 2], [9, 1], [9, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 3], [10, 4], [10, 1], [10, 2], [10, 1], [10, 4], [10, 3], [10, 6], [10, 1], [10, 1], [10, 1], [10, 1], [10, 4], [10, 4], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [11, 3], [11, 3], [12, 3], [6, 3], [6, 5], [32, 1], [32, 1], [32, 1], [32, 1], [54, 1], [54, 1], [13, 1], [13, 1], [13, 3], [13, 3], [30, 1], [30, 1], [45, 1], [46, 1], [49, 1], [47, 1]],
    performAction: function(J, X, tt, st, lt, U, Tt) {
      var $ = U.length - 1;
      switch (lt) {
        case 4:
          return st.setRootDoc(U[$]), U[$];
        case 5:
          this.$ = [];
          break;
        case 6:
          U[$] != "nl" && (U[$ - 1].push(U[$]), this.$ = U[$ - 1]);
          break;
        case 7:
        case 8:
          this.$ = U[$];
          break;
        case 9:
          this.$ = "nl";
          break;
        case 12:
          this.$ = U[$];
          break;
        case 13:
          const A = U[$ - 1];
          A.description = st.trimColon(U[$]), this.$ = A;
          break;
        case 14:
          this.$ = { stmt: "relation", state1: U[$ - 2], state2: U[$] };
          break;
        case 15:
          const I = st.trimColon(U[$]);
          this.$ = { stmt: "relation", state1: U[$ - 3], state2: U[$ - 1], description: I };
          break;
        case 19:
          this.$ = { stmt: "state", id: U[$ - 3], type: "default", description: "", doc: U[$ - 1] };
          break;
        case 20:
          var j = U[$], W = U[$ - 2].trim();
          if (U[$].match(":")) {
            var z = U[$].split(":");
            j = z[0], W = [W, z[1]];
          }
          this.$ = { stmt: "state", id: j, type: "default", description: W };
          break;
        case 21:
          this.$ = { stmt: "state", id: U[$ - 3], type: "default", description: U[$ - 5], doc: U[$ - 1] };
          break;
        case 22:
          this.$ = { stmt: "state", id: U[$], type: "fork" };
          break;
        case 23:
          this.$ = { stmt: "state", id: U[$], type: "join" };
          break;
        case 24:
          this.$ = { stmt: "state", id: U[$], type: "choice" };
          break;
        case 25:
          this.$ = { stmt: "state", id: st.getDividerId(), type: "divider" };
          break;
        case 26:
          this.$ = { stmt: "state", id: U[$ - 1].trim(), note: { position: U[$ - 2].trim(), text: U[$].trim() } };
          break;
        case 30:
          this.$ = U[$].trim(), st.setAccTitle(this.$);
          break;
        case 31:
        case 32:
          this.$ = U[$].trim(), st.setAccDescription(this.$);
          break;
        case 33:
        case 34:
          this.$ = { stmt: "classDef", id: U[$ - 1].trim(), classes: U[$].trim() };
          break;
        case 35:
          this.$ = { stmt: "applyClass", id: U[$ - 1].trim(), styleClass: U[$].trim() };
          break;
        case 38:
          st.setDirection("TB"), this.$ = { stmt: "dir", value: "TB" };
          break;
        case 39:
          st.setDirection("BT"), this.$ = { stmt: "dir", value: "BT" };
          break;
        case 40:
          st.setDirection("RL"), this.$ = { stmt: "dir", value: "RL" };
          break;
        case 41:
          st.setDirection("LR"), this.$ = { stmt: "dir", value: "LR" };
          break;
        case 44:
        case 45:
          this.$ = { stmt: "state", id: U[$].trim(), type: "default", description: "" };
          break;
        case 46:
          this.$ = { stmt: "state", id: U[$ - 2].trim(), classes: [U[$].trim()], type: "default", description: "" };
          break;
        case 47:
          this.$ = { stmt: "state", id: U[$ - 2].trim(), classes: [U[$].trim()], type: "default", description: "" };
          break;
        case 50:
          st.parseDirective("%%{", "open_directive");
          break;
        case 51:
          st.parseDirective(U[$], "type_directive");
          break;
        case 52:
          U[$] = U[$].trim().replace(/'/g, '"'), st.parseDirective(U[$], "arg_directive");
          break;
        case 53:
          st.parseDirective("}%%", "close_directive", "state");
          break;
      }
    },
    table: [{ 3: 1, 4: e, 5: r, 6: 4, 7: n, 45: 6, 60: i }, { 1: [3] }, { 3: 8, 4: e, 5: r, 6: 4, 7: n, 45: 6, 60: i }, { 3: 9, 4: e, 5: r, 6: 4, 7: n, 45: 6, 60: i }, { 3: 10, 4: e, 5: r, 6: 4, 7: n, 45: 6, 60: i }, t([1, 4, 5, 16, 17, 19, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38, 42, 50, 51, 52, 53, 56, 60], s, { 8: 11 }), { 46: 12, 61: [1, 13] }, { 61: [2, 50] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4], 4: a, 5: o, 6: 30, 9: 14, 10: 16, 11: 18, 12: 19, 13: 20, 16: l, 17: u, 19: h, 22: f, 24: d, 25: p, 26: m, 27: _, 28: v, 29: k, 32: 31, 33: x, 35: D, 37: F, 38: P, 42: V, 45: 6, 50: R, 51: O, 52: C, 53: S, 56: T, 60: i }, { 47: 43, 48: [1, 44], 63: b }, t([48, 63], [2, 51]), t(w, [2, 6]), { 6: 30, 10: 46, 11: 18, 12: 19, 13: 20, 16: l, 17: u, 19: h, 22: f, 24: d, 25: p, 26: m, 27: _, 28: v, 29: k, 32: 31, 33: x, 35: D, 37: F, 38: P, 42: V, 45: 6, 50: R, 51: O, 52: C, 53: S, 56: T, 60: i }, t(w, [2, 8]), t(w, [2, 9]), t(w, [2, 10]), t(w, [2, 11]), t(w, [2, 12], { 14: [1, 47], 15: [1, 48] }), t(w, [2, 16]), { 18: [1, 49] }, t(w, [2, 18], { 20: [1, 50] }), { 23: [1, 51] }, t(w, [2, 22]), t(w, [2, 23]), t(w, [2, 24]), t(w, [2, 25]), { 30: 52, 31: [1, 53], 58: [1, 54], 59: [1, 55] }, t(w, [2, 28]), t(w, [2, 29]), { 34: [1, 56] }, { 36: [1, 57] }, t(w, [2, 32]), { 39: [1, 58], 41: [1, 59] }, { 43: [1, 60] }, t(g, [2, 44], { 57: [1, 61] }), t(g, [2, 45], { 57: [1, 62] }), t(w, [2, 38]), t(w, [2, 39]), t(w, [2, 40]), t(w, [2, 41]), t(M, [2, 36]), { 49: 63, 62: [1, 64] }, t(M, [2, 53]), t(w, [2, 7]), t(w, [2, 13]), { 13: 65, 24: d, 56: T }, t(w, [2, 17]), t(y, s, { 8: 66 }), { 24: [1, 67] }, { 24: [1, 68] }, { 23: [1, 69] }, { 24: [2, 48] }, { 24: [2, 49] }, t(w, [2, 30]), t(w, [2, 31]), { 40: [1, 70] }, { 40: [1, 71] }, { 44: [1, 72] }, { 24: [1, 73] }, { 24: [1, 74] }, { 47: 75, 63: b }, { 63: [2, 52] }, t(w, [2, 14], { 14: [1, 76] }), { 4: a, 5: o, 6: 30, 9: 14, 10: 16, 11: 18, 12: 19, 13: 20, 16: l, 17: u, 19: h, 21: [1, 77], 22: f, 24: d, 25: p, 26: m, 27: _, 28: v, 29: k, 32: 31, 33: x, 35: D, 37: F, 38: P, 42: V, 45: 6, 50: R, 51: O, 52: C, 53: S, 56: T, 60: i }, t(w, [2, 20], { 20: [1, 78] }), { 31: [1, 79] }, { 24: [1, 80] }, t(w, [2, 33]), t(w, [2, 34]), t(w, [2, 35]), t(g, [2, 46]), t(g, [2, 47]), t(M, [2, 37]), t(w, [2, 15]), t(w, [2, 19]), t(y, s, { 8: 81 }), t(w, [2, 26]), t(w, [2, 27]), { 4: a, 5: o, 6: 30, 9: 14, 10: 16, 11: 18, 12: 19, 13: 20, 16: l, 17: u, 19: h, 21: [1, 82], 22: f, 24: d, 25: p, 26: m, 27: _, 28: v, 29: k, 32: 31, 33: x, 35: D, 37: F, 38: P, 42: V, 45: 6, 50: R, 51: O, 52: C, 53: S, 56: T, 60: i }, t(w, [2, 21])],
    defaultActions: { 7: [2, 50], 8: [2, 1], 9: [2, 2], 10: [2, 3], 54: [2, 48], 55: [2, 49], 64: [2, 52] },
    parseError: function(J, X) {
      if (X.recoverable)
        this.trace(J);
      else {
        var tt = new Error(J);
        throw tt.hash = X, tt;
      }
    },
    parse: function(J) {
      var X = this, tt = [0], st = [], lt = [null], U = [], Tt = this.table, $ = "", j = 0, W = 0, z = 2, A = 1, I = U.slice.call(arguments, 1), G = Object.create(this.lexer), L = { yy: {} };
      for (var at in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, at) && (L.yy[at] = this.yy[at]);
      G.setInput(J, L.yy), L.yy.lexer = G, L.yy.parser = this, typeof G.yylloc > "u" && (G.yylloc = {});
      var E = G.yylloc;
      U.push(E);
      var Dt = G.options && G.options.ranges;
      typeof L.yy.parseError == "function" ? this.parseError = L.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function et() {
        var Nt;
        return Nt = st.pop() || G.lex() || A, typeof Nt != "number" && (Nt instanceof Array && (st = Nt, Nt = st.pop()), Nt = X.symbols_[Nt] || Nt), Nt;
      }
      for (var Et, vt, pt, ht, gt = {}, ut, yt, ue, re; ; ) {
        if (vt = tt[tt.length - 1], this.defaultActions[vt] ? pt = this.defaultActions[vt] : ((Et === null || typeof Et > "u") && (Et = et()), pt = Tt[vt] && Tt[vt][Et]), typeof pt > "u" || !pt.length || !pt[0]) {
          var Mt = "";
          re = [];
          for (ut in Tt[vt])
            this.terminals_[ut] && ut > z && re.push("'" + this.terminals_[ut] + "'");
          G.showPosition ? Mt = "Parse error on line " + (j + 1) + `:
` + G.showPosition() + `
Expecting ` + re.join(", ") + ", got '" + (this.terminals_[Et] || Et) + "'" : Mt = "Parse error on line " + (j + 1) + ": Unexpected " + (Et == A ? "end of input" : "'" + (this.terminals_[Et] || Et) + "'"), this.parseError(Mt, {
            text: G.match,
            token: this.terminals_[Et] || Et,
            line: G.yylineno,
            loc: E,
            expected: re
          });
        }
        if (pt[0] instanceof Array && pt.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + vt + ", token: " + Et);
        switch (pt[0]) {
          case 1:
            tt.push(Et), lt.push(G.yytext), U.push(G.yylloc), tt.push(pt[1]), Et = null, W = G.yyleng, $ = G.yytext, j = G.yylineno, E = G.yylloc;
            break;
          case 2:
            if (yt = this.productions_[pt[1]][1], gt.$ = lt[lt.length - yt], gt._$ = {
              first_line: U[U.length - (yt || 1)].first_line,
              last_line: U[U.length - 1].last_line,
              first_column: U[U.length - (yt || 1)].first_column,
              last_column: U[U.length - 1].last_column
            }, Dt && (gt._$.range = [
              U[U.length - (yt || 1)].range[0],
              U[U.length - 1].range[1]
            ]), ht = this.performAction.apply(gt, [
              $,
              W,
              j,
              L.yy,
              pt[1],
              lt,
              U
            ].concat(I)), typeof ht < "u")
              return ht;
            yt && (tt = tt.slice(0, -1 * yt * 2), lt = lt.slice(0, -1 * yt), U = U.slice(0, -1 * yt)), tt.push(this.productions_[pt[1]][0]), lt.push(gt.$), U.push(gt._$), ue = Tt[tt[tt.length - 2]][tt[tt.length - 1]], tt.push(ue);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, it = function() {
    var Z = {
      EOF: 1,
      parseError: function(X, tt) {
        if (this.yy.parser)
          this.yy.parser.parseError(X, tt);
        else
          throw new Error(X);
      },
      // resets the lexer, sets new input
      setInput: function(J, X) {
        return this.yy = X || this.yy || {}, this._input = J, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var J = this._input[0];
        this.yytext += J, this.yyleng++, this.offset++, this.match += J, this.matched += J;
        var X = J.match(/(?:\r\n?|\n).*/g);
        return X ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), J;
      },
      // unshifts one char (or a string) into the input
      unput: function(J) {
        var X = J.length, tt = J.split(/(?:\r\n?|\n)/g);
        this._input = J + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - X), this.offset -= X;
        var st = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), tt.length - 1 && (this.yylineno -= tt.length - 1);
        var lt = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: tt ? (tt.length === st.length ? this.yylloc.first_column : 0) + st[st.length - tt.length].length - tt[0].length : this.yylloc.first_column - X
        }, this.options.ranges && (this.yylloc.range = [lt[0], lt[0] + this.yyleng - X]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(J) {
        this.unput(this.match.slice(J));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var J = this.matched.substr(0, this.matched.length - this.match.length);
        return (J.length > 20 ? "..." : "") + J.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var J = this.match;
        return J.length < 20 && (J += this._input.substr(0, 20 - J.length)), (J.substr(0, 20) + (J.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var J = this.pastInput(), X = new Array(J.length + 1).join("-");
        return J + this.upcomingInput() + `
` + X + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(J, X) {
        var tt, st, lt;
        if (this.options.backtrack_lexer && (lt = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (lt.yylloc.range = this.yylloc.range.slice(0))), st = J[0].match(/(?:\r\n?|\n).*/g), st && (this.yylineno += st.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: st ? st[st.length - 1].length - st[st.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + J[0].length
        }, this.yytext += J[0], this.match += J[0], this.matches = J, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(J[0].length), this.matched += J[0], tt = this.performAction.call(this, this.yy, this, X, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), tt)
          return tt;
        if (this._backtrack) {
          for (var U in lt)
            this[U] = lt[U];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var J, X, tt, st;
        this._more || (this.yytext = "", this.match = "");
        for (var lt = this._currentRules(), U = 0; U < lt.length; U++)
          if (tt = this._input.match(this.rules[lt[U]]), tt && (!X || tt[0].length > X[0].length)) {
            if (X = tt, st = U, this.options.backtrack_lexer) {
              if (J = this.test_match(tt, lt[U]), J !== !1)
                return J;
              if (this._backtrack) {
                X = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return X ? (J = this.test_match(X, lt[st]), J !== !1 ? J : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var X = this.next();
        return X || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(X) {
        this.conditionStack.push(X);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var X = this.conditionStack.length - 1;
        return X > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(X) {
        return X = this.conditionStack.length - 1 - Math.abs(X || 0), X >= 0 ? this.conditionStack[X] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(X) {
        this.begin(X);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(X, tt, st, lt) {
        switch (st) {
          case 0:
            return 41;
          case 1:
            return 50;
          case 2:
            return 51;
          case 3:
            return 52;
          case 4:
            return 53;
          case 5:
            return this.begin("open_directive"), 60;
          case 6:
            return this.begin("type_directive"), 61;
          case 7:
            return this.popState(), this.begin("arg_directive"), 48;
          case 8:
            return this.popState(), this.popState(), 63;
          case 9:
            return 62;
          case 10:
            break;
          case 11:
            break;
          case 12:
            return 5;
          case 13:
            break;
          case 14:
            break;
          case 15:
            break;
          case 16:
            break;
          case 17:
            return this.pushState("SCALE"), 17;
          case 18:
            return 18;
          case 19:
            this.popState();
            break;
          case 20:
            return this.begin("acc_title"), 33;
          case 21:
            return this.popState(), "acc_title_value";
          case 22:
            return this.begin("acc_descr"), 35;
          case 23:
            return this.popState(), "acc_descr_value";
          case 24:
            this.begin("acc_descr_multiline");
            break;
          case 25:
            this.popState();
            break;
          case 26:
            return "acc_descr_multiline_value";
          case 27:
            return this.pushState("CLASSDEF"), 38;
          case 28:
            return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
          case 29:
            return this.popState(), this.pushState("CLASSDEFID"), 39;
          case 30:
            return this.popState(), 40;
          case 31:
            return this.pushState("CLASS"), 42;
          case 32:
            return this.popState(), this.pushState("CLASS_STYLE"), 43;
          case 33:
            return this.popState(), 44;
          case 34:
            return this.pushState("SCALE"), 17;
          case 35:
            return 18;
          case 36:
            this.popState();
            break;
          case 37:
            this.pushState("STATE");
            break;
          case 38:
            return this.popState(), tt.yytext = tt.yytext.slice(0, -8).trim(), 25;
          case 39:
            return this.popState(), tt.yytext = tt.yytext.slice(0, -8).trim(), 26;
          case 40:
            return this.popState(), tt.yytext = tt.yytext.slice(0, -10).trim(), 27;
          case 41:
            return this.popState(), tt.yytext = tt.yytext.slice(0, -8).trim(), 25;
          case 42:
            return this.popState(), tt.yytext = tt.yytext.slice(0, -8).trim(), 26;
          case 43:
            return this.popState(), tt.yytext = tt.yytext.slice(0, -10).trim(), 27;
          case 44:
            return 50;
          case 45:
            return 51;
          case 46:
            return 52;
          case 47:
            return 53;
          case 48:
            this.pushState("STATE_STRING");
            break;
          case 49:
            return this.pushState("STATE_ID"), "AS";
          case 50:
            return this.popState(), "ID";
          case 51:
            this.popState();
            break;
          case 52:
            return "STATE_DESCR";
          case 53:
            return 19;
          case 54:
            this.popState();
            break;
          case 55:
            return this.popState(), this.pushState("struct"), 20;
          case 56:
            break;
          case 57:
            return this.popState(), 21;
          case 58:
            break;
          case 59:
            return this.begin("NOTE"), 29;
          case 60:
            return this.popState(), this.pushState("NOTE_ID"), 58;
          case 61:
            return this.popState(), this.pushState("NOTE_ID"), 59;
          case 62:
            this.popState(), this.pushState("FLOATING_NOTE");
            break;
          case 63:
            return this.popState(), this.pushState("FLOATING_NOTE_ID"), "AS";
          case 64:
            break;
          case 65:
            return "NOTE_TEXT";
          case 66:
            return this.popState(), "ID";
          case 67:
            return this.popState(), this.pushState("NOTE_TEXT"), 24;
          case 68:
            return this.popState(), tt.yytext = tt.yytext.substr(2).trim(), 31;
          case 69:
            return this.popState(), tt.yytext = tt.yytext.slice(0, -8).trim(), 31;
          case 70:
            return 7;
          case 71:
            return 7;
          case 72:
            return 16;
          case 73:
            return 56;
          case 74:
            return 24;
          case 75:
            return tt.yytext = tt.yytext.trim(), 14;
          case 76:
            return 15;
          case 77:
            return 28;
          case 78:
            return 57;
          case 79:
            return 5;
          case 80:
            return "INVALID";
        }
      },
      rules: [/^(?:default\b)/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:[\s]+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:classDef\s+)/i, /^(?:DEFAULT\s+)/i, /^(?:\w+\s+)/i, /^(?:[^\n]*)/i, /^(?:class\s+)/i, /^(?:(\w+)+((,\s*\w+)*))/i, /^(?:[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:state\s+)/i, /^(?:.*<<fork>>)/i, /^(?:.*<<join>>)/i, /^(?:.*<<choice>>)/i, /^(?:.*\[\[fork\]\])/i, /^(?:.*\[\[join\]\])/i, /^(?:.*\[\[choice\]\])/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:["])/i, /^(?:\s*as\s+)/i, /^(?:[^\n\{]*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n\s\{]+)/i, /^(?:\n)/i, /^(?:\{)/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:\})/i, /^(?:[\n])/i, /^(?:note\s+)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:")/i, /^(?:\s*as\s*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n]*)/i, /^(?:\s*[^:\n\s\-]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:[\s\S]*?end note\b)/i, /^(?:stateDiagram\s+)/i, /^(?:stateDiagram-v2\s+)/i, /^(?:hide empty description\b)/i, /^(?:\[\*\])/i, /^(?:[^:\n\s\-\{]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:-->)/i, /^(?:--)/i, /^(?::::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { LINE: { rules: [14, 15], inclusive: !1 }, close_directive: { rules: [14, 15], inclusive: !1 }, arg_directive: { rules: [8, 9, 14, 15], inclusive: !1 }, type_directive: { rules: [7, 8, 14, 15], inclusive: !1 }, open_directive: { rules: [6, 14, 15], inclusive: !1 }, struct: { rules: [14, 15, 27, 31, 37, 44, 45, 46, 47, 56, 57, 58, 59, 73, 74, 75, 76, 77], inclusive: !1 }, FLOATING_NOTE_ID: { rules: [66], inclusive: !1 }, FLOATING_NOTE: { rules: [63, 64, 65], inclusive: !1 }, NOTE_TEXT: { rules: [68, 69], inclusive: !1 }, NOTE_ID: { rules: [67], inclusive: !1 }, NOTE: { rules: [60, 61, 62], inclusive: !1 }, CLASS_STYLE: { rules: [33], inclusive: !1 }, CLASS: { rules: [32], inclusive: !1 }, CLASSDEFID: { rules: [30], inclusive: !1 }, CLASSDEF: { rules: [28, 29], inclusive: !1 }, acc_descr_multiline: { rules: [25, 26], inclusive: !1 }, acc_descr: { rules: [23], inclusive: !1 }, acc_title: { rules: [21], inclusive: !1 }, SCALE: { rules: [18, 19, 35, 36], inclusive: !1 }, ALIAS: { rules: [], inclusive: !1 }, STATE_ID: { rules: [50], inclusive: !1 }, STATE_STRING: { rules: [51, 52], inclusive: !1 }, FORK_STATE: { rules: [], inclusive: !1 }, STATE: { rules: [14, 15, 38, 39, 40, 41, 42, 43, 48, 49, 53, 54, 55], inclusive: !1 }, ID: { rules: [14, 15], inclusive: !1 }, INITIAL: { rules: [0, 1, 2, 3, 4, 5, 10, 11, 12, 13, 15, 16, 17, 20, 22, 24, 27, 31, 34, 37, 55, 59, 70, 71, 72, 73, 74, 75, 76, 78, 79, 80], inclusive: !0 } }
    };
    return Z;
  }();
  N.lexer = it;
  function Y() {
    this.yy = {};
  }
  return Y.prototype = N, N.Parser = Y, new Y();
}();
_1.parser = _1;
const M2 = _1, FV = (t, e) => {
  var r;
  return ((r = e == null ? void 0 : e.state) == null ? void 0 : r.defaultRenderer) === "dagre-wrapper" ? !1 : t.match(/^\s*stateDiagram/) !== null;
}, OV = (t, e) => {
  var r;
  return !!(t.match(/^\s*stateDiagram-v2/) !== null || t.match(/^\s*stateDiagram/) && ((r = e == null ? void 0 : e.state) == null ? void 0 : r.defaultRenderer) === "dagre-wrapper");
}, m4 = "LR", PV = "TB", hc = "state", X0 = "relation", VV = "classDef", YV = "applyClass", To = "default", b4 = "divider", K0 = "[*]", _4 = "start", x4 = K0, v4 = "end", N2 = "color", R2 = "fill", zV = "bgFill", UV = ",";
function k4() {
  return {};
}
let w4 = m4, fc = [], Na = k4();
const T4 = () => ({
  relations: [],
  states: {},
  documents: {}
});
let dc = {
  root: T4()
}, ar = dc.root, io = 0, F2 = 0;
const WV = {
  LINE: 0,
  DOTTED_LINE: 1
}, HV = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3
}, Ho = (t) => JSON.parse(JSON.stringify(t)), GV = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
}, qV = (t) => {
  B.info("Setting root doc", t), fc = t;
}, $V = () => fc, fl = (t, e, r) => {
  if (e.stmt === X0)
    fl(t, e.state1, !0), fl(t, e.state2, !1);
  else if (e.stmt === hc && (e.id === "[*]" ? (e.id = r ? t.id + "_start" : t.id + "_end", e.start = r) : e.id = e.id.trim()), e.doc) {
    const n = [];
    let i = [], s;
    for (s = 0; s < e.doc.length; s++)
      if (e.doc[s].type === b4) {
        const a = Ho(e.doc[s]);
        a.doc = Ho(i), n.push(a), i = [];
      } else
        i.push(e.doc[s]);
    if (n.length > 0 && i.length > 0) {
      const a = {
        stmt: hc,
        id: Vg(),
        type: "divider",
        doc: Ho(i)
      };
      n.push(Ho(a)), e.doc = n;
    }
    e.doc.forEach((a) => fl(e, a, !0));
  }
}, jV = () => (fl({ id: "root" }, { id: "root", doc: fc }, !0), { id: "root", doc: fc }), XV = (t) => {
  let e;
  t.doc ? e = t.doc : e = t, B.info(e), E4(!0), B.info("Extract", e), e.forEach((r) => {
    switch (r.stmt) {
      case hc:
        ji(
          r.id.trim(),
          r.type,
          r.doc,
          r.description,
          r.note,
          r.classes,
          r.styles,
          r.textStyles
        );
        break;
      case X0:
        C4(r.state1, r.state2, r.description);
        break;
      case VV:
        S4(r.id.trim(), r.classes);
        break;
      case YV:
        Z0(r.id.trim(), r.styleClass);
        break;
    }
  });
}, ji = function(t, e = To, r = null, n = null, i = null, s = null, a = null, o = null) {
  const l = t == null ? void 0 : t.trim();
  ar.states[l] === void 0 ? (B.info("Adding state ", l, n), ar.states[l] = {
    id: l,
    descriptions: [],
    type: e,
    doc: r,
    note: i,
    classes: [],
    styles: [],
    textStyles: []
  }) : (ar.states[l].doc || (ar.states[l].doc = r), ar.states[l].type || (ar.states[l].type = e)), n && (B.info("Setting state description", l, n), typeof n == "string" && k1(l, n.trim()), typeof n == "object" && n.forEach((u) => k1(l, u.trim()))), i && (ar.states[l].note = i, ar.states[l].note.text = Xt.sanitizeText(
    ar.states[l].note.text,
    q()
  )), s && (B.info("Setting state classes", l, s), (typeof s == "string" ? [s] : s).forEach((h) => Z0(l, h.trim()))), a && (B.info("Setting state styles", l, a), (typeof a == "string" ? [a] : a).forEach((h) => sY(l, h.trim()))), o && (B.info("Setting state styles", l, a), (typeof o == "string" ? [o] : o).forEach((h) => aY(l, h.trim())));
}, E4 = function(t) {
  dc = {
    root: T4()
  }, ar = dc.root, io = 0, Na = k4(), t || Br();
}, so = function(t) {
  return ar.states[t];
}, KV = function() {
  return ar.states;
}, ZV = function() {
  B.info("Documents = ", dc);
}, QV = function() {
  return ar.relations;
};
function x1(t = "") {
  let e = t;
  return t === K0 && (io++, e = `${_4}${io}`), e;
}
function v1(t = "", e = To) {
  return t === K0 ? _4 : e;
}
function JV(t = "") {
  let e = t;
  return t === x4 && (io++, e = `${v4}${io}`), e;
}
function tY(t = "", e = To) {
  return t === x4 ? v4 : e;
}
function eY(t, e, r) {
  let n = x1(t.id.trim()), i = v1(t.id.trim(), t.type), s = x1(e.id.trim()), a = v1(e.id.trim(), e.type);
  ji(
    n,
    i,
    t.doc,
    t.description,
    t.note,
    t.classes,
    t.styles,
    t.textStyles
  ), ji(
    s,
    a,
    e.doc,
    e.description,
    e.note,
    e.classes,
    e.styles,
    e.textStyles
  ), ar.relations.push({
    id1: n,
    id2: s,
    relationTitle: Xt.sanitizeText(r, q())
  });
}
const C4 = function(t, e, r) {
  if (typeof t == "object")
    eY(t, e, r);
  else {
    const n = x1(t.trim()), i = v1(t), s = JV(e.trim()), a = tY(e);
    ji(n, i), ji(s, a), ar.relations.push({
      id1: n,
      id2: s,
      title: Xt.sanitizeText(r, q())
    });
  }
}, k1 = function(t, e) {
  const r = ar.states[t], n = e.startsWith(":") ? e.replace(":", "").trim() : e;
  r.descriptions.push(Xt.sanitizeText(n, q()));
}, rY = function(t) {
  return t.substring(0, 1) === ":" ? t.substr(2).trim() : t.trim();
}, nY = () => (F2++, "divider-id-" + F2), S4 = function(t, e = "") {
  Na[t] === void 0 && (Na[t] = { id: t, styles: [], textStyles: [] });
  const r = Na[t];
  e != null && e.split(UV).forEach((n) => {
    const i = n.replace(/([^;]*);/, "$1").trim();
    if (n.match(N2)) {
      const a = i.replace(R2, zV).replace(N2, R2);
      r.textStyles.push(a);
    }
    r.styles.push(i);
  });
}, iY = function() {
  return Na;
}, Z0 = function(t, e) {
  t.split(",").forEach(function(r) {
    let n = so(r);
    if (n === void 0) {
      const i = r.trim();
      ji(i), n = so(i);
    }
    n.classes.push(e);
  });
}, sY = function(t, e) {
  const r = so(t);
  r !== void 0 && r.textStyles.push(e);
}, aY = function(t, e) {
  const r = so(t);
  r !== void 0 && r.textStyles.push(e);
}, oY = () => w4, lY = (t) => {
  w4 = t;
}, cY = (t) => t && t[0] === ":" ? t.substr(1).trim() : t.trim(), Yn = {
  parseDirective: GV,
  getConfig: () => q().state,
  addState: ji,
  clear: E4,
  getState: so,
  getStates: KV,
  getRelations: QV,
  getClasses: iY,
  getDirection: oY,
  addRelation: C4,
  getDividerId: nY,
  setDirection: lY,
  cleanupLabel: rY,
  lineType: WV,
  relationType: HV,
  logDocuments: ZV,
  getRootDoc: $V,
  setRootDoc: qV,
  getRootDocV2: jV,
  extract: XV,
  trimColon: cY,
  getAccTitle: Dr,
  setAccTitle: Tr,
  getAccDescription: Mr,
  setAccDescription: Ir,
  addStyleClass: S4,
  setCssClass: Z0,
  addDescription: k1,
  setDiagramTitle: un,
  getDiagramTitle: hn
}, Q0 = {}, uY = (t, e) => {
  Q0[t] = e;
}, hY = (t) => Q0[t], A4 = () => Object.keys(Q0), fY = () => A4().length, dY = {
  get: hY,
  set: uY,
  keys: A4,
  size: fY
}, pY = (t) => t.append("circle").attr("class", "start-state").attr("r", q().state.sizeUnit).attr("cx", q().state.padding + q().state.sizeUnit).attr("cy", q().state.padding + q().state.sizeUnit), gY = (t) => t.append("line").style("stroke", "grey").style("stroke-dasharray", "3").attr("x1", q().state.textHeight).attr("class", "divider").attr("x2", q().state.textHeight * 2).attr("y1", 0).attr("y2", 0), yY = (t, e) => {
  const r = t.append("text").attr("x", 2 * q().state.padding).attr("y", q().state.textHeight + 2 * q().state.padding).attr("font-size", q().state.fontSize).attr("class", "state-title").text(e.id), n = r.node().getBBox();
  return t.insert("rect", ":first-child").attr("x", q().state.padding).attr("y", q().state.padding).attr("width", n.width + 2 * q().state.padding).attr("height", n.height + 2 * q().state.padding).attr("rx", q().state.radius), r;
}, mY = (t, e) => {
  const r = function(d, p, m) {
    const _ = d.append("tspan").attr("x", 2 * q().state.padding).text(p);
    m || _.attr("dy", q().state.textHeight);
  }, i = t.append("text").attr("x", 2 * q().state.padding).attr("y", q().state.textHeight + 1.3 * q().state.padding).attr("font-size", q().state.fontSize).attr("class", "state-title").text(e.descriptions[0]).node().getBBox(), s = i.height, a = t.append("text").attr("x", q().state.padding).attr(
    "y",
    s + q().state.padding * 0.4 + q().state.dividerMargin + q().state.textHeight
  ).attr("class", "state-description");
  let o = !0, l = !0;
  e.descriptions.forEach(function(d) {
    o || (r(a, d, l), l = !1), o = !1;
  });
  const u = t.append("line").attr("x1", q().state.padding).attr("y1", q().state.padding + s + q().state.dividerMargin / 2).attr("y2", q().state.padding + s + q().state.dividerMargin / 2).attr("class", "descr-divider"), h = a.node().getBBox(), f = Math.max(h.width, i.width);
  return u.attr("x2", f + 3 * q().state.padding), t.insert("rect", ":first-child").attr("x", q().state.padding).attr("y", q().state.padding).attr("width", f + 2 * q().state.padding).attr("height", h.height + s + 2 * q().state.padding).attr("rx", q().state.radius), t;
}, bY = (t, e, r) => {
  const n = q().state.padding, i = 2 * q().state.padding, s = t.node().getBBox(), a = s.width, o = s.x, l = t.append("text").attr("x", 0).attr("y", q().state.titleShift).attr("font-size", q().state.fontSize).attr("class", "state-title").text(e.id), h = l.node().getBBox().width + i;
  let f = Math.max(h, a);
  f === a && (f = f + i);
  let d;
  const p = t.node().getBBox();
  e.doc, d = o - n, h > a && (d = (a - f) / 2 + n), Math.abs(o - p.x) < n && h > a && (d = o - (h - a) / 2);
  const m = 1 - q().state.textHeight;
  return t.insert("rect", ":first-child").attr("x", d).attr("y", m).attr("class", r ? "alt-composit" : "composit").attr("width", f).attr(
    "height",
    p.height + q().state.textHeight + q().state.titleShift + 1
  ).attr("rx", "0"), l.attr("x", d + n), h <= a && l.attr("x", o + (f - i) / 2 - h / 2 + n), t.insert("rect", ":first-child").attr("x", d).attr(
    "y",
    q().state.titleShift - q().state.textHeight - q().state.padding
  ).attr("width", f).attr("height", q().state.textHeight * 3).attr("rx", q().state.radius), t.insert("rect", ":first-child").attr("x", d).attr(
    "y",
    q().state.titleShift - q().state.textHeight - q().state.padding
  ).attr("width", f).attr("height", p.height + 3 + 2 * q().state.textHeight).attr("rx", q().state.radius), t;
}, _Y = (t) => (t.append("circle").attr("class", "end-state-outer").attr("r", q().state.sizeUnit + q().state.miniPadding).attr(
  "cx",
  q().state.padding + q().state.sizeUnit + q().state.miniPadding
).attr(
  "cy",
  q().state.padding + q().state.sizeUnit + q().state.miniPadding
), t.append("circle").attr("class", "end-state-inner").attr("r", q().state.sizeUnit).attr("cx", q().state.padding + q().state.sizeUnit + 2).attr("cy", q().state.padding + q().state.sizeUnit + 2)), xY = (t, e) => {
  let r = q().state.forkWidth, n = q().state.forkHeight;
  if (e.parentId) {
    let i = r;
    r = n, n = i;
  }
  return t.append("rect").style("stroke", "black").style("fill", "black").attr("width", r).attr("height", n).attr("x", q().state.padding).attr("y", q().state.padding);
}, vY = (t, e, r, n) => {
  let i = 0;
  const s = n.append("text");
  s.style("text-anchor", "start"), s.attr("class", "noteText");
  let a = t.replace(/\r\n/g, "<br/>");
  a = a.replace(/\n/g, "<br/>");
  const o = a.split(Xt.lineBreakRegex);
  let l = 1.25 * q().state.noteMargin;
  for (const u of o) {
    const h = u.trim();
    if (h.length > 0) {
      const f = s.append("tspan");
      if (f.text(h), l === 0) {
        const d = f.node().getBBox();
        l += d.height;
      }
      i += l, f.attr("x", e + q().state.noteMargin), f.attr("y", r + i + 1.25 * q().state.noteMargin);
    }
  }
  return { textWidth: s.node().getBBox().width, textHeight: i };
}, kY = (t, e) => {
  e.attr("class", "state-note");
  const r = e.append("rect").attr("x", 0).attr("y", q().state.padding), n = e.append("g"), { textWidth: i, textHeight: s } = vY(t, 0, 0, n);
  return r.attr("height", s + 2 * q().state.noteMargin), r.attr("width", i + q().state.noteMargin * 2), r;
}, O2 = function(t, e) {
  const r = e.id, n = {
    id: r,
    label: e.id,
    width: 0,
    height: 0
  }, i = t.append("g").attr("id", r).attr("class", "stateGroup");
  e.type === "start" && pY(i), e.type === "end" && _Y(i), (e.type === "fork" || e.type === "join") && xY(i, e), e.type === "note" && kY(e.note.text, i), e.type === "divider" && gY(i), e.type === "default" && e.descriptions.length === 0 && yY(i, e), e.type === "default" && e.descriptions.length > 0 && mY(i, e);
  const s = i.node().getBBox();
  return n.width = s.width + 2 * q().state.padding, n.height = s.height + 2 * q().state.padding, dY.set(r, n), n;
};
let P2 = 0;
const wY = function(t, e, r) {
  const n = function(l) {
    switch (l) {
      case Yn.relationType.AGGREGATION:
        return "aggregation";
      case Yn.relationType.EXTENSION:
        return "extension";
      case Yn.relationType.COMPOSITION:
        return "composition";
      case Yn.relationType.DEPENDENCY:
        return "dependency";
    }
  };
  e.points = e.points.filter((l) => !Number.isNaN(l.y));
  const i = e.points, s = js().x(function(l) {
    return l.x;
  }).y(function(l) {
    return l.y;
  }).curve(Is), a = t.append("path").attr("d", s(i)).attr("id", "edge" + P2).attr("class", "transition");
  let o = "";
  if (q().state.arrowMarkerAbsolute && (o = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, o = o.replace(/\(/g, "\\("), o = o.replace(/\)/g, "\\)")), a.attr(
    "marker-end",
    "url(" + o + "#" + n(Yn.relationType.DEPENDENCY) + "End)"
  ), r.title !== void 0) {
    const l = t.append("g").attr("class", "stateLabel"), { x: u, y: h } = jt.calcLabelPosition(e.points), f = Xt.getRows(r.title);
    let d = 0;
    const p = [];
    let m = 0, _ = 0;
    for (let x = 0; x <= f.length; x++) {
      const D = l.append("text").attr("text-anchor", "middle").text(f[x]).attr("x", u).attr("y", h + d), F = D.node().getBBox();
      m = Math.max(m, F.width), _ = Math.min(_, F.x), B.info(F.x, u, h + d), d === 0 && (d = D.node().getBBox().height, B.info("Title height", d, h)), p.push(D);
    }
    let v = d * f.length;
    if (f.length > 1) {
      const x = (f.length - 1) * d * 0.5;
      p.forEach((D, F) => D.attr("y", h + F * d - x)), v = d * f.length;
    }
    const k = l.node().getBBox();
    l.insert("rect", ":first-child").attr("class", "box").attr("x", u - m / 2 - q().state.padding / 2).attr("y", h - v / 2 - q().state.padding / 2 - 3.5).attr("width", m + q().state.padding).attr("height", v + q().state.padding), B.info(k);
  }
  P2++;
};
let Cr;
const Zu = {}, TY = function() {
}, EY = function(t) {
  t.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, CY = function(t, e, r, n) {
  Cr = q().state;
  const i = q().securityLevel;
  let s;
  i === "sandbox" && (s = _t("#i" + e));
  const a = _t(i === "sandbox" ? s.nodes()[0].contentDocument.body : "body"), o = i === "sandbox" ? s.nodes()[0].contentDocument : document;
  B.debug("Rendering diagram " + t);
  const l = a.select(`[id='${e}']`);
  EY(l), new Ve({
    multigraph: !0,
    compound: !0,
    // acyclicer: 'greedy',
    rankdir: "RL"
    // ranksep: '20'
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  const h = n.db.getRootDoc();
  L4(h, l, void 0, !1, a, o, n);
  const f = Cr.padding, d = l.node().getBBox(), p = d.width + f * 2, m = d.height + f * 2, _ = p * 1.75;
  cn(l, m, _, Cr.useMaxWidth), l.attr(
    "viewBox",
    `${d.x - Cr.padding}  ${d.y - Cr.padding} ` + p + " " + m
  );
}, SY = (t) => t ? t.length * Cr.fontSizeFactor : 1, L4 = (t, e, r, n, i, s, a) => {
  const o = new Ve({
    compound: !0,
    multigraph: !0
  });
  let l, u = !0;
  for (l = 0; l < t.length; l++)
    if (t[l].stmt === "relation") {
      u = !1;
      break;
    }
  r ? o.setGraph({
    rankdir: "LR",
    multigraph: !0,
    compound: !0,
    // acyclicer: 'greedy',
    ranker: "tight-tree",
    ranksep: u ? 1 : Cr.edgeLengthFactor,
    nodeSep: u ? 1 : 50,
    isMultiGraph: !0
    // ranksep: 5,
    // nodesep: 1
  }) : o.setGraph({
    rankdir: "TB",
    multigraph: !0,
    compound: !0,
    // isCompound: true,
    // acyclicer: 'greedy',
    // ranker: 'longest-path'
    ranksep: u ? 1 : Cr.edgeLengthFactor,
    nodeSep: u ? 1 : 50,
    ranker: "tight-tree",
    // ranker: 'network-simplex'
    isMultiGraph: !0
  }), o.setDefaultEdgeLabel(function() {
    return {};
  }), a.db.extract(t);
  const h = a.db.getStates(), f = a.db.getRelations(), d = Object.keys(h);
  for (const k of d) {
    const x = h[k];
    r && (x.parentId = r);
    let D;
    if (x.doc) {
      let F = e.append("g").attr("id", x.id).attr("class", "stateGroup");
      D = L4(x.doc, F, x.id, !n, i, s, a);
      {
        F = bY(F, x, n);
        let P = F.node().getBBox();
        D.width = P.width, D.height = P.height + Cr.padding / 2, Zu[x.id] = { y: Cr.compositTitleSize };
      }
    } else
      D = O2(e, x);
    if (x.note) {
      const F = {
        descriptions: [],
        id: x.id + "-note",
        note: x.note,
        type: "note"
      }, P = O2(e, F);
      x.note.position === "left of" ? (o.setNode(D.id + "-note", P), o.setNode(D.id, D)) : (o.setNode(D.id, D), o.setNode(D.id + "-note", P)), o.setParent(D.id, D.id + "-group"), o.setParent(D.id + "-note", D.id + "-group");
    } else
      o.setNode(D.id, D);
  }
  B.debug("Count=", o.nodeCount(), o);
  let p = 0;
  f.forEach(function(k) {
    p++, B.debug("Setting edge", k), o.setEdge(
      k.id1,
      k.id2,
      {
        relation: k,
        width: SY(k.title),
        height: Cr.labelHeight * Xt.getRows(k.title).length,
        labelpos: "c"
      },
      "id" + p
    );
  }), ta(o), B.debug("Graph after layout", o.nodes());
  const m = e.node();
  o.nodes().forEach(function(k) {
    k !== void 0 && o.node(k) !== void 0 ? (B.warn("Node " + k + ": " + JSON.stringify(o.node(k))), i.select("#" + m.id + " #" + k).attr(
      "transform",
      "translate(" + (o.node(k).x - o.node(k).width / 2) + "," + (o.node(k).y + (Zu[k] ? Zu[k].y : 0) - o.node(k).height / 2) + " )"
    ), i.select("#" + m.id + " #" + k).attr("data-x-shift", o.node(k).x - o.node(k).width / 2), s.querySelectorAll("#" + m.id + " #" + k + " .divider").forEach((D) => {
      const F = D.parentElement;
      let P = 0, V = 0;
      F && (F.parentElement && (P = F.parentElement.getBBox().width), V = parseInt(F.getAttribute("data-x-shift"), 10), Number.isNaN(V) && (V = 0)), D.setAttribute("x1", 0 - V + 8), D.setAttribute("x2", P - V - 8);
    })) : B.debug("No Node " + k + ": " + JSON.stringify(o.node(k)));
  });
  let _ = m.getBBox();
  o.edges().forEach(function(k) {
    k !== void 0 && o.edge(k) !== void 0 && (B.debug("Edge " + k.v + " -> " + k.w + ": " + JSON.stringify(o.edge(k))), wY(e, o.edge(k), o.edge(k).relation));
  }), _ = m.getBBox();
  const v = {
    id: r || "root",
    label: r || "root",
    width: 0,
    height: 0
  };
  return v.width = _.width + 2 * Cr.padding, v.height = _.height + 2 * Cr.padding, B.debug("Doc rendered", v, o), v;
}, AY = {
  setConf: TY,
  draw: CY
}, dl = "rect", Qu = "rectWithTitle", LY = "start", BY = "end", DY = "divider", IY = "roundedWithTitle", MY = "note", NY = "noteGroup", qs = "statediagram", RY = "state", FY = `${qs}-${RY}`, B4 = "transition", OY = "note", PY = "note-edge", VY = `${B4} ${PY}`, YY = `${qs}-${OY}`, zY = "cluster", UY = `${qs}-${zY}`, WY = "cluster-alt", HY = `${qs}-${WY}`, D4 = "parent", I4 = "note", GY = "state", J0 = "----", qY = `${J0}${I4}`, V2 = `${J0}${D4}`, M4 = "fill:none", N4 = "fill: #333", R4 = "c", F4 = "text", O4 = "normal";
let pl = {}, oi = 0;
const $Y = function(t) {
  const e = Object.keys(t);
  for (const r of e)
    t[r];
}, jY = function(t, e) {
  B.trace("Extracting classes"), e.db.clear();
  try {
    return e.parser.parse(t), e.db.extract(e.db.getRootDocV2()), e.db.getClasses();
  } catch (r) {
    return r;
  }
};
function XY(t) {
  return t == null ? "" : t.classes ? t.classes.join(" ") : "";
}
function Ju(t = "", e = 0, r = "", n = J0) {
  const i = r !== null && r.length > 0 ? `${n}${r}` : "";
  return `${GY}-${t}${i}-${e}`;
}
const ka = (t, e, r, n, i, s) => {
  const a = r.id, o = XY(n[a]);
  if (a !== "root") {
    let l = dl;
    r.start === !0 && (l = LY), r.start === !1 && (l = BY), r.type !== To && (l = r.type), pl[a] || (pl[a] = {
      id: a,
      shape: l,
      description: Xt.sanitizeText(a, q()),
      classes: `${o} ${FY}`
    });
    const u = pl[a];
    r.description && (Array.isArray(u.description) ? (u.shape = Qu, u.description.push(r.description)) : u.description.length > 0 ? (u.shape = Qu, u.description === a ? u.description = [r.description] : u.description = [u.description, r.description]) : (u.shape = dl, u.description = r.description), u.description = Xt.sanitizeTextOrArray(u.description, q())), u.description.length === 1 && u.shape === Qu && (u.shape = dl), !u.type && r.doc && (B.info("Setting cluster for ", a, w1(r)), u.type = "group", u.dir = w1(r), u.shape = r.type === b4 ? DY : IY, u.classes = u.classes + " " + UY + " " + (s ? HY : ""));
    const h = {
      labelStyle: "",
      shape: u.shape,
      labelText: u.description,
      // typeof newNode.description === 'object'
      //   ? newNode.description[0]
      //   : newNode.description,
      classes: u.classes,
      style: "",
      //styles.style,
      id: a,
      dir: u.dir,
      domId: Ju(a, oi),
      type: u.type,
      padding: 15
      //getConfig().flowchart.padding
    };
    if (r.note) {
      const f = {
        labelStyle: "",
        shape: MY,
        labelText: r.note.text,
        classes: YY,
        style: "",
        // styles.style,
        id: a + qY + "-" + oi,
        domId: Ju(a, oi, I4),
        type: u.type,
        padding: 15
        //getConfig().flowchart.padding
      }, d = {
        labelStyle: "",
        shape: NY,
        labelText: r.note.text,
        classes: u.classes,
        style: "",
        // styles.style,
        id: a + V2,
        domId: Ju(a, oi, D4),
        type: "group",
        padding: 0
        //getConfig().flowchart.padding
      };
      oi++;
      const p = a + V2;
      t.setNode(p, d), t.setNode(f.id, f), t.setNode(a, h), t.setParent(a, p), t.setParent(f.id, p);
      let m = a, _ = f.id;
      r.note.position === "left of" && (m = f.id, _ = a), t.setEdge(m, _, {
        arrowhead: "none",
        arrowType: "",
        style: M4,
        labelStyle: "",
        classes: VY,
        arrowheadStyle: N4,
        labelpos: R4,
        labelType: F4,
        thickness: O4
      });
    } else
      t.setNode(a, h);
  }
  e && e.id !== "root" && (B.trace("Setting node ", a, " to be child of its parent ", e.id), t.setParent(a, e.id)), r.doc && (B.trace("Adding nodes children "), KY(t, r, r.doc, n, i, !s));
}, KY = (t, e, r, n, i, s) => {
  B.trace("items", r), r.forEach((a) => {
    switch (a.stmt) {
      case hc:
        ka(t, e, a, n, i, s);
        break;
      case To:
        ka(t, e, a, n, i, s);
        break;
      case X0:
        {
          ka(t, e, a.state1, n, i, s), ka(t, e, a.state2, n, i, s);
          const o = {
            id: "edge" + oi,
            arrowhead: "normal",
            arrowTypeEnd: "arrow_barb",
            style: M4,
            labelStyle: "",
            label: Xt.sanitizeText(a.description, q()),
            arrowheadStyle: N4,
            labelpos: R4,
            labelType: F4,
            thickness: O4,
            classes: B4
          };
          t.setEdge(a.state1.id, a.state2.id, o, oi), oi++;
        }
        break;
    }
  });
}, w1 = (t, e = PV) => {
  let r = e;
  if (t.doc)
    for (let n = 0; n < t.doc.length; n++) {
      const i = t.doc[n];
      i.stmt === "dir" && (r = i.value);
    }
  return r;
}, ZY = function(t, e, r, n) {
  B.info("Drawing state diagram (v2)", e), pl = {};
  let i = n.db.getDirection();
  i === void 0 && (i = m4);
  const { securityLevel: s, state: a } = q(), o = a.nodeSpacing || 50, l = a.rankSpacing || 50;
  B.info(n.db.getRootDocV2()), n.db.extract(n.db.getRootDocV2()), B.info(n.db.getRootDocV2());
  const u = n.db.getStates(), h = new Ve({
    multigraph: !0,
    compound: !0
  }).setGraph({
    rankdir: w1(n.db.getRootDocV2()),
    nodesep: o,
    ranksep: l,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  ka(h, void 0, n.db.getRootDocV2(), u, n.db, !0);
  let f;
  s === "sandbox" && (f = _t("#i" + e));
  const d = _t(s === "sandbox" ? f.nodes()[0].contentDocument.body : "body"), p = d.select(`[id="${e}"]`), m = d.select("#" + e + " g");
  B0(m, h, ["barb"], qs, e);
  const _ = 8;
  jt.insertTitle(p, "statediagramTitleText", a.titleTopMargin, n.db.getDiagramTitle());
  const v = p.node().getBBox(), k = v.width + _ * 2, x = v.height + _ * 2;
  p.attr("class", qs);
  const D = p.node().getBBox();
  cn(p, x, k, a.useMaxWidth);
  const F = `${D.x - _} ${D.y - _} ${k} ${x}`;
  B.debug(`viewBox ${F}`), p.attr("viewBox", F);
  const P = document.querySelectorAll('[id="' + e + '"] .edgeLabel .label');
  for (const V of P) {
    const R = V.getBBox(), O = document.createElementNS("http://www.w3.org/2000/svg", dl);
    O.setAttribute("rx", 0), O.setAttribute("ry", 0), O.setAttribute("width", R.width), O.setAttribute("height", R.height), V.insertBefore(O, V.firstChild);
  }
}, QY = {
  setConf: $Y,
  getClasses: jY,
  draw: ZY
};
var T1 = function() {
  var t = function(_, v, k, x) {
    for (k = k || {}, x = _.length; x--; k[_[x]] = v)
      ;
    return k;
  }, e = [1, 2], r = [1, 5], n = [6, 9, 11, 17, 18, 20, 22, 23, 24, 26], i = [1, 15], s = [1, 16], a = [1, 17], o = [1, 18], l = [1, 19], u = [1, 20], h = [1, 24], f = [4, 6, 9, 11, 17, 18, 20, 22, 23, 24, 26], d = {
    trace: function() {
    },
    yy: {},
    symbols_: { error: 2, start: 3, journey: 4, document: 5, EOF: 6, directive: 7, line: 8, SPACE: 9, statement: 10, NEWLINE: 11, openDirective: 12, typeDirective: 13, closeDirective: 14, ":": 15, argDirective: 16, title: 17, acc_title: 18, acc_title_value: 19, acc_descr: 20, acc_descr_value: 21, acc_descr_multiline_value: 22, section: 23, taskName: 24, taskData: 25, open_directive: 26, type_directive: 27, arg_directive: 28, close_directive: 29, $accept: 0, $end: 1 },
    terminals_: { 2: "error", 4: "journey", 6: "EOF", 9: "SPACE", 11: "NEWLINE", 15: ":", 17: "title", 18: "acc_title", 19: "acc_title_value", 20: "acc_descr", 21: "acc_descr_value", 22: "acc_descr_multiline_value", 23: "section", 24: "taskName", 25: "taskData", 26: "open_directive", 27: "type_directive", 28: "arg_directive", 29: "close_directive" },
    productions_: [0, [3, 3], [3, 2], [5, 0], [5, 2], [8, 2], [8, 1], [8, 1], [8, 1], [7, 4], [7, 6], [10, 1], [10, 2], [10, 2], [10, 1], [10, 1], [10, 2], [10, 1], [12, 1], [13, 1], [16, 1], [14, 1]],
    performAction: function(v, k, x, D, F, P, V) {
      var R = P.length - 1;
      switch (F) {
        case 1:
          return P[R - 1];
        case 3:
          this.$ = [];
          break;
        case 4:
          P[R - 1].push(P[R]), this.$ = P[R - 1];
          break;
        case 5:
        case 6:
          this.$ = P[R];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 11:
          D.setDiagramTitle(P[R].substr(6)), this.$ = P[R].substr(6);
          break;
        case 12:
          this.$ = P[R].trim(), D.setAccTitle(this.$);
          break;
        case 13:
        case 14:
          this.$ = P[R].trim(), D.setAccDescription(this.$);
          break;
        case 15:
          D.addSection(P[R].substr(8)), this.$ = P[R].substr(8);
          break;
        case 16:
          D.addTask(P[R - 1], P[R]), this.$ = "task";
          break;
        case 18:
          D.parseDirective("%%{", "open_directive");
          break;
        case 19:
          D.parseDirective(P[R], "type_directive");
          break;
        case 20:
          P[R] = P[R].trim().replace(/'/g, '"'), D.parseDirective(P[R], "arg_directive");
          break;
        case 21:
          D.parseDirective("}%%", "close_directive", "journey");
          break;
      }
    },
    table: [{ 3: 1, 4: e, 7: 3, 12: 4, 26: r }, { 1: [3] }, t(n, [2, 3], { 5: 6 }), { 3: 7, 4: e, 7: 3, 12: 4, 26: r }, { 13: 8, 27: [1, 9] }, { 27: [2, 18] }, { 6: [1, 10], 7: 21, 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: 4, 17: i, 18: s, 20: a, 22: o, 23: l, 24: u, 26: r }, { 1: [2, 2] }, { 14: 22, 15: [1, 23], 29: h }, t([15, 29], [2, 19]), t(n, [2, 8], { 1: [2, 1] }), t(n, [2, 4]), { 7: 21, 10: 25, 12: 4, 17: i, 18: s, 20: a, 22: o, 23: l, 24: u, 26: r }, t(n, [2, 6]), t(n, [2, 7]), t(n, [2, 11]), { 19: [1, 26] }, { 21: [1, 27] }, t(n, [2, 14]), t(n, [2, 15]), { 25: [1, 28] }, t(n, [2, 17]), { 11: [1, 29] }, { 16: 30, 28: [1, 31] }, { 11: [2, 21] }, t(n, [2, 5]), t(n, [2, 12]), t(n, [2, 13]), t(n, [2, 16]), t(f, [2, 9]), { 14: 32, 29: h }, { 29: [2, 20] }, { 11: [1, 33] }, t(f, [2, 10])],
    defaultActions: { 5: [2, 18], 7: [2, 2], 24: [2, 21], 31: [2, 20] },
    parseError: function(v, k) {
      if (k.recoverable)
        this.trace(v);
      else {
        var x = new Error(v);
        throw x.hash = k, x;
      }
    },
    parse: function(v) {
      var k = this, x = [0], D = [], F = [null], P = [], V = this.table, R = "", O = 0, C = 0, S = 2, T = 1, b = P.slice.call(arguments, 1), w = Object.create(this.lexer), g = { yy: {} };
      for (var M in this.yy)
        Object.prototype.hasOwnProperty.call(this.yy, M) && (g.yy[M] = this.yy[M]);
      w.setInput(v, g.yy), g.yy.lexer = w, g.yy.parser = this, typeof w.yylloc > "u" && (w.yylloc = {});
      var y = w.yylloc;
      P.push(y);
      var N = w.options && w.options.ranges;
      typeof g.yy.parseError == "function" ? this.parseError = g.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function it() {
        var j;
        return j = D.pop() || w.lex() || T, typeof j != "number" && (j instanceof Array && (D = j, j = D.pop()), j = k.symbols_[j] || j), j;
      }
      for (var Y, Z, J, X, tt = {}, st, lt, U, Tt; ; ) {
        if (Z = x[x.length - 1], this.defaultActions[Z] ? J = this.defaultActions[Z] : ((Y === null || typeof Y > "u") && (Y = it()), J = V[Z] && V[Z][Y]), typeof J > "u" || !J.length || !J[0]) {
          var $ = "";
          Tt = [];
          for (st in V[Z])
            this.terminals_[st] && st > S && Tt.push("'" + this.terminals_[st] + "'");
          w.showPosition ? $ = "Parse error on line " + (O + 1) + `:
` + w.showPosition() + `
Expecting ` + Tt.join(", ") + ", got '" + (this.terminals_[Y] || Y) + "'" : $ = "Parse error on line " + (O + 1) + ": Unexpected " + (Y == T ? "end of input" : "'" + (this.terminals_[Y] || Y) + "'"), this.parseError($, {
            text: w.match,
            token: this.terminals_[Y] || Y,
            line: w.yylineno,
            loc: y,
            expected: Tt
          });
        }
        if (J[0] instanceof Array && J.length > 1)
          throw new Error("Parse Error: multiple actions possible at state: " + Z + ", token: " + Y);
        switch (J[0]) {
          case 1:
            x.push(Y), F.push(w.yytext), P.push(w.yylloc), x.push(J[1]), Y = null, C = w.yyleng, R = w.yytext, O = w.yylineno, y = w.yylloc;
            break;
          case 2:
            if (lt = this.productions_[J[1]][1], tt.$ = F[F.length - lt], tt._$ = {
              first_line: P[P.length - (lt || 1)].first_line,
              last_line: P[P.length - 1].last_line,
              first_column: P[P.length - (lt || 1)].first_column,
              last_column: P[P.length - 1].last_column
            }, N && (tt._$.range = [
              P[P.length - (lt || 1)].range[0],
              P[P.length - 1].range[1]
            ]), X = this.performAction.apply(tt, [
              R,
              C,
              O,
              g.yy,
              J[1],
              F,
              P
            ].concat(b)), typeof X < "u")
              return X;
            lt && (x = x.slice(0, -1 * lt * 2), F = F.slice(0, -1 * lt), P = P.slice(0, -1 * lt)), x.push(this.productions_[J[1]][0]), F.push(tt.$), P.push(tt._$), U = V[x[x.length - 2]][x[x.length - 1]], x.push(U);
            break;
          case 3:
            return !0;
        }
      }
      return !0;
    }
  }, p = function() {
    var _ = {
      EOF: 1,
      parseError: function(k, x) {
        if (this.yy.parser)
          this.yy.parser.parseError(k, x);
        else
          throw new Error(k);
      },
      // resets the lexer, sets new input
      setInput: function(v, k) {
        return this.yy = k || this.yy || {}, this._input = v, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
      },
      // consumes and returns one char from the input
      input: function() {
        var v = this._input[0];
        this.yytext += v, this.yyleng++, this.offset++, this.match += v, this.matched += v;
        var k = v.match(/(?:\r\n?|\n).*/g);
        return k ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), v;
      },
      // unshifts one char (or a string) into the input
      unput: function(v) {
        var k = v.length, x = v.split(/(?:\r\n?|\n)/g);
        this._input = v + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - k), this.offset -= k;
        var D = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), x.length - 1 && (this.yylineno -= x.length - 1);
        var F = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: x ? (x.length === D.length ? this.yylloc.first_column : 0) + D[D.length - x.length].length - x[0].length : this.yylloc.first_column - k
        }, this.options.ranges && (this.yylloc.range = [F[0], F[0] + this.yyleng - k]), this.yyleng = this.yytext.length, this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function() {
        return this._more = !0, this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function() {
        if (this.options.backtrack_lexer)
          this._backtrack = !0;
        else
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        return this;
      },
      // retain first n characters of the match
      less: function(v) {
        this.unput(this.match.slice(v));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function() {
        var v = this.matched.substr(0, this.matched.length - this.match.length);
        return (v.length > 20 ? "..." : "") + v.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function() {
        var v = this.match;
        return v.length < 20 && (v += this._input.substr(0, 20 - v.length)), (v.substr(0, 20) + (v.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function() {
        var v = this.pastInput(), k = new Array(v.length + 1).join("-");
        return v + this.upcomingInput() + `
` + k + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function(v, k) {
        var x, D, F;
        if (this.options.backtrack_lexer && (F = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (F.yylloc.range = this.yylloc.range.slice(0))), D = v[0].match(/(?:\r\n?|\n).*/g), D && (this.yylineno += D.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: D ? D[D.length - 1].length - D[D.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + v[0].length
        }, this.yytext += v[0], this.match += v[0], this.matches = v, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(v[0].length), this.matched += v[0], x = this.performAction.call(this, this.yy, this, k, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), x)
          return x;
        if (this._backtrack) {
          for (var P in F)
            this[P] = F[P];
          return !1;
        }
        return !1;
      },
      // return next match in input
      next: function() {
        if (this.done)
          return this.EOF;
        this._input || (this.done = !0);
        var v, k, x, D;
        this._more || (this.yytext = "", this.match = "");
        for (var F = this._currentRules(), P = 0; P < F.length; P++)
          if (x = this._input.match(this.rules[F[P]]), x && (!k || x[0].length > k[0].length)) {
            if (k = x, D = P, this.options.backtrack_lexer) {
              if (v = this.test_match(x, F[P]), v !== !1)
                return v;
              if (this._backtrack) {
                k = !1;
                continue;
              } else
                return !1;
            } else if (!this.options.flex)
              break;
          }
        return k ? (v = this.test_match(k, F[D]), v !== !1 ? v : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      },
      // return next match that has a token
      lex: function() {
        var k = this.next();
        return k || this.lex();
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function(k) {
        this.conditionStack.push(k);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function() {
        var k = this.conditionStack.length - 1;
        return k > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function(k) {
        return k = this.conditionStack.length - 1 - Math.abs(k || 0), k >= 0 ? this.conditionStack[k] : "INITIAL";
      },
      // alias for begin(condition)
      pushState: function(k) {
        this.begin(k);
      },
      // return the number of states currently on the stack
      stateStackSize: function() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": !0 },
      performAction: function(k, x, D, F) {
        switch (D) {
          case 0:
            return this.begin("open_directive"), 26;
          case 1:
            return this.begin("type_directive"), 27;
          case 2:
            return this.popState(), this.begin("arg_directive"), 15;
          case 3:
            return this.popState(), this.popState(), 29;
          case 4:
            return 28;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return 11;
          case 8:
            break;
          case 9:
            break;
          case 10:
            return 4;
          case 11:
            return 17;
          case 12:
            return this.begin("acc_title"), 18;
          case 13:
            return this.popState(), "acc_title_value";
          case 14:
            return this.begin("acc_descr"), 20;
          case 15:
            return this.popState(), "acc_descr_value";
          case 16:
            this.begin("acc_descr_multiline");
            break;
          case 17:
            this.popState();
            break;
          case 18:
            return "acc_descr_multiline_value";
          case 19:
            return 23;
          case 20:
            return 24;
          case 21:
            return 25;
          case 22:
            return 15;
          case 23:
            return 6;
          case 24:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:journey\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { open_directive: { rules: [1], inclusive: !1 }, type_directive: { rules: [2, 3], inclusive: !1 }, arg_directive: { rules: [3, 4], inclusive: !1 }, acc_descr_multiline: { rules: [17, 18], inclusive: !1 }, acc_descr: { rules: [15], inclusive: !1 }, acc_title: { rules: [13], inclusive: !1 }, INITIAL: { rules: [0, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 19, 20, 21, 22, 23, 24], inclusive: !0 } }
    };
    return _;
  }();
  d.lexer = p;
  function m() {
    this.yy = {};
  }
  return m.prototype = d, d.Parser = m, new m();
}();
T1.parser = T1;
const JY = T1, tz = (t) => t.match(/^\s*journey/) !== null;
let $s = "";
const tf = [], ao = [], oo = [], ez = function(t, e, r) {
  xe.parseDirective(this, t, e, r);
}, rz = function() {
  tf.length = 0, ao.length = 0, $s = "", oo.length = 0, Br();
}, nz = function(t) {
  $s = t, tf.push(t);
}, iz = function() {
  return tf;
}, sz = function() {
  let t = Y2();
  const e = 100;
  let r = 0;
  for (; !t && r < e; )
    t = Y2(), r++;
  return ao.push(...oo), ao;
}, az = function() {
  const t = [];
  return ao.forEach((r) => {
    r.people && t.push(...r.people);
  }), [...new Set(t)].sort();
}, oz = function(t, e) {
  const r = e.substr(1).split(":");
  let n = 0, i = [];
  r.length === 1 ? (n = Number(r[0]), i = []) : (n = Number(r[0]), i = r[1].split(","));
  const s = i.map((o) => o.trim()), a = {
    section: $s,
    type: $s,
    people: s,
    task: t,
    score: n
  };
  oo.push(a);
}, lz = function(t) {
  const e = {
    section: $s,
    type: $s,
    description: t,
    task: t,
    classes: []
  };
  ao.push(e);
}, Y2 = function() {
  const t = function(r) {
    return oo[r].processed;
  };
  let e = !0;
  for (const [r, n] of oo.entries())
    t(r), e = e && n.processed;
  return e;
}, cz = function() {
  return az();
}, z2 = {
  parseDirective: ez,
  getConfig: () => q().journey,
  clear: rz,
  setDiagramTitle: un,
  getDiagramTitle: hn,
  setAccTitle: Tr,
  getAccTitle: Dr,
  setAccDescription: Ir,
  getAccDescription: Mr,
  addSection: nz,
  getSections: iz,
  getTasks: sz,
  addTask: oz,
  addTaskOrg: lz,
  getActors: cz
}, ou = function(t, e) {
  const r = t.append("rect");
  return r.attr("x", e.x), r.attr("y", e.y), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("width", e.width), r.attr("height", e.height), r.attr("rx", e.rx), r.attr("ry", e.ry), e.class !== void 0 && r.attr("class", e.class), r;
}, uz = function(t, e) {
  const n = t.append("circle").attr("cx", e.cx).attr("cy", e.cy).attr("class", "face").attr("r", 15).attr("stroke-width", 2).attr("overflow", "visible"), i = t.append("g");
  i.append("circle").attr("cx", e.cx - 15 / 3).attr("cy", e.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), i.append("circle").attr("cx", e.cx + 15 / 3).attr("cy", e.cy - 15 / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  function s(l) {
    const u = xh().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", u).attr("transform", "translate(" + e.cx + "," + (e.cy + 2) + ")");
  }
  function a(l) {
    const u = xh().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(7.5).outerRadius(6.8181818181818175);
    l.append("path").attr("class", "mouth").attr("d", u).attr("transform", "translate(" + e.cx + "," + (e.cy + 7) + ")");
  }
  function o(l) {
    l.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", e.cx - 5).attr("y1", e.cy + 7).attr("x2", e.cx + 5).attr("y2", e.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
  }
  return e.score > 3 ? s(i) : e.score < 3 ? a(i) : o(i), n;
}, P4 = function(t, e) {
  const r = t.append("circle");
  return r.attr("cx", e.cx), r.attr("cy", e.cy), r.attr("class", "actor-" + e.pos), r.attr("fill", e.fill), r.attr("stroke", e.stroke), r.attr("r", e.r), r.class !== void 0 && r.attr("class", r.class), e.title !== void 0 && r.append("title").text(e.title), r;
}, V4 = function(t, e) {
  const r = e.text.replace(/<br\s*\/?>/gi, " "), n = t.append("text");
  n.attr("x", e.x), n.attr("y", e.y), n.attr("class", "legend"), n.style("text-anchor", e.anchor), e.class !== void 0 && n.attr("class", e.class);
  const i = n.append("tspan");
  return i.attr("x", e.x + e.textMargin * 2), i.text(r), n;
}, hz = function(t, e) {
  function r(i, s, a, o, l) {
    return i + "," + s + " " + (i + a) + "," + s + " " + (i + a) + "," + (s + o - l) + " " + (i + a - l * 1.2) + "," + (s + o) + " " + i + "," + (s + o);
  }
  const n = t.append("polygon");
  n.attr("points", r(e.x, e.y, 50, 20, 7)), n.attr("class", "labelBox"), e.y = e.y + e.labelMargin, e.x = e.x + 0.5 * e.labelMargin, V4(t, e);
}, fz = function(t, e, r) {
  const n = t.append("g"), i = ef();
  i.x = e.x, i.y = e.y, i.fill = e.fill, i.width = r.width, i.height = r.height, i.class = "journey-section section-type-" + e.num, i.rx = 3, i.ry = 3, ou(n, i), Y4(r)(
    e.text,
    n,
    i.x,
    i.y,
    i.width,
    i.height,
    { class: "journey-section section-type-" + e.num },
    r,
    e.colour
  );
};
let U2 = -1;
const dz = function(t, e, r) {
  const n = e.x + r.width / 2, i = t.append("g");
  U2++;
  const s = 300 + 5 * 30;
  i.append("line").attr("id", "task" + U2).attr("x1", n).attr("y1", e.y).attr("x2", n).attr("y2", s).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666"), uz(i, {
    cx: n,
    cy: 300 + (5 - e.score) * 30,
    score: e.score
  });
  const a = ef();
  a.x = e.x, a.y = e.y, a.fill = e.fill, a.width = r.width, a.height = r.height, a.class = "task task-type-" + e.num, a.rx = 3, a.ry = 3, ou(i, a);
  let o = e.x + 14;
  e.people.forEach((l) => {
    const u = e.actors[l].color, h = {
      cx: o,
      cy: e.y,
      r: 7,
      fill: u,
      stroke: "#000",
      title: l,
      pos: e.actors[l].position
    };
    P4(i, h), o += 10;
  }), Y4(r)(
    e.task,
    i,
    a.x,
    a.y,
    a.width,
    a.height,
    { class: "task" },
    r,
    e.colour
  );
}, pz = function(t, e) {
  ou(t, {
    x: e.startx,
    y: e.starty,
    width: e.stopx - e.startx,
    height: e.stopy - e.starty,
    fill: e.fill,
    class: "rect"
  }).lower();
}, gz = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    "text-anchor": "start",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0
  };
}, ef = function() {
  return {
    x: 0,
    y: 0,
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
}, Y4 = function() {
  function t(i, s, a, o, l, u, h, f) {
    const d = s.append("text").attr("x", a + l / 2).attr("y", o + u / 2 + 5).style("font-color", f).style("text-anchor", "middle").text(i);
    n(d, h);
  }
  function e(i, s, a, o, l, u, h, f, d) {
    const { taskFontSize: p, taskFontFamily: m } = f, _ = i.split(/<br\s*\/?>/gi);
    for (let v = 0; v < _.length; v++) {
      const k = v * p - p * (_.length - 1) / 2, x = s.append("text").attr("x", a + l / 2).attr("y", o).attr("fill", d).style("text-anchor", "middle").style("font-size", p).style("font-family", m);
      x.append("tspan").attr("x", a + l / 2).attr("dy", k).text(_[v]), x.attr("y", o + u / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), n(x, h);
    }
  }
  function r(i, s, a, o, l, u, h, f) {
    const d = s.append("switch"), m = d.append("foreignObject").attr("x", a).attr("y", o).attr("width", l).attr("height", u).attr("position", "fixed").append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    m.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(i), e(i, d, a, o, l, u, h, f), n(m, h);
  }
  function n(i, s) {
    for (const a in s)
      a in s && i.attr(a, s[a]);
  }
  return function(i) {
    return i.textPlacement === "fo" ? r : i.textPlacement === "old" ? t : e;
  };
}(), yz = function(t) {
  t.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
}, lo = {
  drawRect: ou,
  drawCircle: P4,
  drawSection: fz,
  drawText: V4,
  drawLabel: hz,
  drawTask: dz,
  drawBackgroundRect: pz,
  getTextObj: gz,
  getNoteRect: ef,
  initGraphics: yz
}, mz = function(t) {
  Object.keys(t).forEach(function(r) {
    lu[r] = t[r];
  });
}, $n = {};
function bz(t) {
  const e = q().journey;
  let r = 60;
  Object.keys($n).forEach((n) => {
    const i = $n[n].color, s = {
      cx: 20,
      cy: r,
      r: 7,
      fill: i,
      stroke: "#000",
      pos: $n[n].position
    };
    lo.drawCircle(t, s);
    const a = {
      x: 40,
      y: r + 7,
      fill: "#666",
      text: n,
      textMargin: e.boxTextMargin | 5
    };
    lo.drawText(t, a), r += 20;
  });
}
const lu = q().journey, Bi = lu.leftMargin, _z = function(t, e, r, n) {
  const i = q().journey;
  n.db.clear(), n.parser.parse(t + `
`);
  const s = q().securityLevel;
  let a;
  s === "sandbox" && (a = _t("#i" + e));
  const o = _t(s === "sandbox" ? a.nodes()[0].contentDocument.body : "body");
  Vr.init();
  const l = o.select("#" + e);
  lo.initGraphics(l);
  const u = n.db.getTasks(), h = n.db.getDiagramTitle(), f = n.db.getActors();
  for (const k in $n)
    delete $n[k];
  let d = 0;
  f.forEach((k) => {
    $n[k] = {
      color: i.actorColours[d % i.actorColours.length],
      position: d
    }, d++;
  }), bz(l), Vr.insert(0, 0, Bi, Object.keys($n).length * 50), xz(l, u, 0);
  const p = Vr.getBounds();
  h && l.append("text").text(h).attr("x", Bi).attr("font-size", "4ex").attr("font-weight", "bold").attr("y", 25);
  const m = p.stopy - p.starty + 2 * i.diagramMarginY, _ = Bi + p.stopx + 2 * i.diagramMarginX;
  cn(l, m, _, i.useMaxWidth), l.append("line").attr("x1", Bi).attr("y1", i.height * 4).attr("x2", _ - Bi - 4).attr("y2", i.height * 4).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)");
  const v = h ? 70 : 0;
  l.attr("viewBox", `${p.startx} -25 ${_} ${m + v}`), l.attr("preserveAspectRatio", "xMinYMin meet"), l.attr("height", m + v + 25);
}, Vr = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  init: function() {
    this.sequenceItems = [], this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    }, this.verticalPos = 0;
  },
  updateVal: function(t, e, r, n) {
    t[e] === void 0 ? t[e] = r : t[e] = n(r, t[e]);
  },
  updateBounds: function(t, e, r, n) {
    const i = q().journey, s = this;
    let a = 0;
    function o(l) {
      return function(h) {
        a++;
        const f = s.sequenceItems.length - a + 1;
        s.updateVal(h, "starty", e - f * i.boxMargin, Math.min), s.updateVal(h, "stopy", n + f * i.boxMargin, Math.max), s.updateVal(Vr.data, "startx", t - f * i.boxMargin, Math.min), s.updateVal(Vr.data, "stopx", r + f * i.boxMargin, Math.max), l !== "activation" && (s.updateVal(h, "startx", t - f * i.boxMargin, Math.min), s.updateVal(h, "stopx", r + f * i.boxMargin, Math.max), s.updateVal(Vr.data, "starty", e - f * i.boxMargin, Math.min), s.updateVal(Vr.data, "stopy", n + f * i.boxMargin, Math.max));
      };
    }
    this.sequenceItems.forEach(o());
  },
  insert: function(t, e, r, n) {
    const i = Math.min(t, r), s = Math.max(t, r), a = Math.min(e, n), o = Math.max(e, n);
    this.updateVal(Vr.data, "startx", i, Math.min), this.updateVal(Vr.data, "starty", a, Math.min), this.updateVal(Vr.data, "stopx", s, Math.max), this.updateVal(Vr.data, "stopy", o, Math.max), this.updateBounds(i, a, s, o);
  },
  bumpVerticalPos: function(t) {
    this.verticalPos = this.verticalPos + t, this.data.stopy = this.verticalPos;
  },
  getVerticalPos: function() {
    return this.verticalPos;
  },
  getBounds: function() {
    return this.data;
  }
}, th = lu.sectionFills, W2 = lu.sectionColours, xz = function(t, e, r) {
  const n = q().journey;
  let i = "";
  const s = n.height * 2 + n.diagramMarginY, a = r + s;
  let o = 0, l = "#CCC", u = "black", h = 0;
  for (const [f, d] of e.entries()) {
    if (i !== d.section) {
      l = th[o % th.length], h = o % th.length, u = W2[o % W2.length];
      const m = {
        x: f * n.taskMargin + f * n.width + Bi,
        y: 50,
        text: d.section,
        fill: l,
        num: h,
        colour: u
      };
      lo.drawSection(t, m, n), i = d.section, o++;
    }
    const p = d.people.reduce((m, _) => ($n[_] && (m[_] = $n[_]), m), {});
    d.x = f * n.taskMargin + f * n.width + Bi, d.y = a, d.width = n.diagramMarginX, d.height = n.diagramMarginY, d.colour = u, d.fill = l, d.num = h, d.actors = p, lo.drawTask(t, d, n), Vr.insert(d.x, d.y, d.x + d.width + n.taskMargin, 300 + 5 * 30);
  }
}, H2 = {
  setConf: mz,
  draw: _z
};
let G2 = {};
const vz = function(t) {
  G2 = { ...G2, ...t };
}, kz = (t, e, r) => {
  try {
    B.debug(`Renering svg for syntax error
`);
    const n = _t("#" + e), i = n.append("g");
    i.append("path").attr("class", "error-icon").attr(
      "d",
      "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
    ), i.append("path").attr("class", "error-icon").attr(
      "d",
      "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
    ), i.append("path").attr("class", "error-icon").attr(
      "d",
      "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
    ), i.append("path").attr("class", "error-icon").attr(
      "d",
      "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
    ), i.append("path").attr("class", "error-icon").attr(
      "d",
      "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
    ), i.append("path").attr("class", "error-icon").attr(
      "d",
      "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
    ), i.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in graph"), i.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text("mermaid version " + r), n.attr("height", 100), n.attr("width", 500), n.attr("viewBox", "768 0 912 512");
  } catch (n) {
    B.error("Error while rendering info diagram"), B.error(eE(n));
  }
}, pc = {
  setConf: vz,
  draw: kz
}, z4 = "flowchart-elk", wz = (t, e) => {
  var r;
  return (
    // If diagram explicitly states flowchart-elk
    !!(t.match(/^\s*flowchart-elk/) || // If a flowchart/graph diagram has their default renderer set to elk
    t.match(/^\s*flowchart|graph/) && ((r = e == null ? void 0 : e.flowchart) == null ? void 0 : r.defaultRenderer) === "elk")
  );
}, Tz = async () => {
  const { diagram: t } = await import("./flowchart-elk-definition-09af5231.js");
  return { id: z4, diagram: t };
}, Ez = {
  id: z4,
  detector: wz,
  loader: Tz
}, Cz = Ez, U4 = "timeline", Sz = (t) => t.match(/^\s*timeline/) !== null, Az = async () => {
  const { diagram: t } = await import("./timeline-definition-d4078a23.js");
  return { id: U4, diagram: t };
}, Lz = {
  id: U4,
  detector: Sz,
  loader: Az
}, Bz = Lz, W4 = "mindmap", Dz = (t) => t.match(/^\s*mindmap/) !== null, Iz = async () => {
  const { diagram: t } = await import("./mindmap-definition-9cae3198.js");
  return { id: W4, diagram: t };
}, Mz = {
  id: W4,
  detector: Dz,
  loader: Iz
}, Nz = Mz;
let q2 = !1;
const Eo = () => {
  q2 || (q2 = !0, Ng(Cz, Bz, Nz), ze(
    "error",
    // Special diagram with error messages but setup as a regular diagram
    {
      db: {
        clear: () => {
        }
      },
      styles: Dh,
      renderer: pc,
      parser: {
        parser: { yy: {} },
        parse: () => {
        }
      },
      init: () => {
      }
    },
    (t) => t.toLowerCase().trim() === "error"
  ), ze(
    "---",
    // --- diagram type may appear if YAML front-matter is not parsed correctly
    {
      db: {
        clear: () => {
        }
      },
      styles: Dh,
      // should never be used
      renderer: pc,
      // should never be used
      parser: {
        parser: { yy: {} },
        parse: () => {
          throw new Error(
            "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with unindented `---` blocks"
          );
        }
      },
      init: () => null
      // no op
    },
    (t) => t.toLowerCase().trimStart().startsWith("---")
  ), ze(
    "c4",
    {
      parser: TC,
      db: by,
      renderer: kd,
      styles: oy,
      init: (t) => {
        kd.setConf(t.c4);
      }
    },
    EC
  ), ze(
    "class",
    {
      parser: wd,
      db: ps,
      renderer: rN,
      styles: Sa,
      init: (t) => {
        t.class || (t.class = {}), t.class.arrowMarkerAbsolute = t.arrowMarkerAbsolute, ps.clear();
      }
    },
    m9
  ), ze(
    "classDiagram",
    {
      parser: wd,
      db: ps,
      renderer: mR,
      styles: Sa,
      init: (t) => {
        t.class || (t.class = {}), t.class.arrowMarkerAbsolute = t.arrowMarkerAbsolute, ps.clear();
      }
    },
    b9
  ), ze(
    "er",
    {
      parser: bR,
      db: AR,
      renderer: QR,
      styles: ty
    },
    _R
  ), ze(
    "gantt",
    {
      parser: KF,
      db: H0,
      renderer: OO,
      styles: ey
    },
    ZF
  ), ze(
    "info",
    {
      parser: PO,
      db: WO,
      renderer: GO,
      styles: ry
    },
    qO
  ), ze(
    "pie",
    {
      parser: $O,
      db: rP,
      renderer: iP,
      styles: ny
    },
    jO
  ), ze(
    "requirement",
    {
      parser: sP,
      db: EP,
      renderer: NP,
      styles: iy
    },
    aP
  ), ze(
    "sequence",
    {
      parser: RP,
      db: B2,
      renderer: I2,
      styles: sy,
      init: (t) => {
        if (t.sequence || (t.sequence = {}), t.sequence.arrowMarkerAbsolute = t.arrowMarkerAbsolute, "sequenceDiagram" in t)
          throw new Error(
            "`mermaid config.sequenceDiagram` has been renamed to `config.sequence`. Please update your mermaid config."
          );
        B2.setWrap(t.wrap), I2.setConf(t.sequence);
      }
    },
    FP
  ), ze(
    "state",
    {
      parser: M2,
      db: Yn,
      renderer: AY,
      styles: Hl,
      init: (t) => {
        t.state || (t.state = {}), t.state.arrowMarkerAbsolute = t.arrowMarkerAbsolute, Yn.clear();
      }
    },
    FV
  ), ze(
    "stateDiagram",
    {
      parser: M2,
      db: Yn,
      renderer: QY,
      styles: Hl,
      init: (t) => {
        t.state || (t.state = {}), t.state.arrowMarkerAbsolute = t.arrowMarkerAbsolute, Yn.clear();
      }
    },
    OV
  ), ze(
    "journey",
    {
      parser: JY,
      db: z2,
      renderer: H2,
      styles: ay,
      init: (t) => {
        H2.setConf(t.journey), z2.clear();
      }
    },
    tz
  ), ze(
    "flowchart",
    {
      parser: T2,
      db: gn,
      renderer: Ku,
      styles: Wl,
      init: (t) => {
        t.flowchart || (t.flowchart = {}), t.flowchart.arrowMarkerAbsolute = t.arrowMarkerAbsolute, qF.setConf(t.flowchart), gn.clear(), gn.setGen("gen-1");
      }
    },
    JR
  ), ze(
    "flowchart-v2",
    {
      parser: T2,
      db: gn,
      renderer: Ku,
      styles: Wl,
      init: (t) => {
        t.flowchart || (t.flowchart = {}), t.flowchart.arrowMarkerAbsolute = t.arrowMarkerAbsolute, Kg({ flowchart: { arrowMarkerAbsolute: t.arrowMarkerAbsolute } }), Ku.setConf(t.flowchart), gn.clear(), gn.setGen("gen-2");
      }
    },
    tF
  ), ze(
    "gitGraph",
    { parser: $E, db: dC, renderer: vC, styles: wC },
    jE
  ));
};
class E1 {
  constructor(e, r) {
    var a, o;
    this.txt = e, this.type = "graph", this.detectTypeFailed = !1;
    const n = q();
    this.txt = e;
    try {
      this.type = Q1(e, n);
    } catch (l) {
      this.handleError(l, r), this.type = "error", this.detectTypeFailed = !0;
    }
    const i = uy(this.type);
    B.debug("Type " + this.type), this.db = i.db, (o = (a = this.db).clear) == null || o.call(a), this.renderer = i.renderer, this.parser = i.parser;
    const s = this.parser.parse.bind(this.parser);
    this.parser.parse = (l) => s(Mw(l, this.db)), this.parser.parser.yy = this.db, i.init && (i.init(n), B.info("Initialized diagram " + this.type, n)), this.txt += `
`, this.parse(this.txt, r);
  }
  parse(e, r) {
    var n, i;
    if (this.detectTypeFailed)
      return !1;
    try {
      return e = e + `
`, (i = (n = this.db).clear) == null || i.call(n), this.parser.parse(e), !0;
    } catch (s) {
      this.handleError(s, r);
    }
    return !1;
  }
  handleError(e, r) {
    if (r === void 0)
      throw e;
    if (t0(e)) {
      r(e.str, e.hash);
      return;
    }
    r(e);
  }
  getParser() {
    return this.parser;
  }
  getType() {
    return this.type;
  }
}
const rf = (t, e) => {
  const r = Q1(t, q());
  try {
    uy(r);
  } catch {
    const i = Fw(r);
    if (!i)
      throw new Error(`Diagram ${r} not found.`);
    return i().then(({ diagram: s }) => (ze(r, s, void 0), new E1(t, e)));
  }
  return new E1(t, e);
}, nf = E1, Rz = "graphics-document document";
function Fz(t, e) {
  t.attr("role", Rz), vs(e) || t.attr("aria-roledescription", e);
}
function Oz(t, e, r, n) {
  if (t.insert !== void 0)
    if (e || r) {
      if (r) {
        const i = "chart-desc-" + n;
        t.attr("aria-describedby", i), t.insert("desc", ":first-child").attr("id", i).text(r);
      }
      if (e) {
        const i = "chart-title-" + n;
        t.attr("aria-labelledby", i), t.insert("title", ":first-child").attr("id", i).text(e);
      }
    } else
      return;
}
const sf = ["graph", "flowchart", "flowchart-v2", "stateDiagram", "stateDiagram-v2"], H4 = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa", G4 = "sandbox", q4 = "loose", Pz = "http://www.w3.org/2000/svg", $4 = "http://www.w3.org/1999/xlink", j4 = "http://www.w3.org/1999/xhtml", Vz = "100%", Yz = "100%", zz = "border:0;margin:0;", Uz = "margin:0", Wz = "allow-top-navigation-by-user-activation allow-popups", Hz = 'The "iframe" tag is not supported by your browser.', X4 = ["foreignobject"], K4 = ["dominant-baseline"];
function Gz(t, e) {
  return Eo(), new nf(t, e).parse(t, e);
}
async function qz(t, e) {
  return Eo(), (await rf(t, e)).parse(t, e);
}
const Z4 = function(t) {
  let e = t;
  return e = e.replace(/style.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), e = e.replace(/classDef.*:\S*#.*;/g, function(r) {
    return r.substring(0, r.length - 1);
  }), e = e.replace(/#\w+;/g, function(r) {
    const n = r.substring(1, r.length - 1);
    return /^\+?\d+$/.test(n) ? "" + n + "" : "" + n + "";
  }), e;
}, af = function(t) {
  let e = t;
  return e = e.replace(//g, "&#"), e = e.replace(//g, "&"), e = e.replace(//g, ";"), e;
}, $2 = (t, e, r = []) => `
.${t} ${e} { ${r.join(" !important; ")} !important; }`, $z = (t, e, r = {}) => {
  var i;
  let n = "";
  if (t.themeCSS !== void 0 && (n += `
${t.themeCSS}`), t.fontFamily !== void 0 && (n += `
:root { --mermaid-font-family: ${t.fontFamily}}`), t.altFontFamily !== void 0 && (n += `
:root { --mermaid-alt-font-family: ${t.altFontFamily}}`), !vs(r) && sf.includes(e)) {
    const l = t.htmlLabels || ((i = t.flowchart) == null ? void 0 : i.htmlLabels) ? ["> *", "span"] : ["rect", "polygon", "ellipse", "circle", "path"];
    for (const u in r) {
      const h = r[u];
      vs(h.styles) || l.forEach((f) => {
        n += $2(h.id, f, h.styles);
      }), vs(h.textStyles) || (n += $2(h.id, "tspan", h.textStyles));
    }
  }
  return n;
}, Q4 = (t, e, r, n) => {
  const i = $z(t, e, r), s = PE(e, i, t.themeVariables);
  return Bh(gE(`${n}{${s}}`), mE);
}, J4 = (t = "", e, r) => {
  let n = t;
  return !r && !e && (n = n.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#')), n = af(n), n = n.replace(/<br>/g, "<br/>"), n;
}, t5 = (t = "", e) => {
  const r = e ? e.viewBox.baseVal.height + "px" : Yz, n = btoa('<body style="' + Uz + '">' + t + "</body>");
  return `<iframe style="width:${Vz};height:${r};${zz}" src="data:text/html;base64,${n}" sandbox="${Wz}">
  ${Hz}
</iframe>`;
}, gc = (t, e, r, n, i) => {
  const s = t.append("div");
  s.attr("id", r), n && s.attr("style", n);
  const a = s.append("svg").attr("id", e).attr("width", "100%").attr("xmlns", Pz);
  return i && a.attr("xmlns:xlink", i), a.append("g"), t;
};
function yc(t, e) {
  return t.append("iframe").attr("id", e).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
}
const e5 = (t, e, r, n) => {
  var i, s, a;
  (i = t.getElementById(e)) == null || i.remove(), (s = t.getElementById(r)) == null || s.remove(), (a = t.getElementById(n)) == null || a.remove();
}, jz = function(t, e, r, n) {
  var g, M, y, N;
  Eo(), Ha();
  const i = jt.detectInit(e);
  i && (Yi(i), n0(i));
  const s = q();
  B.debug(s), e.length > ((s == null ? void 0 : s.maxTextSize) ?? 5e4) && (e = H4), e = e.replace(/\r\n?/g, `
`);
  const a = "#" + t, o = "i" + t, l = "#" + o, u = "d" + t, h = "#" + u;
  let f = _t("body");
  const d = s.securityLevel === G4, p = s.securityLevel === q4, m = s.fontFamily;
  if (n !== void 0) {
    if (n && (n.innerHTML = ""), d) {
      const it = yc(_t(n), o);
      f = _t(it.nodes()[0].contentDocument.body), f.node().style.margin = 0;
    } else
      f = _t(n);
    gc(f, t, u, `font-family: ${m}`, $4);
  } else {
    if (e5(document, t, u, o), d) {
      const it = yc(_t("body"), o);
      f = _t(it.nodes()[0].contentDocument.body), f.node().style.margin = 0;
    } else
      f = _t("body");
    gc(f, t, u);
  }
  e = Z4(e);
  let _, v;
  try {
    if (_ = rf(e), "then" in _)
      throw new Error("Diagram is a promise. Use renderAsync.");
  } catch (it) {
    _ = new nf("error"), v = it;
  }
  const k = f.select(h).node(), x = _.type, D = k.firstChild, F = D.firstChild, P = sf.includes(x) ? _.renderer.getClasses(e, _) : {}, V = Q4(
    s,
    x,
    // @ts-ignore convert renderer to TS.
    P,
    a
  ), R = document.createElement("style");
  R.innerHTML = V, D.insertBefore(R, F);
  try {
    _.renderer.draw(e, t, Ul, _);
  } catch (it) {
    throw pc.draw(e, t, Ul), it;
  }
  const O = f.select(`${h} svg`), C = (M = (g = _.db).getAccTitle) == null ? void 0 : M.call(g), S = (N = (y = _.db).getAccDescription) == null ? void 0 : N.call(y);
  r5(x, O, C, S), f.select(`[id="${t}"]`).selectAll("foreignobject > *").attr("xmlns", j4);
  let T = f.select(h).node().innerHTML;
  if (B.debug("config.arrowMarkerAbsolute", s.arrowMarkerAbsolute), T = J4(T, d, Ke(s.arrowMarkerAbsolute)), d) {
    const it = f.select(h + " svg").node();
    T = t5(T, it);
  } else
    p || (T = Va.sanitize(T, {
      ADD_TAGS: X4,
      ADD_ATTR: K4
    }));
  if (r !== void 0)
    switch (x) {
      case "flowchart":
      case "flowchart-v2":
        r(T, gn.bindFunctions);
        break;
      case "gantt":
        r(T, H0.bindFunctions);
        break;
      case "class":
      case "classDiagram":
        r(T, ps.bindFunctions);
        break;
      default:
        r(T);
    }
  else
    B.debug("CB = undefined!");
  l4();
  const w = _t(d ? l : h).node();
  if (w && "remove" in w && w.remove(), v)
    throw v;
  return T;
}, Xz = async function(t, e, r, n) {
  var g, M, y, N;
  Eo(), Ha();
  const i = jt.detectInit(e);
  i && (Yi(i), n0(i));
  const s = q();
  B.debug(s), e.length > ((s == null ? void 0 : s.maxTextSize) ?? 5e4) && (e = H4), e = e.replace(/\r\n?/g, `
`);
  const a = "#" + t, o = "i" + t, l = "#" + o, u = "d" + t, h = "#" + u;
  let f = _t("body");
  const d = s.securityLevel === G4, p = s.securityLevel === q4, m = s.fontFamily;
  if (n !== void 0) {
    if (n && (n.innerHTML = ""), d) {
      const it = yc(_t(n), o);
      f = _t(it.nodes()[0].contentDocument.body), f.node().style.margin = 0;
    } else
      f = _t(n);
    gc(f, t, u, `font-family: ${m}`, $4);
  } else {
    if (e5(document, t, u, o), d) {
      const it = yc(_t("body"), o);
      f = _t(it.nodes()[0].contentDocument.body), f.node().style.margin = 0;
    } else
      f = _t("body");
    gc(f, t, u);
  }
  e = Z4(e);
  let _, v;
  try {
    _ = await rf(e);
  } catch (it) {
    _ = new nf("error"), v = it;
  }
  const k = f.select(h).node(), x = _.type, D = k.firstChild, F = D.firstChild, P = sf.includes(x) ? _.renderer.getClasses(e, _) : {}, V = Q4(
    s,
    x,
    // @ts-ignore convert renderer to TS.
    P,
    a
  ), R = document.createElement("style");
  R.innerHTML = V, D.insertBefore(R, F);
  try {
    await _.renderer.draw(e, t, Ul, _);
  } catch (it) {
    throw pc.draw(e, t, Ul), it;
  }
  const O = f.select(`${h} svg`), C = (M = (g = _.db).getAccTitle) == null ? void 0 : M.call(g), S = (N = (y = _.db).getAccDescription) == null ? void 0 : N.call(y);
  r5(x, O, C, S), f.select(`[id="${t}"]`).selectAll("foreignobject > *").attr("xmlns", j4);
  let T = f.select(h).node().innerHTML;
  if (B.debug("config.arrowMarkerAbsolute", s.arrowMarkerAbsolute), T = J4(T, d, Ke(s.arrowMarkerAbsolute)), d) {
    const it = f.select(h + " svg").node();
    T = t5(T, it);
  } else
    p || (T = Va.sanitize(T, {
      ADD_TAGS: X4,
      ADD_ATTR: K4
    }));
  if (r !== void 0)
    switch (x) {
      case "flowchart":
      case "flowchart-v2":
        r(T, gn.bindFunctions);
        break;
      case "gantt":
        r(T, H0.bindFunctions);
        break;
      case "class":
      case "classDiagram":
        r(T, ps.bindFunctions);
        break;
      default:
        r(T);
    }
  else
    B.debug("CB = undefined!");
  l4();
  const w = _t(d ? l : h).node();
  if (w && "remove" in w && w.remove(), v)
    throw v;
  return T;
};
function Kz(t = {}) {
  var r;
  t != null && t.fontFamily && !((r = t.themeVariables) != null && r.fontFamily) && (t.themeVariables = { fontFamily: t.fontFamily }), _E(t), t != null && t.theme && t.theme in jn ? t.themeVariables = jn[t.theme].getThemeVariables(
    t.themeVariables
  ) : t && (t.themeVariables = jn.default.getThemeVariables(t.themeVariables));
  const e = typeof t == "object" ? bE(t) : Xg();
  C1(e.logLevel), Eo();
}
function r5(t, e, r, n) {
  Fz(e, t), Oz(e, r, n, e.attr("id"));
}
const xe = Object.freeze({
  render: jz,
  renderAsync: Xz,
  parse: Gz,
  parseAsync: qz,
  parseDirective: ly,
  initialize: Kz,
  getConfig: q,
  setConfig: Kg,
  getSiteConfig: Xg,
  updateSiteConfig: xE,
  reset: () => {
    Ha();
  },
  globalReset: () => {
    Ha(Fs);
  },
  defaultConfig: Fs
});
C1(q().logLevel);
Ha(q());
const Zz = async function(t, e, r) {
  try {
    await i5(t, e, r);
  } catch (n) {
    B.warn("Syntax Error rendering"), t0(n) && B.warn(n.str), an.parseError && an.parseError(n);
  }
}, n5 = (t, e, r) => {
  B.warn(t), t0(t) ? (r && r(t.str, t.hash), e.push({ ...t, message: t.str, error: t })) : (r && r(t), t instanceof Error && e.push({
    str: t.message,
    message: t.message,
    hash: t.name,
    error: t
  }));
}, Qz = function(t, e, r) {
  const n = xe.getConfig();
  t && (an.sequenceConfig = t), B.debug(`${r ? "" : "No "}Callback function found`);
  let i;
  if (e === void 0)
    i = document.querySelectorAll(".mermaid");
  else if (typeof e == "string")
    i = document.querySelectorAll(e);
  else if (e instanceof HTMLElement)
    i = [e];
  else if (e instanceof NodeList)
    i = e;
  else
    throw new Error("Invalid argument nodes for mermaid.init");
  B.debug(`Found ${i.length} diagrams`), (t == null ? void 0 : t.startOnLoad) !== void 0 && (B.debug("Start On Load: " + (t == null ? void 0 : t.startOnLoad)), xe.updateSiteConfig({ startOnLoad: t == null ? void 0 : t.startOnLoad }));
  const s = new jt.initIdGenerator(n.deterministicIds, n.deterministicIDSeed);
  let a;
  const o = [];
  for (const l of Array.from(i)) {
    B.info("Rendering diagram: " + l.id);
    /*! Check if previously processed */
    if (l.getAttribute("data-processed"))
      continue;
    l.setAttribute("data-processed", "true");
    const u = `mermaid-${s.next()}`;
    a = l.innerHTML, a = j2(jt.entityDecode(a)).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const h = jt.detectInit(a);
    h && B.debug("Detected early reinit: ", h);
    try {
      xe.render(
        u,
        a,
        (f, d) => {
          l.innerHTML = f, r !== void 0 && r(u), d && d(l);
        },
        l
      );
    } catch (f) {
      n5(f, o, an.parseError);
    }
  }
  if (o.length > 0)
    throw o[0];
}, Jz = async (...t) => {
  B.debug(`Loading ${t.length} external diagrams`);
  const r = (await Promise.allSettled(
    t.map(async ({ id: n, detector: i, loader: s }) => {
      const { diagram: a } = await s();
      ze(n, a, i);
    })
  )).filter((n) => n.status === "rejected");
  if (r.length > 0) {
    B.error(`Failed to load ${r.length} external diagrams`);
    for (const n of r)
      B.error(n);
    throw new Error(`Failed to load ${r.length} external diagrams`);
  }
}, i5 = async function(t, e, r) {
  const n = xe.getConfig();
  t && (an.sequenceConfig = t), B.debug(`${r ? "" : "No "}Callback function found`);
  let i;
  if (e === void 0)
    i = document.querySelectorAll(".mermaid");
  else if (typeof e == "string")
    i = document.querySelectorAll(e);
  else if (e instanceof HTMLElement)
    i = [e];
  else if (e instanceof NodeList)
    i = e;
  else
    throw new Error("Invalid argument nodes for mermaid.init");
  B.debug(`Found ${i.length} diagrams`), (t == null ? void 0 : t.startOnLoad) !== void 0 && (B.debug("Start On Load: " + (t == null ? void 0 : t.startOnLoad)), xe.updateSiteConfig({ startOnLoad: t == null ? void 0 : t.startOnLoad }));
  const s = new jt.initIdGenerator(n.deterministicIds, n.deterministicIDSeed);
  let a;
  const o = [];
  for (const l of Array.from(i)) {
    B.info("Rendering diagram: " + l.id);
    /*! Check if previously processed */
    if (l.getAttribute("data-processed"))
      continue;
    l.setAttribute("data-processed", "true");
    const u = `mermaid-${s.next()}`;
    a = l.innerHTML, a = j2(jt.entityDecode(a)).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const h = jt.detectInit(a);
    h && B.debug("Detected early reinit: ", h);
    try {
      await xe.renderAsync(
        u,
        a,
        (f, d) => {
          l.innerHTML = f, r !== void 0 && r(u), d && d(l);
        },
        l
      );
    } catch (f) {
      n5(f, o, an.parseError);
    }
  }
  if (o.length > 0)
    throw o[0];
}, tU = function(t) {
  xe.initialize(t);
}, eU = async (t, {
  lazyLoad: e = !0
} = {}) => {
  e ? Ng(...t) : await Jz(...t);
}, s5 = function() {
  if (an.startOnLoad) {
    const { startOnLoad: t } = xe.getConfig();
    t && an.init().catch((e) => B.error("Mermaid failed to initialize", e));
  }
};
if (typeof document < "u") {
  /*!
   * Wait for document loaded before starting the execution
   */
  window.addEventListener("load", s5, !1);
}
const rU = function(t) {
  an.parseError = t;
}, nU = (t) => xe.parse(t, an.parseError), mc = [];
let eh = !1;
const a5 = async () => {
  if (!eh) {
    for (eh = !0; mc.length > 0; ) {
      const t = mc.shift();
      if (t)
        try {
          await t();
        } catch (e) {
          B.error("Error executing queue", e);
        }
    }
    eh = !1;
  }
}, iU = (t) => new Promise((e, r) => {
  const n = () => new Promise((i, s) => {
    xe.parseAsync(t, an.parseError).then(
      (a) => {
        i(a), e(a);
      },
      (a) => {
        B.error("Error parsing", a), s(a), r(a);
      }
    );
  });
  mc.push(n), a5().catch(r);
}), sU = (t, e, r, n) => new Promise((i, s) => {
  const a = () => new Promise((o, l) => {
    xe.renderAsync(t, e, r, n).then(
      (u) => {
        o(u), i(u);
      },
      (u) => {
        B.error("Error parsing", u), l(u), s(u);
      }
    );
  });
  mc.push(a), a5().catch(s);
}), an = {
  startOnLoad: !0,
  diagrams: {},
  mermaidAPI: xe,
  parse: nU,
  parseAsync: iU,
  render: xe.render,
  renderAsync: sU,
  init: Zz,
  initThrowsErrors: Qz,
  initThrowsErrorsAsync: i5,
  registerExternalDiagrams: eU,
  initialize: tU,
  parseError: void 0,
  contentLoaded: s5,
  setParseErrorHandler: rU
};
export {
  Zn as C,
  ee as _,
  q as a,
  Oc as b,
  bc as c,
  yi as d,
  Ke as e,
  N0 as f,
  aU as g,
  Xt as h,
  yN as i,
  KN as j,
  Qr as k,
  B as l,
  Ar as m,
  oR as n,
  js as o,
  fU as p,
  T2 as q,
  YE as r,
  _t as s,
  ly as t,
  Br as u,
  xh as v,
  zt as w,
  Zt as x,
  Ur as y,
  an as z
};
//# sourceMappingURL=mermaid-eb8c45e6.js.map
